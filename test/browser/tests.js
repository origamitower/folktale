(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var __metamagical_withMeta = function metamagical_withMeta(object, meta) {
  var parent = Object.getPrototypeOf(object);var oldMeta = object[Symbol.for('@@meta:magical')] || {};if (parent && parent[Symbol.for('@@meta:magical')] === oldMeta) {
    oldMeta = {};
  }Object.keys(meta).forEach(function (key) {
    if (/^~/.test(key)) {
      oldMeta[key.slice(1)] = meta[key];
    } else {
      oldMeta[key] = meta[key];
    }
  });object[Symbol.for('@@meta:magical')] = oldMeta;return object;
},
    __metamagical_assert_equals = function metamagical_assert_equals(assert, actual, expected, message) {
  var assertionType = Symbol.for('@@meta:magical:assertion-type');var rest = Symbol.for('@@meta:magical:assertion-rest');var keys = Object.keys;function isSetoid(value) {
    return value && typeof value.equals === 'function';
  }function isRecord(value) {
    return value && value[assertionType] === 'record';
  }function check(predicate) {
    for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }return values.every(predicate);
  }function getSpecialArrayLength(array) {
    var rests = array.map(function (x, i) {
      return [x, i];
    }).filter(function (pair) {
      return pair[0] === rest;
    });if (rests.length > 1 || rests[0] && rests[0][1] !== array.length - 1) {
      assert.ok(false, message + '. Assertions only support a single trailing rest indication for arrays currently.');
    }return (rests[0] || [null, array.length])[1];
  }function compareArrays(left, right) {
    var expectedLength = getSpecialArrayLength(right);assert.ok(Array.isArray(left), message + '. The LHS is not an array.');if (left.length < expectedLength) {
      assert.ok(false, message + '. The LHS does not have the minimum expected length (' + left.length + ' < ' + expectedLength + ')');
    }for (var i = 0; i < expectedLength; ++i) {
      compare(left[i], right[i]);
    }
  }function compareRecord(left, right) {
    var isPartial = right[rest];assert.ok(Object(left) === left, message);if (!isPartial) {
      assert.deepStrictEqual(keys(left).sort(), keys(right).sort(), message + '. The objects have different keys ([' + keys(left).sort().join(', ') + '] vs. [' + keys(right).sort().join(', ') + '])');
    }Object.keys(right).forEach(function (key) {
      if (!(key in left)) {
        assert.ok(false, message + '. The expected key ' + key + ' is not present in the actual object.');
      }compare(left[key], right[key]);
    });
  }function compare(l, r) {
    return check(isSetoid, l, r) ? assert.ok(l.equals(r), message + '. The LHS (' + l + ') setoid instance says the LHS and RHS (' + r + ') are not equal.') : Array.isArray(r) ? compareArrays(l, r) : isRecord(r) ? compareRecord(l, r) : /* otherwise */assert.deepStrictEqual(l, r, message + '. The LHS (' + l + ') and the RHS (' + r + ') are not structually equal.');
  }compare(actual, expected);
},
    _metamagical_withMet;

function _defineEnumerableProperties(obj, descs) { for (var key in descs) { var desc = descs[key]; desc.configurable = desc.enumerable = true; if ("value" in desc) desc.writable = true; Object.defineProperty(obj, key, desc); } return obj; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

// --[ Dependencies ]---------------------------------------------------
var warnDeprecation = require('../../helpers/warnDeprecation');

// --[ Constants and Aliases ]------------------------------------------
var TYPE = Symbol.for('@@folktale:adt:type');
var TAG = Symbol.for('@@folktale:adt:tag');
var META = Symbol.for('@@meta:magical');

var keys = Object.keys;
var symbols = Object.getOwnPropertySymbols;
var defineProperty = Object.defineProperty;
var property = Object.getOwnPropertyDescriptor;

// --[ Helpers ]--------------------------------------------------------

/*~
 * Returns an array of own enumerable values in an object.
 */
function values(object) {
  return keys(object).map(function (key) {
    return object[key];
  });
}

/*~
 * Transforms own enumerable key/value pairs.
 */

__metamagical_withMeta(values, {
  'name': 'values',
  'source': 'function values(object) {\n  return keys(object).map(key => object[key]);\n}',
  'signature': 'values(object)',
  'location': {
    'filename': 'src/core/adt/core.js',
    'start': {
      'line': 30,
      'column': 0
    },
    'end': {
      'line': 32,
      'column': 1
    }
  },
  'module': 'folktale/src/core/adt/core',
  'licence': 'MIT',
  'authors': ['Quildreen Motta'],
  'repository': 'https://github.com/origamitower/folktale',
  'npmPackage': 'folktale',
  'documentation': '\nReturns an array of own enumerable values in an object.\n '
});

function mapObject(object, transform) {
  return keys(object).reduce(function (result, key) {
    result[key] = transform(key, object[key]);
    return result;
  }, {});
}

/*~
 * Extends an objects with own enumerable key/value pairs from other sources.
 * 
 * This is used to define objects for the ADTs througout this file, and there
 * are some important differences from Object.assign:
 * 
 *   - This code is only concerned with own enumerable property *names*.
 *   - Additionally this code copies all own symbols (important for tags).
 * 
 * When copying, this function copies **whole property descriptors**, which
 * means getters/setters are not executed during the copying. The only
 * exception is when the property name is `prototype`, which is not
 * configurable in functions by default.
 * 
 * This code only special cases `prototype` because any other non-configurable
 * property is considered an error, and should crash the program so it can be
 * fixed.
 */

__metamagical_withMeta(mapObject, {
  'name': 'mapObject',
  'source': 'function mapObject(object, transform) {\n  return keys(object).reduce((result, key) => {\n    result[key] = transform(key, object[key]);\n    return result;\n  }, {});\n}',
  'signature': 'mapObject(object, transform)',
  'location': {
    'filename': 'src/core/adt/core.js',
    'start': {
      'line': 38,
      'column': 0
    },
    'end': {
      'line': 43,
      'column': 1
    }
  },
  'module': 'folktale/src/core/adt/core',
  'licence': 'MIT',
  'authors': ['Quildreen Motta'],
  'repository': 'https://github.com/origamitower/folktale',
  'npmPackage': 'folktale',
  'documentation': '\nTransforms own enumerable key/value pairs.\n '
});

function extend(target) {
  for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    sources[_key - 1] = arguments[_key];
  }

  sources.forEach(function (source) {
    keys(source).forEach(function (key) {
      if (key === 'prototype') {
        target[key] = source[key];
      } else {
        defineProperty(target, key, property(source, key));
      }
    });
    symbols(source).forEach(function (symbol) {
      defineProperty(target, symbol, property(source, symbol));
    });
  });
  return target;
}

// --[ Variant implementation ]-----------------------------------------

/*~
 * Defines the variants given a set of patterns and an ADT namespace.
 */

__metamagical_withMeta(extend, {
  'name': 'extend',
  'source': 'function extend(target, ...sources) {\n  sources.forEach(source => {\n    keys(source).forEach(key => {\n      if (key === \'prototype\') {\n        target[key] = source[key];\n      } else {\n        defineProperty(target, key, property(source, key));\n      }\n    });\n    symbols(source).forEach(symbol => {\n      defineProperty(target, symbol, property(source, symbol));\n    });\n  });\n  return target;\n}',
  'signature': 'extend(target, ...sources)',
  'location': {
    'filename': 'src/core/adt/core.js',
    'start': {
      'line': 64,
      'column': 0
    },
    'end': {
      'line': 78,
      'column': 1
    }
  },
  'module': 'folktale/src/core/adt/core',
  'licence': 'MIT',
  'authors': ['Quildreen Motta'],
  'repository': 'https://github.com/origamitower/folktale',
  'npmPackage': 'folktale',
  'documentation': '\nExtends an objects with own enumerable key/value pairs from other sources.\n\nThis is used to define objects for the ADTs througout this file, and there\nare some important differences from Object.assign:\n\n  - This code is only concerned with own enumerable property *names*.\n  - Additionally this code copies all own symbols (important for tags).\n\nWhen copying, this function copies **whole property descriptors**, which\nmeans getters/setters are not executed during the copying. The only\nexception is when the property name is `prototype`, which is not\nconfigurable in functions by default.\n\nThis code only special cases `prototype` because any other non-configurable\nproperty is considered an error, and should crash the program so it can be\nfixed.\n '
});

function defineVariants(typeId, patterns, adt) {
  return mapObject(patterns, function (name, constructor) {
    var _extend, _ref, _extend2, _mutatorMap, _extend3, _tag, _type, _constructor, _extend4, _mutatorMap2;

    // ---[ Variant Internals ]-----------------------------------------
    function InternalConstructor() {}
    InternalConstructor.prototype = Object.create(adt);

    extend(InternalConstructor.prototype, (_extend = (_extend2 = {}, _defineProperty(_extend2, TAG, name), _defineProperty(_extend2, 'constructor', constructor), _ref = 'is' + name, _mutatorMap = {}, _mutatorMap[_ref] = _mutatorMap[_ref] || {}, _mutatorMap[_ref].get = function () {
      warnDeprecation('.is' + name + ' is deprecated. Use ' + name + '.hasInstance(value)\ninstead to check if a value belongs to the ADT variant.');
      return true;
    }, _defineProperty(_extend2, 'cata', function cata(pattern) {
      warnDeprecation('`.cata(pattern)` is deprecated. Use `.matchWith(pattern)` instead.');
      return this.matchWith(pattern);
    }), _defineProperty(_extend2, 'matchWith', function matchWith(pattern) {
      return pattern[name](this);
    }), _defineEnumerableProperties(_extend2, _mutatorMap), _extend2), __metamagical_withMeta(Object.getOwnPropertyDescriptor(_extend, 'is' + name).get, {
      'source': 'get [`is${name}`]() {\n        warnDeprecation(`.is${name} is deprecated. Use ${name}.hasInstance(value)\ninstead to check if a value belongs to the ADT variant.`);\n        return true;\n      }',
      'location': {
        'filename': 'src/core/adt/core.js',
        'start': {
          'line': 92,
          'column': 42
        },
        'end': {
          'line': 184,
          'column': 5
        }
      },
      'module': 'folktale/src/core/adt/core',
      'licence': 'MIT',
      'authors': ['Quildreen Motta'],
      'repository': 'https://github.com/origamitower/folktale',
      'npmPackage': 'folktale',
      'category': 'Testing and Comparing',
      'deprecated': {
        'version': '2.0.0',
        'replacedBy': '.hasInstance(value)',
        'reason': 'Having a `value.isFoo` property doesn\'t allow people to\ndifferentiate two variants from different ADTs that have the\nsame name. So, instead, now variants and ADTs come with a\nstatic `.hasInstance(value)` method.\n'
      },
      '~belongsTo': function belongsTo() {
        return constructor;
      },
      'documentation': '\nTrue if a value belongs to the ADT variant.\n'
    }), __metamagical_withMeta(_extend['cata'], {
      'name': 'cata',
      'source': 'cata(pattern) {\n        warnDeprecation(\'`.cata(pattern)` is deprecated. Use `.matchWith(pattern)` instead.\');\n        return this.matchWith(pattern);\n      }',
      'signature': 'cata(pattern)',
      'location': {
        'filename': 'src/core/adt/core.js',
        'start': {
          'line': 92,
          'column': 42
        },
        'end': {
          'line': 184,
          'column': 5
        }
      },
      'module': 'folktale/src/core/adt/core',
      'licence': 'MIT',
      'authors': ['Quildreen Motta'],
      'repository': 'https://github.com/origamitower/folktale',
      'npmPackage': 'folktale',
      'category': 'Transforming',
      'type': '(\'a is Variant).({ \'b: (Object Any) => \'c }) => \'c\nwhere \'b = \'a[`@@folktale:adt:tag]\n',
      'deprecated': {
        'version': '2.0.0',
        'replacedBy': '.matchWith(pattern)',
        'reason': '`.cata()` is not a very intuitive name, and most people are\nnot familiar with the term `catamorphism` either. `.matchWith()`\nis more familiar and conveys more information to more people.\n'
      },
      '~belongsTo': function belongsTo() {
        return constructor;
      },
      'documentation': '\nSelects an operation based on this Variant\'s tag.\n\nThe `cata`morphism operation allows a very limited form of\npattern matching, by selecting an operation depending on this\nvalue\'s tag.\n'
    }), __metamagical_withMeta(_extend['matchWith'], {
      'name': 'matchWith',
      'source': 'matchWith(pattern) {\n        return pattern[name](this);\n      }',
      'signature': 'matchWith(pattern)',
      'location': {
        'filename': 'src/core/adt/core.js',
        'start': {
          'line': 92,
          'column': 42
        },
        'end': {
          'line': 184,
          'column': 5
        }
      },
      'module': 'folktale/src/core/adt/core',
      'licence': 'MIT',
      'authors': ['Quildreen Motta'],
      'repository': 'https://github.com/origamitower/folktale',
      'npmPackage': 'folktale',
      'category': 'Transforming',
      'type': '(\'a is Variant).({ \'b: (Object Any) => \'c }) => \'c\nwhere \'b = \'a[`@@folktale:adt:tag]\n',
      '~belongsTo': function belongsTo() {
        return constructor;
      },
      'documentation': '\nSelects an operation based on this Variant\'s tag.\n\nThe `matchWith` operation allows a very limited form of\npattern matching, by selecting an operation depending on this\nvalue\'s tag.\n\n\n## Example:\n\n    const List = data(\'List\', {\n      Nil:  ()           => ({}),\n      Cons: (head, tail) => ({ head, tail })\n    });\n\n    const { Nil, Cons } = List;\n\n    const sum = (list) => list.matchWith({\n      Nil:  ()               => 0,\n      Cons: ({ head, tail }) => head + sum(tail)  \n    });\n\n    sum(Cons(1, Cons(2, Nil()))); // ==> 3\n',
      'examples': [{
        'name': '',
        'call': __metamagical_withMeta(function () {}, {
          'source': ''
        }),
        'inferred': true
      }, {
        'name': 'Example::',
        'call': __metamagical_withMeta(function () {
          var List = data('List', { Nil: function Nil() {
              return {};
            }, Cons: function Cons(head, tail) {
              return { head: head, tail: tail };
            } });var Nil = List.Nil;
          var Cons = List.Cons;
          var sum = function sum(list) {
            return list.matchWith({ Nil: function Nil() {
                return 0;
              }, Cons: function Cons(_ref2) {
                var head = _ref2.head;
                var tail = _ref2.tail;
                return head + sum(tail);
              } });
          };__metamagical_assert_equals(require('assert'), sum(Cons(1, Cons(2, Nil()))), 3, 'sum(Cons(1, Cons(2, Nil()))) ==> 3');; // ==> 3
        }, {
          'source': 'const List = data(\'List\', {\n  Nil:  ()           => ({}),\n  Cons: (head, tail) => ({ head, tail })\n});\n\nconst { Nil, Cons } = List;\n\nconst sum = (list) => list.matchWith({\n  Nil:  ()               => 0,\n  Cons: ({ head, tail }) => head + sum(tail)  \n});\n\nsum(Cons(1, Cons(2, Nil()))); // ==> 3'
        }),
        'inferred': true
      }]
    }), _extend));

    function makeInstance() {
      var result = new InternalConstructor();
      Object.assign(result, constructor.apply(undefined, arguments));
      return result;
    }

    extend(makeInstance, (_extend3 = (_extend4 = {}, _defineProperty(_extend4, META, constructor[META]), _tag = 'tag', _mutatorMap2 = {}, _mutatorMap2[_tag] = _mutatorMap2[_tag] || {}, _mutatorMap2[_tag].get = function () {
      return name;
    }, _type = 'type', _mutatorMap2[_type] = _mutatorMap2[_type] || {}, _mutatorMap2[_type].get = function () {
      return typeId;
    }, _constructor = 'constructor', _mutatorMap2[_constructor] = _mutatorMap2[_constructor] || {}, _mutatorMap2[_constructor].get = function () {
      return constructor;
    }, _defineProperty(_extend4, 'prototype', InternalConstructor.prototype), _defineProperty(_extend4, 'hasInstance', function hasInstance(value) {
      return Boolean(value) && adt.hasInstance(value) && value[TAG] === name;
    }), _defineEnumerableProperties(_extend4, _mutatorMap2), _extend4), __metamagical_withMeta(Object.getOwnPropertyDescriptor(_extend3, 'tag').get, {
      'name': 'tag',
      'source': 'get tag() {\n        return name;\n      }',
      'signature': 'get tag()',
      'location': {
        'filename': 'src/core/adt/core.js',
        'start': {
          'line': 192,
          'column': 25
        },
        'end': {
          'line': 273,
          'column': 5
        }
      },
      'module': 'folktale/src/core/adt/core',
      'licence': 'MIT',
      'authors': ['Quildreen Motta'],
      'repository': 'https://github.com/origamitower/folktale',
      'npmPackage': 'folktale',
      'category': 'State and Configuration',
      '~belongsTo': function belongsTo() {
        return makeInstance;
      },
      'documentation': '\nThe unique tag for this variant within the ADT.\n'
    }), __metamagical_withMeta(Object.getOwnPropertyDescriptor(_extend3, 'type').get, {
      'name': 'type',
      'source': 'get type() {\n        return typeId;\n      }',
      'signature': 'get type()',
      'location': {
        'filename': 'src/core/adt/core.js',
        'start': {
          'line': 192,
          'column': 25
        },
        'end': {
          'line': 273,
          'column': 5
        }
      },
      'module': 'folktale/src/core/adt/core',
      'licence': 'MIT',
      'authors': ['Quildreen Motta'],
      'repository': 'https://github.com/origamitower/folktale',
      'npmPackage': 'folktale',
      'category': 'State and Configuration',
      '~belongsTo': function belongsTo() {
        return makeInstance;
      },
      'documentation': '\nThe (ideally unique) type for the ADT. This is provided by the user\ncreating the ADT, so we can\'t actually guarantee uniqueness.\n'
    }), __metamagical_withMeta(Object.getOwnPropertyDescriptor(_extend3, 'constructor').get, {
      'name': 'constructor',
      'source': 'get constructor() {\n        return constructor;\n      }',
      'signature': 'get constructor()',
      'location': {
        'filename': 'src/core/adt/core.js',
        'start': {
          'line': 192,
          'column': 25
        },
        'end': {
          'line': 273,
          'column': 5
        }
      },
      'module': 'folktale/src/core/adt/core',
      'licence': 'MIT',
      'authors': ['Quildreen Motta'],
      'repository': 'https://github.com/origamitower/folktale',
      'npmPackage': 'folktale',
      'category': 'Internal',
      '~belongsTo': function belongsTo() {
        return makeInstance;
      },
      'documentation': '\nThe internal constructor provided by the user, which transforms and\nvalidates the properties attached to objects constructed in this ADT.\n'
    }), __metamagical_withMeta(_extend3['prototype'], {
      'name': 'prototype',
      'source': 'InternalConstructor.prototype',
      'location': {
        'filename': 'src/core/adt/core.js',
        'start': {
          'line': 192,
          'column': 25
        },
        'end': {
          'line': 273,
          'column': 5
        }
      },
      'module': 'folktale/src/core/adt/core',
      'licence': 'MIT',
      'authors': ['Quildreen Motta'],
      'repository': 'https://github.com/origamitower/folktale',
      'npmPackage': 'folktale',
      'category': 'Internal',
      '~belongsTo': function belongsTo() {
        return makeInstance;
      },
      'documentation': '\nThe object that provides common behaviours for instances of this variant.\n'
    }), __metamagical_withMeta(_extend3['hasInstance'], {
      'name': 'hasInstance',
      'source': 'hasInstance(value) {\n        return Boolean(value) \n        &&     adt.hasInstance(value) \n        &&     value[TAG] === name;\n      }',
      'signature': 'hasInstance(value)',
      'location': {
        'filename': 'src/core/adt/core.js',
        'start': {
          'line': 192,
          'column': 25
        },
        'end': {
          'line': 273,
          'column': 5
        }
      },
      'module': 'folktale/src/core/adt/core',
      'licence': 'MIT',
      'authors': ['Quildreen Motta'],
      'repository': 'https://github.com/origamitower/folktale',
      'npmPackage': 'folktale',
      'category': 'Comparing and Testing',
      'type': '(Variant) => Boolean\n',
      '~belongsTo': function belongsTo() {
        return makeInstance;
      },
      'documentation': '\nChecks if a value belongs to this Variant.\n\nThis is similar to the `ADT.hasInstance` check, with the\nexception that we also check if the value is of the same\nvariant (has the same tag) as this variant.\n\n\n## Example:\n\n    const Either = data(\'Either\', {\n      Left:  (value) => ({ value }),\n      Right: (value) => ({ value })\n    });\n\n    const { Left, Right } = Either;\n \n    Left.hasInstance(Left(1));  // ==> true\n    Left.hasInstance(Right(1)); // ==> false\n',
      'examples': [{
        'name': '',
        'call': __metamagical_withMeta(function () {}, {
          'source': ''
        }),
        'inferred': true
      }, {
        'name': 'Example::',
        'call': __metamagical_withMeta(function () {
          var Either = data('Either', { Left: function Left(value) {
              return { value: value };
            }, Right: function Right(value) {
              return { value: value };
            } });var Left = Either.Left;
          var Right = Either.Right;
          __metamagical_assert_equals(require('assert'), Left.hasInstance(Left(1)), true, 'Left.hasInstance(Left(1)) ==> true');; // ==> true
          __metamagical_assert_equals(require('assert'), Left.hasInstance(Right(1)), false, 'Left.hasInstance(Right(1)) ==> false');; // ==> false
        }, {
          'source': 'const Either = data(\'Either\', {\n  Left:  (value) => ({ value }),\n  Right: (value) => ({ value })\n});\n\nconst { Left, Right } = Either;\n\nLeft.hasInstance(Left(1));  // ==> true\nLeft.hasInstance(Right(1)); // ==> false'
        }),
        'inferred': true
      }]
    }), _extend3));

    return makeInstance;
  });
}

// --[ ADT Implementation ]--------------------------------------------

/*~
 * Constructs a tagged union data structure.
 *
 * 
 * ## Using the ADT module::
 *
 *     var List = data('List', {
 *       Nil(){ },
 *       Cons(value, rest) {
 *         return { value, rest };
 *       }
 *     });
 *
 *     var { Nil, Cons } = List;
 *
 *     Cons('a', Cons('b', Cons('c', Nil())));
 *     // ==> { value: 'a', rest: { value: 'b', ..._ }}
 *
 *
 * 
 * ## Why use tagged unions?
 * 
 * Data modelling is a very important part of programming, directly
 * affecting things like correctness and performance. Folktale is
 * in general mostly interested in correctness, and providing tools
 * for achieving that.
 * 
 * When modelling data in a program, there are several different
 * choices that one must make in an attempt to capture the rules of
 * how that data is manipulated and what they represent. Data modeling
 * tends to come in three different concepts:
 * 
 *   - **Scalars** represent concepts that have only one atomic
 *     value at a time. This value makes sense on its own, and can't
 *     be divided into further concepts. Examples of this are numers,
 *     strings, etc.
 * 
 *   - **Product** represent bigger concepts that are made out of
 *     possibly several smaller concepts, each of which is independent
 *     of each other, and always present. An object that contains a
 *     person's `name` and `age` is an example of a product, arrays
 *     are another example.
 * 
 *   - **Unions** represent one of out of many concepts, at any given
 *     time. JS doesn't have many data structure that captures the idea
 *     of an union, but there are many cases where this happens in a
 *     codebase: 
 * 
 *       - Reading a file may either give you the data in that
 *         file or an error object; 
 * 
 *       - Accessing a property in an object may either give you the
 *         value or undefined;
 * 
 *       - Querying a database may give you a connection error (maybe
 *         we weren't able to contact the database), a query error
 *         (maybe the query wasn't well formed), a "this value isn't
 *         here" response, or the value you want.
 * 
 * Out of these, you're probably already familiar with products and scalars,
 * because they're used everywhere in JavaScript, but maybe you're not
 * familiar with unions, since JavaScript doesn't have many of them built-in.
 * 
 * For example, when reading a file in Node, you have this:
 * 
 *     fs.readFile(filename, (error, value) => {
 *       if (error != null) {
 *         handleError(error);
 *       } else {
 *         handleSuccess(value);
 *       }
 *     });
 * 
 * The callback function receives two arguments, `error` and `value`, but
 * only one of them may ever be present at any given time. If you have a
 * value, then `error` must be null, and if you have an error, then `value`
 * must be null. Nothing in the representation of this data tells you
 * that, or forces you to deal with it like that.
 * 
 * If you compare it with an API like `fetch`, where you get a Promise
 * instead, many of these problems are solved:
 * 
 *     fetch(url).then(
 *       (response) => handleSuccess(response),
 *       (error)    => handleError(error)
 *     );
 * 
 * Here the result of `fetch` can be either a response or an error, like in
 * the `readFile` exammple, but the only way of getting to that value is
 * through the `then` function, which requires you to define separate branches
 * for handling each case. This way it's not possible to forget to deal with
 * one of the cases, or make mistakes in the branching condition, such as
 * `if (error == null) { handleError(...) }` â€” which the first version of
 * this documentation had, in fact.
 * 
 * 
 * ## Modelling data with Core.ADT
 * 
 * So, properly modelling your data helps making sure that a series of errors
 * can't ever occurr in your program, which is great as you have to deal with
 * less problems, but how does Core.ADT help you in that?
 * 
 * 
 * ### A simple failure case
 * 
 * To answer this question let's consider a very simple, everyday problem: you
 * have a function that can return any value, but it can also fail. How do you
 * differentiate failure from regular values?
 * 
 * ::
 * 
 *     const find = (predicate, items) => {
 *       for (let i = 0; i < items.length; ++i) {
 *         const item = items[i];
 *         if (predicate(item))  return item;
 *       }
 *       return null;
 *     };
 * 
 * The example above returns the item if the predicate matches anything, or `null`
 * if it doesn't. But `null` is also a valid JavaScript value::
 * 
 *     find(x => true, [1, 2, 3]);    // ==> 1
 *     find(x => false, [1, 2, 3]);   // ==> null
 *     find(x => true, [null, 1, 2]); // ==> null
 * 
 * Now, there isn't a way of differentiating failure from success if your arrays
 * have a `null` value. One could say "this function works for arrays without
 * nulls", but there isn't a separate type that can enforce those guarantees
 * either. This confusing behaviour opens the door for bugs that are very
 * difficult to find, since they're created way before they hit the `find`
 * function.
 * 
 * A more practical approach is to return something that can't be in the array.
 * For example, if we return an object like: `{ found: Bool, value: Any }`, then
 * we don't run into this issue::
 * 
 *     const find2 = (predicate, items) => {
 *       for (let i = 0; i < items.length; ++i) {
 *         const item = items[i];
 *         if (predicate(item))  return { found: true, value: item };
 *       }
 *       return { found: false };
 *     };
 * 
 *     find2(x => true, [1, 2, 3]);    // ==> { found: true, value: 1 }
 *     find2(x => false, [1, 2, 3]);   // ==> { found: false }
 *     find2(x => true, [null, 1, 2]); // ==> { found: true, value: null }
 * 
 * We can differentiate between successes and failures now, but in order to
 * use the value we need to unpack it. Now we have two problems: `found` and
 * `value` aren't entirely related, and we have to create this ad-hoc relationship
 * through an `if` statement. That's very easy to get wrong. Another problem is
 * that nothing forces people to check `found` before looking at `value`.
 * 
 * So, a better solution for this is to use tagged unions and pattern matching::
 * 
 *     const Maybe = data('Maybe', {
 *       None() { return {} },
 *       Some(value) { return { value } }
 *     });
 * 
 *     const find3 = (predicate, items) => {
 *       for (let i = 0; i < items.length; ++i) {
 *         const item = items[i];
 *         if (predicate(item))  return Maybe.Some(item);
 *       }
 *       return Maybe.None();
 *     };
 * 
 *     find3(x => true, [1, 2, 3]);    // ==> Maybe.Some(1)
 *     find3(x => false, [1, 2, 3]);   // ==> Maybe.None()
 *     find3(x => true, [null, 1, 2]); // ==> Maybe.Some(null)
 * 
 *     find3(x => true, [1, 2, 3]).matchWith({
 *       None: ()          => "Not found",
 *       Some: ({ value }) => "Found " + value
 *     }); // ==> "Found 1"
 * 
 * 
 * ### Modelling complex cases
 * 
 * Let's consider a more complex case. Imagine you're writing a function to
 * handle communicating with some HTTP API. Like in the case presented in
 * the previous section, a call to the API may succeed or fail. Unlike the
 * previous example, here a failure has more information associated with it,
 * and we can have different kinds of failures:
 * 
 *   - The operation may succeed, and return a value;
 *   - The operation may fail:
 *     - Because it wasn't possible to reach the API (due to a network error, for example);
 *     - Because the return value of the API wasn't in the expected format (unable to parse);
 *     - Because the API itself returned an error (e.g.: if the request had bad data in it).
 * 
 * A common way of writing this in Node would be like this:
 * 
 *     api.method((error, response) => {
 *       if (error != null) {
 *         if (error.code === "http") {
 *           // handle network failures here
 *         }
 *         if (error.code === "service") {
 *           // handle service failures here
 *         } 
 *       } else {
 *         try {
 *           var data = normalise(response);
 *           // handle success here 
 *         } catch(e) { 
 *           // handle invalid responses here
 *         }
 *       }
 *     });
 * 
 * But again, in this style of programming it's easier to make mistakes that are hard
 * to catch, since we're assigning meaning through control flow in an ad-hoc manner,
 * and there's nothing to tell us if we've got it wrong. It's also harder to abstract,
 * because we can't capture these rules as data, so we have to add even more special
 * control flow structures to handle the abstractions.
 * 
 * Let's model it as a tagged union instead. We could make a single data structure
 * that captures all 4 possible results, and that would be a reasonable way of modelling
 * this. But on the other hand, we wouldn't be able to talk about failures *in general*,
 * because this forces us to handle each failure case independently. Instead we'll have
 * two tagged unions::
 * 
 *     const Result = data('Result', {
 *       Ok(value) {
 *         return { value }; 
 *       },
 *       Error(reason) {
 *         return { reason };
 *       }
 *     });
 * 
 *     const APIError = data('APIError', {
 *       NetworkError(error){
 *         return { error };
 *       },
 *       ServiceError(code, message) {
 *         return { code, message };
 *       },
 *       ParsingError(error, data) {
 *         return { error, data };
 *       }
 *     });
 * 
 * Then we can construct these values in the API, and make sure people will handle
 * all cases when using it:
 * 
 *     function handleError(error) {
 *       error.matchWith({
 *         NetworkError: ({ error }) => { ... },
 *         ServiceError: ({ code, message }) => { ... },
 *         ParsingError: ({ error, data }) => { ... }
 *       })
 *     }
 * 
 *     api.method(response => {
 *       response.matchWith({
 *         Error: ({ reason }) => handleError(reason),
 *         Ok:    ({ value })  => { ... }
 *       })
 *     });
 * 
 * 
 * ## Providing common functionality
 * 
 * When you're modelling data with ADTs it's tempting to create a lot of
 * very specific objects to capture correctly all of the choices that may
 * exist in a particular domain, but Core.ADT only gives you construction
 * and pattern matching, so what if you want your types to have a notion
 * of equality?
 * 
 * That's where the concept of *derivation* comes in. A derivation is a
 * function that provides a set of common functionality for an ADT and
 * its variants. For example, if one wanted to add the notion of equality
 * to an ADT, they could `derive` `Setoid` as follows::
 * 
 *     const Setoid = require('folktale/core/adt/setoid');
 * 
 *     const Either = data('Either', {
 *       Left(value) { return { value } },
 *       Right(value){ return { value } }
 *     }).derive(Setoid);
 * 
 * Note the `.derive(Setoid)` invocation. `derive` is a method that can
 * be called at any time on the ADT to provide new common functionality
 * to it. In this case, the `Setoid` derivation gives all variants an
 * `equals()` method::
 * 
 *     Either.Left(1).equals(Either.Left(1));   // ==> true
 *     Either.Left(1).equals(Either.Right(1));  // ==> false
 *     Either.Right(1).equals(Either.Right(2)); // ==> false
 *     Either.Right(2).equals(Either.Right(2)); // ==> true
 *     
 * While Core.ADT provides a set of common derivations (categorised
 * `Derivation` in the documentation), one may create their own derivation
 * functions to use with Folktale's ADTs. See the [Extending ADTs](#extending-adts)
 * section for details.
 *  
 *
 * ## Architecture
 *
 * The ADT module approaches this problem in a structural-type-ish way, which
 * happens to be very similar to how OCaml's polymorphic variants work, and
 * how different values are handled in untyped languages.
 *
 * In essence, calling `data` with a set of patterns results in the creation
 * of N constructors, each with a distinct **tag**.
 *
 * Revisiting the previous `List` ADT example, when one writes:
 *
 *     var List = data('List', {
 *       Nil:  () => {},
 *       Cons: (value, rest) => ({ value, rest })
 *     })
 *
 * That's roughly equivalent to the idiomatic:
 *
 *     var List = {};
 *
 *     function Nil() { }
 *     Nil.prototype = Object.create(List);
 *
 *     function Cons(value, rest) {
 *       this.value = value;
 *       this.rest  = rest;
 *     }
 *     Cons.prototype = Object.create(List);
 *
 * The `data` function takes as arguments a type identifier (which can be any
 * object, if you want it to be unique), and an object with the variants. Each
 * property in this object is expected to be a function that returns the
 * properties that'll be provided for the instance of that variant.
 *
 * The given variants are not returned directly. Instead, we return a wrapper
 * that will construct a proper value of this type, and augment it with the
 * properties provided by that variant initialiser.
 *
 *
 * ## Reflection
 *
 * The ADT module relies on JavaScript's built-in reflective features first,
 * and adds a couple of additional fields to this.
 *
 *
 * ### Types and Tags
 *
 * The provided type for the ADT, and the tag provided for the variant
 * are both reified in the ADT structure and the constructed values. These
 * allow checking the compatibility of different values structurally, which
 * sidesteps the problems with realms.
 *
 * The type of the ADT is provided by the global symbol `@@folktale:adt:type`::
 *
 *     var Id = data('Identity', { Id: () => {} });
 *     Id[Symbol.for('@@folktale:adt:type')]
 *     // ==> 'Identity'
 *
 * The tag of the value is provided by the global symbol `@@folktale:adt:tag`::
 *
 *     var List = data('List', {
 *       Nil: () => {},
 *       Cons: (h, t) => ({ h, t })
 *     });
 *     List.Nil()[Symbol.for('@@folktale:adt:tag')]
 *     // ==> 'Nil'
 *
 * These symbols are also exported as properties of the `data` function
 * itself, so you can use `data.typeSymbol` and `data.tagSymbol` instead
 * of retrieving a symbol instance with the `Symbol.for` function.
 *
 *
 * ### `is-a` tests
 *
 * Sometimes it's desirable to test if a value belongs to an ADT or
 * to a variant. Out of the box the structures constructed by ADT
 * provide a `hasInstance` check that verify if a value is structurally
 * part of an ADT structure, by checking the Type and Tag of that value.
 *
 * ###### checking if a value belongs to an ADT::
 *
 *     var IdA = data('IdA', { Id: (x) => ({ x }) });
 *     var IdB = data('IdB', { Id: (x) => ({ x }) });
 *
 *     IdA.hasInstance(IdA.Id(1))  // ==> true
 *     IdA.hasInstance(IdB.Id(1))  // ==> false
 *
 *
 * ###### checking if a value belongs to a variant::
 *
 *     var Either = data('Either', {
 *       Left:  value => ({ value }),
 *       Right: value => ({ value })
 *     });
 *     var { Left, Right } = Either;
 *
 *     Left.hasInstance(Left(1));  // ==> true
 *     Left.hasInstance(Right(1)); // ==> false
 *
 *
 * Note that if two ADTs have the same type ID, they'll be considered
 * equivalent by `hasInstance`. You may pass an object (like
 * `Symbol('type name')`) to `data` to avoid this, however reference
 * equality does not work across realms in JavaScript.
 *
 * Since all instances inherit from the ADT and the variant's prototype
 * it's also possible to use `proto.isPrototypeOf(instance)` to check
 * if an instance belongs to an ADT by reference equality, rather than
 * structural equality.
 *
 *
 * ## Extending ADTs
 *
 * Because all variants inherit from the ADT namespace, it's possible
 * to provide new functionality to all variants by simply adding new
 * properties to the ADT::
 *
 *     var List = data('List', {
 *       Nil:  () => {},
 *       Cons: (value, rest) => ({ value, rest })
 *     });
 *
 *     var { Nil, Cons } = List;
 *
 *     List.sum = function() {
 *       return this.matchWith({
 *         Nil:  () => 0,
 *         Cons: ({ value, rest }) => value + rest.sum()
 *       });
 *     };
 *
 *     Cons(1, Cons(2, Nil())).sum();
 *     // ==> 3
 *
 * A better approach, however, may be to use the `derive` function from
 * the ADT to provide new functionality to every variant. `derive` accepts
 * many derivation functions, which are just functions taking a variant and
 * and ADT, and providing new functionality for that variant.
 *
 * If one wanted to define a JSON serialisation for each variant, for example,
 * they could do so by using the `derive` functionality::
 *
 *     function ToJSON(variant, adt) {
 *       var { tag, type } = variant;
 *       variant.prototype.toJSON = function() {
 *         var json = { tag: `${type}:${tag}` };
 *         Object.keys(this).forEach(key => {
 *           var value = this[key];
 *           if (value && typeof value.toJSON === "function") {
 *             json[key] = value.toJSON();
 *           } else {
 *             json[key] = value;
 *           }
 *         });
 *         return json;
 *       }
 *     }
 *
 *     var List = data('List', {
 *       Nil:  () => {},
 *       Cons: (value, rest) => ({ value, rest })
 *     }).derive(ToJSON);
 *
 *     var { Nil, Cons } = List;
 *
 *     Nil().toJSON()
 *     // ==> { tag: "List:Nil" }
 *
 *     Cons(1, Nil()).toJSON()
 *     // ==> { tag: "List:Cons", value: 1, rest: { "tag": "List:Nil" }}
 *
 *
 *
 * ---
 * category    : Constructing Data Structures
 * stability   : experimental
 * authors:
 *   - Quildreen Motta
 *
 * seeAlso:
 *   - type  : link
 *     title : "Designing with types: Making illegal states unrepresentable"
 *     url   : http://fsharpforfunandprofit.com/posts/designing-with-types-making-illegal-states-unrepresentable/
 *
 * type: |
 *   (String, Object (Array String)) => ADT
 */

__metamagical_withMeta(defineVariants, {
  'name': 'defineVariants',
  'source': 'function defineVariants(typeId, patterns, adt) {\n  return mapObject(patterns, (name, constructor) => {\n    // ---[ Variant Internals ]-----------------------------------------\n    function InternalConstructor() { }\n    InternalConstructor.prototype = Object.create(adt);\n\n    extend(InternalConstructor.prototype, {\n      // This is internal, and we don\'t want the user to be messing with this.\n      [TAG]: name,\n\n      // This is documented by the user, so we don\'t re-document it.\n      constructor: constructor,\n\n      /*~\n       * True if a value belongs to the ADT variant.\n       * \n       * ---\n       * category: Testing and Comparing\n       * deprecated:\n       *   version: 2.0.0\n       *   replacedBy: .hasInstance(value)\n       *   reason: |\n       *     Having a `value.isFoo` property doesn\'t allow people to\n       *     differentiate two variants from different ADTs that have the\n       *     same name. So, instead, now variants and ADTs come with a\n       *     static `.hasInstance(value)` method.\n       * \n       * ~belongsTo: constructor\n       */\n      get [`is${name}`]() {\n        warnDeprecation(`.is${name} is deprecated. Use ${name}.hasInstance(value)\ninstead to check if a value belongs to the ADT variant.`);\n        return true;\n      },\n\n      /*~\n       * Selects an operation based on this Variant\'s tag.\n       *\n       * The `cata`morphism operation allows a very limited form of\n       * pattern matching, by selecting an operation depending on this\n       * value\'s tag.\n       *\n       * ---\n       * category : Transforming\n       * type: |\n       *   (\'a is Variant).({ \'b: (Object Any) => \'c }) => \'c\n       *   where \'b = \'a[`@@folktale:adt:tag]\n       *\n       * deprecated:\n       *   version: 2.0.0\n       *   replacedBy: .matchWith(pattern)\n       *   reason: |\n       *     `.cata()` is not a very intuitive name, and most people are\n       *     not familiar with the term `catamorphism` either. `.matchWith()`\n       *     is more familiar and conveys more information to more people.\n       * \n       * ~belongsTo: constructor\n       */\n      cata(pattern) {\n        warnDeprecation(\'`.cata(pattern)` is deprecated. Use `.matchWith(pattern)` instead.\');\n        return this.matchWith(pattern);\n      },\n      \n      /*~\n       * Selects an operation based on this Variant\'s tag.\n       *\n       * The `matchWith` operation allows a very limited form of\n       * pattern matching, by selecting an operation depending on this\n       * value\'s tag.\n       * \n       * \n       * ## Example::\n       * \n       *     const List = data(\'List\', {\n       *       Nil:  ()           => ({}),\n       *       Cons: (head, tail) => ({ head, tail })\n       *     });\n       * \n       *     const { Nil, Cons } = List;\n       * \n       *     const sum = (list) => list.matchWith({\n       *       Nil:  ()               => 0,\n       *       Cons: ({ head, tail }) => head + sum(tail)  \n       *     });\n       * \n       *     sum(Cons(1, Cons(2, Nil()))); // ==> 3\n       *\n       * ---\n       * category : Transforming\n       * type: |\n       *   (\'a is Variant).({ \'b: (Object Any) => \'c }) => \'c\n       *   where \'b = \'a[`@@folktale:adt:tag]\n       *\n       * ~belongsTo: constructor\n       */\n      matchWith(pattern) {\n        return pattern[name](this);\n      } \n    });\n\n    function makeInstance(...args) {\n      let result = new InternalConstructor();\n      Object.assign(result, constructor(...args));\n      return result;\n    }\n\n    extend(makeInstance, {\n      // We propagate the original metadata for the constructor to our\n      // wrapper, which is what the user will interact with most of the time.\n      [META]: constructor[META],\n\n      /*~\n       * The unique tag for this variant within the ADT.\n       * \n       * ---\n       * category: State and Configuration\n       * ~belongsTo: makeInstance\n       */\n      get tag() {\n        return name;\n      },\n\n      /*~\n       * The (ideally unique) type for the ADT. This is provided by the user\n       * creating the ADT, so we can\'t actually guarantee uniqueness.\n       * \n       * ---\n       * category: State and Configuration\n       * ~belongsTo: makeInstance \n       */\n      get type() {\n        return typeId;\n      },\n\n      /*~\n       * The internal constructor provided by the user, which transforms and\n       * validates the properties attached to objects constructed in this ADT.\n       * \n       * ---\n       * category: Internal\n       * ~belongsTo: makeInstance \n       */\n      get constructor() {\n        return constructor;\n      },\n\n      /*~\n       * The object that provides common behaviours for instances of this variant.\n       * \n       * ---\n       * category: Internal\n       * ~belongsTo: makeInstance\n       */\n      prototype: InternalConstructor.prototype,\n\n      /*~\n       * Checks if a value belongs to this Variant.\n       *\n       * This is similar to the `ADT.hasInstance` check, with the\n       * exception that we also check if the value is of the same\n       * variant (has the same tag) as this variant.\n       * \n       * \n       * ## Example::\n       * \n       *     const Either = data(\'Either\', {\n       *       Left:  (value) => ({ value }),\n       *       Right: (value) => ({ value })\n       *     });\n       * \n       *     const { Left, Right } = Either;\n       *  \n       *     Left.hasInstance(Left(1));  // ==> true\n       *     Left.hasInstance(Right(1)); // ==> false\n       *\n       * ---\n       * category : Comparing and Testing\n       * type: |\n       *   (Variant) => Boolean\n       *\n       * ~belongsTo: makeInstance\n       */\n      hasInstance(value) {\n        return Boolean(value) \n        &&     adt.hasInstance(value) \n        &&     value[TAG] === name;\n      },\n    });\n\n\n    return makeInstance;\n  });\n}',
  'signature': 'defineVariants(typeId, patterns, adt)',
  'location': {
    'filename': 'src/core/adt/core.js',
    'start': {
      'line': 86,
      'column': 0
    },
    'end': {
      'line': 278,
      'column': 1
    }
  },
  'module': 'folktale/src/core/adt/core',
  'licence': 'MIT',
  'authors': ['Quildreen Motta'],
  'repository': 'https://github.com/origamitower/folktale',
  'npmPackage': 'folktale',
  'documentation': '\nDefines the variants given a set of patterns and an ADT namespace.\n '
});

var data = __metamagical_withMeta(function (typeId, patterns) {
  var _extend5, _extend6;

  var ADTNamespace = Object.create(ADT);
  var variants = defineVariants(typeId, patterns, ADTNamespace);

  extend(ADTNamespace, variants, (_extend5 = (_extend6 = {}, _defineProperty(_extend6, TYPE, typeId), _defineProperty(_extend6, 'variants', values(variants)), _defineProperty(_extend6, 'hasInstance', function hasInstance(value) {
    return Boolean(value) && value[TYPE] === this[TYPE];
  }), _extend6), __metamagical_withMeta(_extend5['variants'], {
    'name': 'variants',
    'source': 'values(variants)',
    'location': {
      'filename': 'src/core/adt/core.js',
      'start': {
        'line': 777,
        'column': 33
      },
      'end': {
        'line': 812,
        'column': 3
      }
    },
    'module': 'folktale/src/core/adt/core',
    'licence': 'MIT',
    'authors': ['Quildreen Motta'],
    'repository': 'https://github.com/origamitower/folktale',
    'npmPackage': 'folktale',
    'category': 'Members',
    'type': 'Array Variant',
    '~belongsTo': function belongsTo() {
      return ADTNamespace;
    },
    'documentation': '\nThe variants present in this ADT.\n'
  }), __metamagical_withMeta(_extend5['hasInstance'], {
    'name': 'hasInstance',
    'source': 'hasInstance(value) {\n      return Boolean(value)\n      &&     value[TYPE] === this[TYPE];\n    }',
    'signature': 'hasInstance(value)',
    'location': {
      'filename': 'src/core/adt/core.js',
      'start': {
        'line': 777,
        'column': 33
      },
      'end': {
        'line': 812,
        'column': 3
      }
    },
    'module': 'folktale/src/core/adt/core',
    'licence': 'MIT',
    'authors': ['Quildreen Motta'],
    'repository': 'https://github.com/origamitower/folktale',
    'npmPackage': 'folktale',
    'category': 'Comparing and Testing',
    'type': 'ADT.(Variant) -> Boolean\n',
    '~belongsTo': function belongsTo() {
      return ADTNamespace;
    },
    'documentation': '\nChecks if a value belongs to this ADT.\n\nValues are considered to belong to an ADT if they have the same\n`Symbol.for(\'@@folktale:adt:type\')` property as the ADT\'s.\n\nIf you don\'t want a structural check, you can test whether the\nADT is in the prototype chain of the value, but keep in mind that\nthis does not work cross-realm.\n'
  }), _extend5));

  return ADTNamespace;
}, {
  'name': 'data',
  'source': '(typeId, patterns) => {\n  const ADTNamespace = Object.create(ADT);\n  const variants     = defineVariants(typeId, patterns, ADTNamespace);\n\n  extend(ADTNamespace, variants, {\n    // This is internal, and we don\'t really document it to the user\n    [TYPE]: typeId,\n\n    /*~\n     * The variants present in this ADT.\n     * \n     * ---\n     * category: Members\n     * type: Array Variant\n     * ~belongsTo: ADTNamespace\n     */\n    variants: values(variants),\n\n    /*~\n     * Checks if a value belongs to this ADT.\n     *\n     * Values are considered to belong to an ADT if they have the same\n     * `Symbol.for(\'@@folktale:adt:type\')` property as the ADT\'s.\n     *\n     * If you don\'t want a structural check, you can test whether the\n     * ADT is in the prototype chain of the value, but keep in mind that\n     * this does not work cross-realm.\n     *\n     * ---\n     * category  : Comparing and Testing\n     * type: |\n     *   ADT.(Variant) -> Boolean\n     *\n     * ~belongsTo: ADTNamespace\n     */\n    hasInstance(value) {\n      return Boolean(value)\n      &&     value[TYPE] === this[TYPE];\n    }\n  });\n\n  return ADTNamespace;\n}',
  'signature': 'data(typeId, patterns)',
  'location': {
    'filename': 'src/core/adt/core.js',
    'start': {
      'line': 773,
      'column': 0
    },
    'end': {
      'line': 815,
      'column': 2
    }
  },
  'module': 'folktale/src/core/adt/core',
  'licence': 'MIT',
  'authors': ['Quildreen Motta'],
  'repository': 'https://github.com/origamitower/folktale',
  'npmPackage': 'folktale',
  'category': 'Constructing Data Structures',
  'stability': 'experimental',
  'seeAlso': [{
    'type': 'link',
    'title': 'Designing with types: Making illegal states unrepresentable',
    'url': 'http://fsharpforfunandprofit.com/posts/designing-with-types-making-illegal-states-unrepresentable/'
  }],
  'type': '(String, Object (Array String)) => ADT\n',
  'documentation': '\nConstructs a tagged union data structure.\n\n\n## Using the ADT module:\n\n    var List = data(\'List\', {\n      Nil(){ },\n      Cons(value, rest) {\n        return { value, rest };\n      }\n    });\n\n    var { Nil, Cons } = List;\n\n    Cons(\'a\', Cons(\'b\', Cons(\'c\', Nil())));\n    // ==> { value: \'a\', rest: { value: \'b\', ..._ }}\n\n\n\n## Why use tagged unions?\n\nData modelling is a very important part of programming, directly\naffecting things like correctness and performance. Folktale is\nin general mostly interested in correctness, and providing tools\nfor achieving that.\n\nWhen modelling data in a program, there are several different\nchoices that one must make in an attempt to capture the rules of\nhow that data is manipulated and what they represent. Data modeling\ntends to come in three different concepts:\n\n  - **Scalars** represent concepts that have only one atomic\n    value at a time. This value makes sense on its own, and can\'t\n    be divided into further concepts. Examples of this are numers,\n    strings, etc.\n\n  - **Product** represent bigger concepts that are made out of\n    possibly several smaller concepts, each of which is independent\n    of each other, and always present. An object that contains a\n    person\'s `name` and `age` is an example of a product, arrays\n    are another example.\n\n  - **Unions** represent one of out of many concepts, at any given\n    time. JS doesn\'t have many data structure that captures the idea\n    of an union, but there are many cases where this happens in a\n    codebase: \n\n      - Reading a file may either give you the data in that\n        file or an error object; \n\n      - Accessing a property in an object may either give you the\n        value or undefined;\n\n      - Querying a database may give you a connection error (maybe\n        we weren\'t able to contact the database), a query error\n        (maybe the query wasn\'t well formed), a "this value isn\'t\n        here" response, or the value you want.\n\nOut of these, you\'re probably already familiar with products and scalars,\nbecause they\'re used everywhere in JavaScript, but maybe you\'re not\nfamiliar with unions, since JavaScript doesn\'t have many of them built-in.\n\nFor example, when reading a file in Node, you have this:\n\n    fs.readFile(filename, (error, value) => {\n      if (error != null) {\n        handleError(error);\n      } else {\n        handleSuccess(value);\n      }\n    });\n\nThe callback function receives two arguments, `error` and `value`, but\nonly one of them may ever be present at any given time. If you have a\nvalue, then `error` must be null, and if you have an error, then `value`\nmust be null. Nothing in the representation of this data tells you\nthat, or forces you to deal with it like that.\n\nIf you compare it with an API like `fetch`, where you get a Promise\ninstead, many of these problems are solved:\n\n    fetch(url).then(\n      (response) => handleSuccess(response),\n      (error)    => handleError(error)\n    );\n\nHere the result of `fetch` can be either a response or an error, like in\nthe `readFile` exammple, but the only way of getting to that value is\nthrough the `then` function, which requires you to define separate branches\nfor handling each case. This way it\'s not possible to forget to deal with\none of the cases, or make mistakes in the branching condition, such as\n`if (error == null) { handleError(...) }` â€” which the first version of\nthis documentation had, in fact.\n\n\n## Modelling data with Core.ADT\n\nSo, properly modelling your data helps making sure that a series of errors\ncan\'t ever occurr in your program, which is great as you have to deal with\nless problems, but how does Core.ADT help you in that?\n\n\n### A simple failure case\n\nTo answer this question let\'s consider a very simple, everyday problem: you\nhave a function that can return any value, but it can also fail. How do you\ndifferentiate failure from regular values?\n\n\n\n    const find = (predicate, items) => {\n      for (let i = 0; i < items.length; ++i) {\n        const item = items[i];\n        if (predicate(item))  return item;\n      }\n      return null;\n    };\n\nThe example above returns the item if the predicate matches anything, or `null`\nif it doesn\'t. But `null` is also a valid JavaScript value:\n\n    find(x => true, [1, 2, 3]);    // ==> 1\n    find(x => false, [1, 2, 3]);   // ==> null\n    find(x => true, [null, 1, 2]); // ==> null\n\nNow, there isn\'t a way of differentiating failure from success if your arrays\nhave a `null` value. One could say "this function works for arrays without\nnulls", but there isn\'t a separate type that can enforce those guarantees\neither. This confusing behaviour opens the door for bugs that are very\ndifficult to find, since they\'re created way before they hit the `find`\nfunction.\n\nA more practical approach is to return something that can\'t be in the array.\nFor example, if we return an object like: `{ found: Bool, value: Any }`, then\nwe don\'t run into this issue:\n\n    const find2 = (predicate, items) => {\n      for (let i = 0; i < items.length; ++i) {\n        const item = items[i];\n        if (predicate(item))  return { found: true, value: item };\n      }\n      return { found: false };\n    };\n\n    find2(x => true, [1, 2, 3]);    // ==> { found: true, value: 1 }\n    find2(x => false, [1, 2, 3]);   // ==> { found: false }\n    find2(x => true, [null, 1, 2]); // ==> { found: true, value: null }\n\nWe can differentiate between successes and failures now, but in order to\nuse the value we need to unpack it. Now we have two problems: `found` and\n`value` aren\'t entirely related, and we have to create this ad-hoc relationship\nthrough an `if` statement. That\'s very easy to get wrong. Another problem is\nthat nothing forces people to check `found` before looking at `value`.\n\nSo, a better solution for this is to use tagged unions and pattern matching:\n\n    const Maybe = data(\'Maybe\', {\n      None() { return {} },\n      Some(value) { return { value } }\n    });\n\n    const find3 = (predicate, items) => {\n      for (let i = 0; i < items.length; ++i) {\n        const item = items[i];\n        if (predicate(item))  return Maybe.Some(item);\n      }\n      return Maybe.None();\n    };\n\n    find3(x => true, [1, 2, 3]);    // ==> Maybe.Some(1)\n    find3(x => false, [1, 2, 3]);   // ==> Maybe.None()\n    find3(x => true, [null, 1, 2]); // ==> Maybe.Some(null)\n\n    find3(x => true, [1, 2, 3]).matchWith({\n      None: ()          => "Not found",\n      Some: ({ value }) => "Found " + value\n    }); // ==> "Found 1"\n\n\n### Modelling complex cases\n\nLet\'s consider a more complex case. Imagine you\'re writing a function to\nhandle communicating with some HTTP API. Like in the case presented in\nthe previous section, a call to the API may succeed or fail. Unlike the\nprevious example, here a failure has more information associated with it,\nand we can have different kinds of failures:\n\n  - The operation may succeed, and return a value;\n  - The operation may fail:\n    - Because it wasn\'t possible to reach the API (due to a network error, for example);\n    - Because the return value of the API wasn\'t in the expected format (unable to parse);\n    - Because the API itself returned an error (e.g.: if the request had bad data in it).\n\nA common way of writing this in Node would be like this:\n\n    api.method((error, response) => {\n      if (error != null) {\n        if (error.code === "http") {\n          // handle network failures here\n        }\n        if (error.code === "service") {\n          // handle service failures here\n        } \n      } else {\n        try {\n          var data = normalise(response);\n          // handle success here \n        } catch(e) { \n          // handle invalid responses here\n        }\n      }\n    });\n\nBut again, in this style of programming it\'s easier to make mistakes that are hard\nto catch, since we\'re assigning meaning through control flow in an ad-hoc manner,\nand there\'s nothing to tell us if we\'ve got it wrong. It\'s also harder to abstract,\nbecause we can\'t capture these rules as data, so we have to add even more special\ncontrol flow structures to handle the abstractions.\n\nLet\'s model it as a tagged union instead. We could make a single data structure\nthat captures all 4 possible results, and that would be a reasonable way of modelling\nthis. But on the other hand, we wouldn\'t be able to talk about failures *in general*,\nbecause this forces us to handle each failure case independently. Instead we\'ll have\ntwo tagged unions:\n\n    const Result = data(\'Result\', {\n      Ok(value) {\n        return { value }; \n      },\n      Error(reason) {\n        return { reason };\n      }\n    });\n\n    const APIError = data(\'APIError\', {\n      NetworkError(error){\n        return { error };\n      },\n      ServiceError(code, message) {\n        return { code, message };\n      },\n      ParsingError(error, data) {\n        return { error, data };\n      }\n    });\n\nThen we can construct these values in the API, and make sure people will handle\nall cases when using it:\n\n    function handleError(error) {\n      error.matchWith({\n        NetworkError: ({ error }) => { ... },\n        ServiceError: ({ code, message }) => { ... },\n        ParsingError: ({ error, data }) => { ... }\n      })\n    }\n\n    api.method(response => {\n      response.matchWith({\n        Error: ({ reason }) => handleError(reason),\n        Ok:    ({ value })  => { ... }\n      })\n    });\n\n\n## Providing common functionality\n\nWhen you\'re modelling data with ADTs it\'s tempting to create a lot of\nvery specific objects to capture correctly all of the choices that may\nexist in a particular domain, but Core.ADT only gives you construction\nand pattern matching, so what if you want your types to have a notion\nof equality?\n\nThat\'s where the concept of *derivation* comes in. A derivation is a\nfunction that provides a set of common functionality for an ADT and\nits variants. For example, if one wanted to add the notion of equality\nto an ADT, they could `derive` `Setoid` as follows:\n\n    const Setoid = require(\'folktale/core/adt/setoid\');\n\n    const Either = data(\'Either\', {\n      Left(value) { return { value } },\n      Right(value){ return { value } }\n    }).derive(Setoid);\n\nNote the `.derive(Setoid)` invocation. `derive` is a method that can\nbe called at any time on the ADT to provide new common functionality\nto it. In this case, the `Setoid` derivation gives all variants an\n`equals()` method:\n\n    Either.Left(1).equals(Either.Left(1));   // ==> true\n    Either.Left(1).equals(Either.Right(1));  // ==> false\n    Either.Right(1).equals(Either.Right(2)); // ==> false\n    Either.Right(2).equals(Either.Right(2)); // ==> true\n    \nWhile Core.ADT provides a set of common derivations (categorised\n`Derivation` in the documentation), one may create their own derivation\nfunctions to use with Folktale\'s ADTs. See the [Extending ADTs](#extending-adts)\nsection for details.\n \n\n## Architecture\n\nThe ADT module approaches this problem in a structural-type-ish way, which\nhappens to be very similar to how OCaml\'s polymorphic variants work, and\nhow different values are handled in untyped languages.\n\nIn essence, calling `data` with a set of patterns results in the creation\nof N constructors, each with a distinct **tag**.\n\nRevisiting the previous `List` ADT example, when one writes:\n\n    var List = data(\'List\', {\n      Nil:  () => {},\n      Cons: (value, rest) => ({ value, rest })\n    })\n\nThat\'s roughly equivalent to the idiomatic:\n\n    var List = {};\n\n    function Nil() { }\n    Nil.prototype = Object.create(List);\n\n    function Cons(value, rest) {\n      this.value = value;\n      this.rest  = rest;\n    }\n    Cons.prototype = Object.create(List);\n\nThe `data` function takes as arguments a type identifier (which can be any\nobject, if you want it to be unique), and an object with the variants. Each\nproperty in this object is expected to be a function that returns the\nproperties that\'ll be provided for the instance of that variant.\n\nThe given variants are not returned directly. Instead, we return a wrapper\nthat will construct a proper value of this type, and augment it with the\nproperties provided by that variant initialiser.\n\n\n## Reflection\n\nThe ADT module relies on JavaScript\'s built-in reflective features first,\nand adds a couple of additional fields to this.\n\n\n### Types and Tags\n\nThe provided type for the ADT, and the tag provided for the variant\nare both reified in the ADT structure and the constructed values. These\nallow checking the compatibility of different values structurally, which\nsidesteps the problems with realms.\n\nThe type of the ADT is provided by the global symbol `@@folktale:adt:type`:\n\n    var Id = data(\'Identity\', { Id: () => {} });\n    Id[Symbol.for(\'@@folktale:adt:type\')]\n    // ==> \'Identity\'\n\nThe tag of the value is provided by the global symbol `@@folktale:adt:tag`:\n\n    var List = data(\'List\', {\n      Nil: () => {},\n      Cons: (h, t) => ({ h, t })\n    });\n    List.Nil()[Symbol.for(\'@@folktale:adt:tag\')]\n    // ==> \'Nil\'\n\nThese symbols are also exported as properties of the `data` function\nitself, so you can use `data.typeSymbol` and `data.tagSymbol` instead\nof retrieving a symbol instance with the `Symbol.for` function.\n\n\n### `is-a` tests\n\nSometimes it\'s desirable to test if a value belongs to an ADT or\nto a variant. Out of the box the structures constructed by ADT\nprovide a `hasInstance` check that verify if a value is structurally\npart of an ADT structure, by checking the Type and Tag of that value.\n\n###### checking if a value belongs to an ADT:\n\n    var IdA = data(\'IdA\', { Id: (x) => ({ x }) });\n    var IdB = data(\'IdB\', { Id: (x) => ({ x }) });\n\n    IdA.hasInstance(IdA.Id(1))  // ==> true\n    IdA.hasInstance(IdB.Id(1))  // ==> false\n\n\n###### checking if a value belongs to a variant:\n\n    var Either = data(\'Either\', {\n      Left:  value => ({ value }),\n      Right: value => ({ value })\n    });\n    var { Left, Right } = Either;\n\n    Left.hasInstance(Left(1));  // ==> true\n    Left.hasInstance(Right(1)); // ==> false\n\n\nNote that if two ADTs have the same type ID, they\'ll be considered\nequivalent by `hasInstance`. You may pass an object (like\n`Symbol(\'type name\')`) to `data` to avoid this, however reference\nequality does not work across realms in JavaScript.\n\nSince all instances inherit from the ADT and the variant\'s prototype\nit\'s also possible to use `proto.isPrototypeOf(instance)` to check\nif an instance belongs to an ADT by reference equality, rather than\nstructural equality.\n\n\n## Extending ADTs\n\nBecause all variants inherit from the ADT namespace, it\'s possible\nto provide new functionality to all variants by simply adding new\nproperties to the ADT:\n\n    var List = data(\'List\', {\n      Nil:  () => {},\n      Cons: (value, rest) => ({ value, rest })\n    });\n\n    var { Nil, Cons } = List;\n\n    List.sum = function() {\n      return this.matchWith({\n        Nil:  () => 0,\n        Cons: ({ value, rest }) => value + rest.sum()\n      });\n    };\n\n    Cons(1, Cons(2, Nil())).sum();\n    // ==> 3\n\nA better approach, however, may be to use the `derive` function from\nthe ADT to provide new functionality to every variant. `derive` accepts\nmany derivation functions, which are just functions taking a variant and\nand ADT, and providing new functionality for that variant.\n\nIf one wanted to define a JSON serialisation for each variant, for example,\nthey could do so by using the `derive` functionality:\n\n    function ToJSON(variant, adt) {\n      var { tag, type } = variant;\n      variant.prototype.toJSON = function() {\n        var json = { tag: `${type}:${tag}` };\n        Object.keys(this).forEach(key => {\n          var value = this[key];\n          if (value && typeof value.toJSON === "function") {\n            json[key] = value.toJSON();\n          } else {\n            json[key] = value;\n          }\n        });\n        return json;\n      }\n    }\n\n    var List = data(\'List\', {\n      Nil:  () => {},\n      Cons: (value, rest) => ({ value, rest })\n    }).derive(ToJSON);\n\n    var { Nil, Cons } = List;\n\n    Nil().toJSON()\n    // ==> { tag: "List:Nil" }\n\n    Cons(1, Nil()).toJSON()\n    // ==> { tag: "List:Cons", value: 1, rest: { "tag": "List:Nil" }}\n\n\n',
  'examples': [{
    'name': '',
    'call': __metamagical_withMeta(function () {}, {
      'source': ''
    }),
    'inferred': true
  }, {
    'name': 'Using the ADT module::',
    'call': __metamagical_withMeta(function () {
      var _rest;

      var List = data('List', {
        Nil: function Nil() {},
        Cons: function Cons(value, rest) {
          return { value: value, rest: rest };
        }
      });var Nil = List.Nil;
      var Cons = List.Cons;
      __metamagical_assert_equals(require('assert'), Cons('a', Cons('b', Cons('c', Nil()))), _defineProperty({ value: 'a', rest: (_rest = { value: 'b' }, _defineProperty(_rest, Symbol.for('@@meta:magical:assertion-rest'), true), _defineProperty(_rest, Symbol.for('@@meta:magical:assertion-type'), 'record'), _rest) }, Symbol.for('@@meta:magical:assertion-type'), 'record'), 'Cons(\'a\', Cons(\'b\', Cons(\'c\', Nil()))) ==> { value: \'a\', rest: { value: \'b\', ..._ }}');; // ==> { value: 'a', rest: { value: 'b', ..._ }}
    }, {
      'source': 'var List = data(\'List\', {\n  Nil(){ },\n  Cons(value, rest) {\n    return { value, rest };\n  }\n});\n\nvar { Nil, Cons } = List;\n\nCons(\'a\', Cons(\'b\', Cons(\'c\', Nil())));\n// ==> { value: \'a\', rest: { value: \'b\', ..._ }}'
    }),
    'inferred': true
  }, {
    'name': 'Why use tagged unions?',
    'call': __metamagical_withMeta(function () {}, {
      'source': ''
    }),
    'inferred': true
  }, {
    'name': 'Modelling data with Core.ADT',
    'call': __metamagical_withMeta(function () {}, {
      'source': ''
    }),
    'inferred': true
  }, {
    'name': 'A simple failure case',
    'call': __metamagical_withMeta(function () {
      var find = function find(predicate, items) {
        for (var i = 0; i < items.length; ++i) {
          var item = items[i];if (predicate(item)) return item;
        }return null;
      };__metamagical_assert_equals(require('assert'), find(function (x) {
        return true;
      }, [1, 2, 3]), 1, 'find(x => true, [1, 2, 3]) ==> 1');; // ==> 1
      __metamagical_assert_equals(require('assert'), find(function (x) {
        return false;
      }, [1, 2, 3]), null, 'find(x => false, [1, 2, 3]) ==> null');;__metamagical_assert_equals(require('assert'), find(function (x) {
        return true;
      }, [null, 1, 2]), null, 'find(x => true, [null, 1, 2]) ==> null');; // ==> null
      var find2 = function find2(predicate, items) {
        for (var i = 0; i < items.length; ++i) {
          var item = items[i];if (predicate(item)) return { found: true, value: item };
        }return { found: false };
      };__metamagical_assert_equals(require('assert'), find2(function (x) {
        return true;
      }, [1, 2, 3]), _defineProperty({ found: true, value: 1 }, Symbol.for('@@meta:magical:assertion-type'), 'record'), 'find2(x => true, [1, 2, 3]) ==> { found: true, value: 1 }');; // ==> { found: true, value: 1 }
      __metamagical_assert_equals(require('assert'), find2(function (x) {
        return false;
      }, [1, 2, 3]), _defineProperty({ found: false }, Symbol.for('@@meta:magical:assertion-type'), 'record'), 'find2(x => false, [1, 2, 3]) ==> { found: false }');; // ==> { found: false }
      __metamagical_assert_equals(require('assert'), find2(function (x) {
        return true;
      }, [null, 1, 2]), _defineProperty({ found: true, value: null }, Symbol.for('@@meta:magical:assertion-type'), 'record'), 'find2(x => true, [null, 1, 2]) ==> { found: true, value: null }');; // ==> { found: true, value: null }
      var Maybe = data('Maybe', {
        None: function None() {
          return {};
        },
        Some: function Some(value) {
          return { value: value };
        }
      });var find3 = function find3(predicate, items) {
        for (var i = 0; i < items.length; ++i) {
          var item = items[i];if (predicate(item)) return Maybe.Some(item);
        }return Maybe.None();
      };__metamagical_assert_equals(require('assert'), find3(function (x) {
        return true;
      }, [1, 2, 3]), Maybe.Some(1), 'find3(x => true, [1, 2, 3]) ==> Maybe.Some(1)');; // ==> Maybe.Some(1)
      __metamagical_assert_equals(require('assert'), find3(function (x) {
        return false;
      }, [1, 2, 3]), Maybe.None(), 'find3(x => false, [1, 2, 3]) ==> Maybe.None()');; // ==> Maybe.None()
      __metamagical_assert_equals(require('assert'), find3(function (x) {
        return true;
      }, [null, 1, 2]), Maybe.Some(null), 'find3(x => true, [null, 1, 2]) ==> Maybe.Some(null)');; // ==> Maybe.Some(null)
      __metamagical_assert_equals(require('assert'), find3(function (x) {
        return true;
      }, [1, 2, 3]).matchWith({ None: function None() {
          return "Not found";
        }, Some: function Some(_ref3) {
          var value = _ref3.value;
          return "Found " + value;
        } }), "Found 1", 'find3(x => true, [1, 2, 3]).matchWith({\n  None: () => "Not found",\n  Some: ({\n    value\n  }) => "Found " + value\n}) ==> "Found 1"');; // ==> "Found 1"
    }, {
      'source': 'const find = (predicate, items) => {\n  for (let i = 0; i < items.length; ++i) {\n    const item = items[i];\n    if (predicate(item))  return item;\n  }\n  return null;\n};\n\nfind(x => true, [1, 2, 3]);    // ==> 1\nfind(x => false, [1, 2, 3]);   // ==> null\nfind(x => true, [null, 1, 2]); // ==> null\n\nconst find2 = (predicate, items) => {\n  for (let i = 0; i < items.length; ++i) {\n    const item = items[i];\n    if (predicate(item))  return { found: true, value: item };\n  }\n  return { found: false };\n};\n\nfind2(x => true, [1, 2, 3]);    // ==> { found: true, value: 1 }\nfind2(x => false, [1, 2, 3]);   // ==> { found: false }\nfind2(x => true, [null, 1, 2]); // ==> { found: true, value: null }\n\nconst Maybe = data(\'Maybe\', {\n  None() { return {} },\n  Some(value) { return { value } }\n});\n\nconst find3 = (predicate, items) => {\n  for (let i = 0; i < items.length; ++i) {\n    const item = items[i];\n    if (predicate(item))  return Maybe.Some(item);\n  }\n  return Maybe.None();\n};\n\nfind3(x => true, [1, 2, 3]);    // ==> Maybe.Some(1)\nfind3(x => false, [1, 2, 3]);   // ==> Maybe.None()\nfind3(x => true, [null, 1, 2]); // ==> Maybe.Some(null)\n\nfind3(x => true, [1, 2, 3]).matchWith({\n  None: ()          => "Not found",\n  Some: ({ value }) => "Found " + value\n}); // ==> "Found 1"'
    }),
    'inferred': true
  }, {
    'name': 'Modelling complex cases',
    'call': __metamagical_withMeta(function () {
      var Result = data('Result', {
        Ok: function Ok(value) {
          return { value: value };
        },
        Error: function Error(reason) {
          return { reason: reason };
        }
      });var APIError = data('APIError', {
        NetworkError: function NetworkError(error) {
          return { error: error };
        },
        ServiceError: function ServiceError(code, message) {
          return { code: code, message: message };
        },
        ParsingError: function ParsingError(error, data) {
          return { error: error, data: data };
        }
      });
    }, {
      'source': 'const Result = data(\'Result\', {\n  Ok(value) {\n    return { value }; \n  },\n  Error(reason) {\n    return { reason };\n  }\n});\n\nconst APIError = data(\'APIError\', {\n  NetworkError(error){\n    return { error };\n  },\n  ServiceError(code, message) {\n    return { code, message };\n  },\n  ParsingError(error, data) {\n    return { error, data };\n  }\n});'
    }),
    'inferred': true
  }, {
    'name': 'Providing common functionality',
    'call': __metamagical_withMeta(function () {
      var Setoid = require('./setoid');var Either = data('Either', {
        Left: function Left(value) {
          return { value: value };
        },
        Right: function Right(value) {
          return { value: value };
        }
      }).derive(Setoid);__metamagical_assert_equals(require('assert'), Either.Left(1).equals(Either.Left(1)), true, 'Either.Left(1).equals(Either.Left(1)) ==> true');; // ==> true
      __metamagical_assert_equals(require('assert'), Either.Left(1).equals(Either.Right(1)), false, 'Either.Left(1).equals(Either.Right(1)) ==> false');; // ==> false
      __metamagical_assert_equals(require('assert'), Either.Right(1).equals(Either.Right(2)), false, 'Either.Right(1).equals(Either.Right(2)) ==> false');; // ==> false
      __metamagical_assert_equals(require('assert'), Either.Right(2).equals(Either.Right(2)), true, 'Either.Right(2).equals(Either.Right(2)) ==> true');; // ==> true
    }, {
      'source': 'const Setoid = require(\'folktale/core/adt/setoid\');\n\nconst Either = data(\'Either\', {\n  Left(value) { return { value } },\n  Right(value){ return { value } }\n}).derive(Setoid);\n\nEither.Left(1).equals(Either.Left(1));   // ==> true\nEither.Left(1).equals(Either.Right(1));  // ==> false\nEither.Right(1).equals(Either.Right(2)); // ==> false\nEither.Right(2).equals(Either.Right(2)); // ==> true'
    }),
    'inferred': true
  }, {
    'name': 'Architecture',
    'call': __metamagical_withMeta(function () {}, {
      'source': ''
    }),
    'inferred': true
  }, {
    'name': 'Reflection',
    'call': __metamagical_withMeta(function () {}, {
      'source': ''
    }),
    'inferred': true
  }, {
    'name': 'Types and Tags',
    'call': __metamagical_withMeta(function () {
      var Id = data('Identity', { Id: function Id() {} });__metamagical_assert_equals(require('assert'), Id[Symbol.for('@@folktale:adt:type')], 'Identity', 'Id[Symbol.for(\'@@folktale:adt:type\')] ==> \'Identity\'');; // ==> 'Identity'
      var List = data('List', { Nil: function Nil() {}, Cons: function Cons(h, t) {
          return { h: h, t: t };
        } });__metamagical_assert_equals(require('assert'), List.Nil()[Symbol.for('@@folktale:adt:tag')], 'Nil', 'List.Nil()[Symbol.for(\'@@folktale:adt:tag\')] ==> \'Nil\'');; // ==> 'Nil'
    }, {
      'source': 'var Id = data(\'Identity\', { Id: () => {} });\nId[Symbol.for(\'@@folktale:adt:type\')]\n// ==> \'Identity\'\n\nvar List = data(\'List\', {\n  Nil: () => {},\n  Cons: (h, t) => ({ h, t })\n});\nList.Nil()[Symbol.for(\'@@folktale:adt:tag\')]\n// ==> \'Nil\''
    }),
    'inferred': true
  }, {
    'name': '`is-a` tests',
    'call': __metamagical_withMeta(function () {}, {
      'source': ''
    }),
    'inferred': true
  }, {
    'name': 'checking if a value belongs to an ADT::',
    'call': __metamagical_withMeta(function () {
      var IdA = data('IdA', { Id: function Id(x) {
          return { x: x };
        } });var IdB = data('IdB', { Id: function Id(x) {
          return { x: x };
        } });__metamagical_assert_equals(require('assert'), IdA.hasInstance(IdA.Id(1)), true, 'IdA.hasInstance(IdA.Id(1)) ==> true');; // ==> true
      __metamagical_assert_equals(require('assert'), IdA.hasInstance(IdB.Id(1)), false, 'IdA.hasInstance(IdB.Id(1)) ==> false');;
    }, {
      'source': 'var IdA = data(\'IdA\', { Id: (x) => ({ x }) });\nvar IdB = data(\'IdB\', { Id: (x) => ({ x }) });\n\nIdA.hasInstance(IdA.Id(1))  // ==> true\nIdA.hasInstance(IdB.Id(1))  // ==> false'
    }),
    'inferred': true
  }, {
    'name': 'checking if a value belongs to a variant::',
    'call': __metamagical_withMeta(function () {
      var Either = data('Either', { Left: function Left(value) {
          return { value: value };
        }, Right: function Right(value) {
          return { value: value };
        } });var Left = Either.Left;
      var Right = Either.Right;
      __metamagical_assert_equals(require('assert'), Left.hasInstance(Left(1)), true, 'Left.hasInstance(Left(1)) ==> true');; // ==> true
      __metamagical_assert_equals(require('assert'), Left.hasInstance(Right(1)), false, 'Left.hasInstance(Right(1)) ==> false');; // ==> false
    }, {
      'source': 'var Either = data(\'Either\', {\n  Left:  value => ({ value }),\n  Right: value => ({ value })\n});\nvar { Left, Right } = Either;\n\nLeft.hasInstance(Left(1));  // ==> true\nLeft.hasInstance(Right(1)); // ==> false'
    }),
    'inferred': true
  }, {
    'name': 'Extending ADTs',
    'call': __metamagical_withMeta(function () {
      var List = data('List', { Nil: function Nil() {}, Cons: function Cons(value, rest) {
          return { value: value, rest: rest };
        } });var Nil = List.Nil;
      var Cons = List.Cons;
      List.sum = function () {
        return this.matchWith({ Nil: function Nil() {
            return 0;
          }, Cons: function Cons(_ref4) {
            var value = _ref4.value;
            var rest = _ref4.rest;
            return value + rest.sum();
          } });
      };__metamagical_assert_equals(require('assert'), Cons(1, Cons(2, Nil())).sum(), 3, 'Cons(1, Cons(2, Nil())).sum() ==> 3');; // ==> 3
      ;function ToJSON(variant, adt) {
        var tag = variant.tag;
        var type = variant.type;
        variant.prototype.toJSON = function () {
          var _this = this;

          var json = { tag: type + ':' + tag };Object.keys(this).forEach(function (key) {
            var value = _this[key];if (value && typeof value.toJSON === "function") {
              json[key] = value.toJSON();
            } else {
              json[key] = value;
            }
          });return json;
        };
      }var List = data('List', { Nil: function Nil() {}, Cons: function Cons(value, rest) {
          return { value: value, rest: rest };
        } }).derive(ToJSON);var Nil = List.Nil;
      var Cons = List.Cons;
      __metamagical_assert_equals(require('assert'), Nil().toJSON(), _defineProperty({ tag: "List:Nil" }, Symbol.for('@@meta:magical:assertion-type'), 'record'), 'Nil().toJSON() ==> { tag: "List:Nil" }');; // ==> { tag: "List:Nil" }
      __metamagical_assert_equals(require('assert'), Cons(1, Nil()).toJSON(), _defineProperty({ tag: "List:Cons", value: 1, rest: _defineProperty({ "tag": "List:Nil" }, Symbol.for('@@meta:magical:assertion-type'), 'record') }, Symbol.for('@@meta:magical:assertion-type'), 'record'), 'Cons(1, Nil()).toJSON() ==> { tag: "List:Cons", value: 1, rest: { "tag": "List:Nil" }}');; // ==> { tag: "List:Cons", value: 1, rest: { "tag": "List:Nil" }}
    }, {
      'source': 'var List = data(\'List\', {\n  Nil:  () => {},\n  Cons: (value, rest) => ({ value, rest })\n});\n\nvar { Nil, Cons } = List;\n\nList.sum = function() {\n  return this.matchWith({\n    Nil:  () => 0,\n    Cons: ({ value, rest }) => value + rest.sum()\n  });\n};\n\nCons(1, Cons(2, Nil())).sum();\n// ==> 3\n;\nfunction ToJSON(variant, adt) {\n  var { tag, type } = variant;\n  variant.prototype.toJSON = function() {\n    var json = { tag: `${type}:${tag}` };\n    Object.keys(this).forEach(key => {\n      var value = this[key];\n      if (value && typeof value.toJSON === "function") {\n        json[key] = value.toJSON();\n      } else {\n        json[key] = value;\n      }\n    });\n    return json;\n  }\n}\n\nvar List = data(\'List\', {\n  Nil:  () => {},\n  Cons: (value, rest) => ({ value, rest })\n}).derive(ToJSON);\n\nvar { Nil, Cons } = List;\n\nNil().toJSON()\n// ==> { tag: "List:Nil" }\n\nCons(1, Nil()).toJSON()\n// ==> { tag: "List:Cons", value: 1, rest: { "tag": "List:Nil" }}'
    }),
    'inferred': true
  }]
});

/*~
 * The basis of all algebraic data types.
 *
 * ADT is used basically to share some methods for refining data structures
 * created by this module, derivation being one of them.
 *
 * ---
 * category   : Data Structures
 * ~belongsTo : data
 */
var ADT = __metamagical_withMeta((_metamagical_withMet = {
  derive: function derive() {
    var _this2 = this;

    for (var _len2 = arguments.length, derivations = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      derivations[_key2] = arguments[_key2];
    }

    derivations.forEach(function (derivation) {
      _this2.variants.forEach(function (variant) {
        return derivation(variant, _this2);
      });
    });
    return this;
  }
}, __metamagical_withMeta(_metamagical_withMet['derive'], {
  'name': 'derive',
  'source': 'derive(...derivations) {\n    derivations.forEach(derivation => {\n      this.variants.forEach(variant => derivation(variant, this));\n    });\n    return this;\n  }',
  'signature': 'derive(...derivations)',
  'belongsTo': function belongsTo() {
    return ADT;
  },
  'category': 'Extending ADTs',
  'type': 'ADT . (...(Variant, ADT) => Any) => ADT\n \n',
  'documentation': '\nAllows a function to provide functionality to variants in an ADT.\n\nThe `derive` method exists to support meta-programming on ADT objects,\nsuch that additional functionality (implementation of interfaces or\nprotocols, for example) may be provided by libraries instead of having\nto be hand-coded by the user.\n\nThe operation accepts many `derivation` functions, which will be invoked\nfor each variant in the ADT, where a Variant is just an object with the\nfollowing attributes:\n\n    interface Variant(Any...) -> \'a <: self.prototype {\n      tag         : String,\n      type        : Any,\n      constructor : Constructor,\n      prototype   : Object\n    }\n'
}), _metamagical_withMet), {
  'name': 'ADT',
  'source': '{\n\n  /*~\n   * Allows a function to provide functionality to variants in an ADT.\n   *\n   * The `derive` method exists to support meta-programming on ADT objects,\n   * such that additional functionality (implementation of interfaces or\n   * protocols, for example) may be provided by libraries instead of having\n   * to be hand-coded by the user.\n   *\n   * The operation accepts many `derivation` functions, which will be invoked\n   * for each variant in the ADT, where a Variant is just an object with the\n   * following attributes:\n   *\n   *     interface Variant(Any...) -> \'a <: self.prototype {\n   *       tag         : String,\n   *       type        : Any,\n   *       constructor : Constructor,\n   *       prototype   : Object\n   *     }\n   *\n   * ---\n   * category : Extending ADTs\n   * type: |\n   *   ADT . (...(Variant, ADT) => Any) => ADT\n   */\n  derive(...derivations) {\n    derivations.forEach(derivation => {\n      this.variants.forEach(variant => derivation(variant, this));\n    });\n    return this;\n  }\n}',
  'location': {
    'filename': 'src/core/adt/core.js',
    'start': {
      'line': 828,
      'column': 0
    },
    'end': {
      'line': 860,
      'column': 2
    }
  },
  'module': 'folktale/src/core/adt/core',
  'licence': 'MIT',
  'authors': ['Quildreen Motta'],
  'repository': 'https://github.com/origamitower/folktale',
  'npmPackage': 'folktale',
  'category': 'Data Structures',
  '~belongsTo': function belongsTo() {
    return data;
  },
  'documentation': '\nThe basis of all algebraic data types.\n\nADT is used basically to share some methods for refining data structures\ncreated by this module, derivation being one of them.\n'
});

// --[ Exports ]--------------------------------------------------------
data.ADT = ADT;
data.typeSymbol = TYPE;
data.tagSymbol = TAG;

module.exports = data;
},{"../../helpers/warnDeprecation":52,"./setoid":4,"assert":54}],2:[function(require,module,exports){
'use strict';

var __metamagical_withMeta = function metamagical_withMeta(object, meta) {
  var parent = Object.getPrototypeOf(object);var oldMeta = object[Symbol.for('@@meta:magical')] || {};if (parent && parent[Symbol.for('@@meta:magical')] === oldMeta) {
    oldMeta = {};
  }Object.keys(meta).forEach(function (key) {
    if (/^~/.test(key)) {
      oldMeta[key.slice(1)] = meta[key];
    } else {
      oldMeta[key] = meta[key];
    }
  });object[Symbol.for('@@meta:magical')] = oldMeta;return object;
},
    __metamagical_assert_equals = function metamagical_assert_equals(assert, actual, expected, message) {
  var assertionType = Symbol.for('@@meta:magical:assertion-type');var rest = Symbol.for('@@meta:magical:assertion-rest');var keys = Object.keys;function isSetoid(value) {
    return value && typeof value.equals === 'function';
  }function isRecord(value) {
    return value && value[assertionType] === 'record';
  }function check(predicate) {
    for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }return values.every(predicate);
  }function getSpecialArrayLength(array) {
    var rests = array.map(function (x, i) {
      return [x, i];
    }).filter(function (pair) {
      return pair[0] === rest;
    });if (rests.length > 1 || rests[0] && rests[0][1] !== array.length - 1) {
      assert.ok(false, message + '. Assertions only support a single trailing rest indication for arrays currently.');
    }return (rests[0] || [null, array.length])[1];
  }function compareArrays(left, right) {
    var expectedLength = getSpecialArrayLength(right);assert.ok(Array.isArray(left), message + '. The LHS is not an array.');if (left.length < expectedLength) {
      assert.ok(false, message + '. The LHS does not have the minimum expected length (' + left.length + ' < ' + expectedLength + ')');
    }for (var i = 0; i < expectedLength; ++i) {
      compare(left[i], right[i]);
    }
  }function compareRecord(left, right) {
    var isPartial = right[rest];assert.ok(Object(left) === left, message);if (!isPartial) {
      assert.deepStrictEqual(keys(left).sort(), keys(right).sort(), message + '. The objects have different keys ([' + keys(left).sort().join(', ') + '] vs. [' + keys(right).sort().join(', ') + '])');
    }Object.keys(right).forEach(function (key) {
      if (!(key in left)) {
        assert.ok(false, message + '. The expected key ' + key + ' is not present in the actual object.');
      }compare(left[key], right[key]);
    });
  }function compare(l, r) {
    return check(isSetoid, l, r) ? assert.ok(l.equals(r), message + '. The LHS (' + l + ') setoid instance says the LHS and RHS (' + r + ') are not equal.') : Array.isArray(r) ? compareArrays(l, r) : isRecord(r) ? compareRecord(l, r) : /* otherwise */assert.deepStrictEqual(l, r, message + '. The LHS (' + l + ') and the RHS (' + r + ') are not structually equal.');
  }compare(actual, expected);
};

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

/*~
 * Provides utilities to define tagged unions.
 * 
 * 
 * ## Programming with Tagged Unions
 * 
 * Modelling data is important for a range of reasons. From performance
 * to correctness to safety. Tagged unions give you a way of modelling
 * choices that forces the correct handling of them, unlike predicate-based
 * branching, such as the one used by if statements and other common 
 * control flow structures.
 * 
 * Most of the structures provided by Folktale are tagged unions. But
 * Folktale also gives you a primitive for constructing new ones in an
 * easy way. The `data` function provided by this module achieves that
 * goal::
 * 
 *     const data = require('folktale/core/adt/core');
 *     
 *     const Maybe = data('Maybe', {
 *       Some(value){ return { value } },
 *       None() { return {} }
 *     });
 * 
 *     Maybe.Some(1).matchWith({
 *       Some: ({ value }) => `Found ${value}`,
 *       None: ()          => "Not found" 
 *     });
 *     // ==> "Found 1"
 * 
 * Tagged unions constructed by this module allow one to easily bestow
 * common functionality in them through the `derive` function. For example,
 * one could add the concept of equality to the `Maybe` data structure
 * constructed previously by using the `Setoid` derivation, which is also
 * provided by this module::
 * 
 *     const Setoid = require('folktale/core/adt/setoid');
 *     Maybe.derive(Setoid);
 * 
 *     Maybe.Some(1).equals(Maybe.Some(1)); // ==> true
 *     Maybe.Some(2).equals(Maybe.Some(1)); // ==> false
 * 
 * These structures also provide a way of testing if a value belongs to
 * an ADT in a cross-realm way using the `.hasInstance` method on the ADT
 * or variant::
 * 
 *     Maybe.hasInstance(Maybe.None());       // ==> true
 *     Maybe.Some.hasInstance(Maybe.None());  // ==> false
 *     Maybe.Some.hasInstance(Maybe.Some(1)); // ==> true
 *
 * See the documentation on the `data` function for details.
 * 
 * 
 * ## What's in Core.ADT?
 * 
 * Core.ADT provides features to construct tagged unions, and common
 * derivations for those structures. These operations are divided as
 * follows:
 * 
 *   - **Constructing Data Structures**: functions that construct new
 *   tagged unions.
 * 
 *   - **Extending ADTs**: functions that allow one to extend existing
 *   ADTs and variants with new functionality.
 * 
 *   - **Derivation**: functions that can be used as derivations to
 *   provide common functionality to ADTs.
 * 
 * 
 * ---
 * name        : module folktale/core/adt
 * category    : Data Structures
 */
module.exports = __metamagical_withMeta({
  data: require('./core'),
  setoid: require('./setoid'),
  show: require('./show'),
  serialize: require('./serialize')
}, {
  'name': 'module folktale/core/adt',
  'source': '{\n  data: require(\'./core\'),\n  setoid: require(\'./setoid\'),\n  show: require(\'./show\'),\n  serialize: require(\'./serialize\')\n}',
  'location': {
    'filename': 'src/core/adt/index.js',
    'start': {
      'line': 83,
      'column': 0
    },
    'end': {
      'line': 88,
      'column': 2
    }
  },
  'module': 'folktale/src/core/adt',
  'licence': 'MIT',
  'authors': ['Quildreen Motta'],
  'repository': 'https://github.com/origamitower/folktale',
  'npmPackage': 'folktale',
  'isModule': true,
  'category': 'Data Structures',
  'documentation': '\nProvides utilities to define tagged unions.\n\n\n## Programming with Tagged Unions\n\nModelling data is important for a range of reasons. From performance\nto correctness to safety. Tagged unions give you a way of modelling\nchoices that forces the correct handling of them, unlike predicate-based\nbranching, such as the one used by if statements and other common \ncontrol flow structures.\n\nMost of the structures provided by Folktale are tagged unions. But\nFolktale also gives you a primitive for constructing new ones in an\neasy way. The `data` function provided by this module achieves that\ngoal:\n\n    const data = require(\'folktale/core/adt/core\');\n    \n    const Maybe = data(\'Maybe\', {\n      Some(value){ return { value } },\n      None() { return {} }\n    });\n\n    Maybe.Some(1).matchWith({\n      Some: ({ value }) => `Found ${value}`,\n      None: ()          => "Not found" \n    });\n    // ==> "Found 1"\n\nTagged unions constructed by this module allow one to easily bestow\ncommon functionality in them through the `derive` function. For example,\none could add the concept of equality to the `Maybe` data structure\nconstructed previously by using the `Setoid` derivation, which is also\nprovided by this module:\n\n    const Setoid = require(\'folktale/core/adt/setoid\');\n    Maybe.derive(Setoid);\n\n    Maybe.Some(1).equals(Maybe.Some(1)); // ==> true\n    Maybe.Some(2).equals(Maybe.Some(1)); // ==> false\n\nThese structures also provide a way of testing if a value belongs to\nan ADT in a cross-realm way using the `.hasInstance` method on the ADT\nor variant:\n\n    Maybe.hasInstance(Maybe.None());       // ==> true\n    Maybe.Some.hasInstance(Maybe.None());  // ==> false\n    Maybe.Some.hasInstance(Maybe.Some(1)); // ==> true\n\nSee the documentation on the `data` function for details.\n\n\n## What\'s in Core.ADT?\n\nCore.ADT provides features to construct tagged unions, and common\nderivations for those structures. These operations are divided as\nfollows:\n\n  - **Constructing Data Structures**: functions that construct new\n  tagged unions.\n\n  - **Extending ADTs**: functions that allow one to extend existing\n  ADTs and variants with new functionality.\n\n  - **Derivation**: functions that can be used as derivations to\n  provide common functionality to ADTs.\n\n',
  'examples': [{
    'name': '',
    'call': __metamagical_withMeta(function () {}, {
      'source': ''
    }),
    'inferred': true
  }, {
    'name': 'Programming with Tagged Unions',
    'call': __metamagical_withMeta(function () {
      var data = require('./core');var Maybe = data('Maybe', {
        Some: function Some(value) {
          return { value: value };
        },
        None: function None() {
          return {};
        }
      });__metamagical_assert_equals(require('assert'), Maybe.Some(1).matchWith({ Some: function Some(_ref) {
          var value = _ref.value;
          return 'Found ' + value;
        }, None: function None() {
          return "Not found";
        } }), "Found 1", 'Maybe.Some(1).matchWith({\n  Some: ({\n    value\n  }) => `Found ${ value }`,\n  None: () => "Not found"\n}) ==> "Found 1"');; // ==> "Found 1"
      var Setoid = require('./setoid');Maybe.derive(Setoid);__metamagical_assert_equals(require('assert'), Maybe.Some(1).equals(Maybe.Some(1)), true, 'Maybe.Some(1).equals(Maybe.Some(1)) ==> true');; // ==> true
      __metamagical_assert_equals(require('assert'), Maybe.Some(2).equals(Maybe.Some(1)), false, 'Maybe.Some(2).equals(Maybe.Some(1)) ==> false');; // ==> false
      __metamagical_assert_equals(require('assert'), Maybe.hasInstance(Maybe.None()), true, 'Maybe.hasInstance(Maybe.None()) ==> true');; // ==> true
      __metamagical_assert_equals(require('assert'), Maybe.Some.hasInstance(Maybe.None()), false, 'Maybe.Some.hasInstance(Maybe.None()) ==> false');; // ==> false
      __metamagical_assert_equals(require('assert'), Maybe.Some.hasInstance(Maybe.Some(1)), true, 'Maybe.Some.hasInstance(Maybe.Some(1)) ==> true');; // ==> true
    }, {
      'source': 'const data = require(\'folktale/core/adt/core\');\n\nconst Maybe = data(\'Maybe\', {\n  Some(value){ return { value } },\n  None() { return {} }\n});\n\nMaybe.Some(1).matchWith({\n  Some: ({ value }) => `Found ${value}`,\n  None: ()          => "Not found" \n});\n// ==> "Found 1"\n\nconst Setoid = require(\'folktale/core/adt/setoid\');\nMaybe.derive(Setoid);\n\nMaybe.Some(1).equals(Maybe.Some(1)); // ==> true\nMaybe.Some(2).equals(Maybe.Some(1)); // ==> false\n\nMaybe.hasInstance(Maybe.None());       // ==> true\nMaybe.Some.hasInstance(Maybe.None());  // ==> false\nMaybe.Some.hasInstance(Maybe.Some(1)); // ==> true'
    }),
    'inferred': true
  }]
});
},{"./core":1,"./serialize":3,"./setoid":4,"./show":5,"assert":54}],3:[function(require,module,exports){
'use strict';

var __metamagical_withMeta = function metamagical_withMeta(object, meta) {
  var parent = Object.getPrototypeOf(object);var oldMeta = object[Symbol.for('@@meta:magical')] || {};if (parent && parent[Symbol.for('@@meta:magical')] === oldMeta) {
    oldMeta = {};
  }Object.keys(meta).forEach(function (key) {
    if (/^~/.test(key)) {
      oldMeta[key.slice(1)] = meta[key];
    } else {
      oldMeta[key] = meta[key];
    }
  });object[Symbol.for('@@meta:magical')] = oldMeta;return object;
},
    __metamagical_assert_equals = function metamagical_assert_equals(assert, actual, expected, message) {
  var assertionType = Symbol.for('@@meta:magical:assertion-type');var rest = Symbol.for('@@meta:magical:assertion-rest');var keys = Object.keys;function isSetoid(value) {
    return value && typeof value.equals === 'function';
  }function isRecord(value) {
    return value && value[assertionType] === 'record';
  }function check(predicate) {
    for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }return values.every(predicate);
  }function getSpecialArrayLength(array) {
    var rests = array.map(function (x, i) {
      return [x, i];
    }).filter(function (pair) {
      return pair[0] === rest;
    });if (rests.length > 1 || rests[0] && rests[0][1] !== array.length - 1) {
      assert.ok(false, message + '. Assertions only support a single trailing rest indication for arrays currently.');
    }return (rests[0] || [null, array.length])[1];
  }function compareArrays(left, right) {
    var expectedLength = getSpecialArrayLength(right);assert.ok(Array.isArray(left), message + '. The LHS is not an array.');if (left.length < expectedLength) {
      assert.ok(false, message + '. The LHS does not have the minimum expected length (' + left.length + ' < ' + expectedLength + ')');
    }for (var i = 0; i < expectedLength; ++i) {
      compare(left[i], right[i]);
    }
  }function compareRecord(left, right) {
    var isPartial = right[rest];assert.ok(Object(left) === left, message);if (!isPartial) {
      assert.deepStrictEqual(keys(left).sort(), keys(right).sort(), message + '. The objects have different keys ([' + keys(left).sort().join(', ') + '] vs. [' + keys(right).sort().join(', ') + '])');
    }Object.keys(right).forEach(function (key) {
      if (!(key in left)) {
        assert.ok(false, message + '. The expected key ' + key + ' is not present in the actual object.');
      }compare(left[key], right[key]);
    });
  }function compare(l, r) {
    return check(isSetoid, l, r) ? assert.ok(l.equals(r), message + '. The LHS (' + l + ') setoid instance says the LHS and RHS (' + r + ') are not equal.') : Array.isArray(r) ? compareArrays(l, r) : isRecord(r) ? compareRecord(l, r) : /* otherwise */assert.deepStrictEqual(l, r, message + '. The LHS (' + l + ') and the RHS (' + r + ') are not structually equal.');
  }compare(actual, expected);
};

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

// --[ Dependencies ]---------------------------------------------------
var _require = require('./core');

var tagSymbol = _require.tagSymbol;
var typeSymbol = _require.typeSymbol;

var mapValues = require('../object/map-values');
var values = require('../object/values');

// --[ Constants ]------------------------------------------------------
var typeJsonKey = '@@type';
var tagJsonKey = '@@tag';
var valueJsonKey = '@@value';

// --[ Helpers ]--------------------------------------------------------

/*~
 * Creates a type lookup table from an array of types.
 * 
 * ---
 * type: ((Object 'a) => 'b) => ([Object 'a]) => Object 'b  
 */
var arrayToObject = __metamagical_withMeta(function (extractKey) {
  return function (array) {
    return array.reduce(function (object, element) {
      object[extractKey(element)] = element;
      return object;
    }, {});
  };
}, {
  'name': 'arrayToObject',
  'source': '(extractKey) => (array) => \n  array.reduce((object, element) => {\n    object[extractKey(element)] = element;\n    return object;\n  }, {})',
  'signature': 'arrayToObject(extractKey)',
  'location': {
    'filename': 'src/core/adt/serialize.js',
    'start': {
      'line': 30,
      'column': 0
    },
    'end': {
      'line': 34,
      'column': 9
    }
  },
  'module': 'folktale/src/core/adt/serialize',
  'licence': 'MIT',
  'authors': ['Quildreen Motta'],
  'repository': 'https://github.com/origamitower/folktale',
  'npmPackage': 'folktale',
  'type': '((Object \'a) => \'b) => ([Object \'a]) => Object \'b',
  'documentation': '\nCreates a type lookup table from an array of types.\n'
});

/*~
 * Retrieves the property of an object.
 * 
 * ---
 * type: (String) => (Object 'a) => 'a | None 
 */
var property = __metamagical_withMeta(function (propertyName) {
  return function (object) {
    return object[propertyName];
  };
}, {
  'name': 'property',
  'source': '(propertyName) => (object) => object[propertyName]',
  'signature': 'property(propertyName)',
  'location': {
    'filename': 'src/core/adt/serialize.js',
    'start': {
      'line': 43,
      'column': 0
    },
    'end': {
      'line': 43,
      'column': 68
    }
  },
  'module': 'folktale/src/core/adt/serialize',
  'licence': 'MIT',
  'authors': ['Quildreen Motta'],
  'repository': 'https://github.com/origamitower/folktale',
  'npmPackage': 'folktale',
  'type': '(String) => (Object \'a) => \'a | None',
  'documentation': '\nRetrieves the property of an object.\n'
});

/*~
 * Specifies `arrayToObject`.
 * 
 * ---
 * type: ([Object 'a]) => Object 'a 
 */
var indexByType = __metamagical_withMeta(arrayToObject(property(typeSymbol)), {
  'name': 'indexByType',
  'source': 'arrayToObject(property(typeSymbol))',
  'location': {
    'filename': 'src/core/adt/serialize.js',
    'start': {
      'line': 52,
      'column': 0
    },
    'end': {
      'line': 52,
      'column': 56
    }
  },
  'module': 'folktale/src/core/adt/serialize',
  'licence': 'MIT',
  'authors': ['Quildreen Motta'],
  'repository': 'https://github.com/origamitower/folktale',
  'npmPackage': 'folktale',
  'type': '([Object \'a]) => Object \'a',
  'documentation': '\nSpecifies `arrayToObject`.\n'
});

/*~
 * Tests a type identifier.
 * 
 * ---
 * type: (String, String) => Bool
 */
var assertType = __metamagical_withMeta(function (given, expected) {
  if (expected !== given) {
    throw new TypeError('\n       The JSON structure was generated from ' + expected + '.\n       You are trying to parse it as ' + given + '. \n    ');
  }
}, {
  'name': 'assertType',
  'source': '(given, expected) => {\n  if (expected !== given) {\n    throw new TypeError(`\n       The JSON structure was generated from ${expected}.\n       You are trying to parse it as ${given}. \n    `);\n  }\n}',
  'signature': 'assertType(given, expected)',
  'location': {
    'filename': 'src/core/adt/serialize.js',
    'start': {
      'line': 61,
      'column': 0
    },
    'end': {
      'line': 68,
      'column': 2
    }
  },
  'module': 'folktale/src/core/adt/serialize',
  'licence': 'MIT',
  'authors': ['Quildreen Motta'],
  'repository': 'https://github.com/origamitower/folktale',
  'npmPackage': 'folktale',
  'type': '(String, String) => Bool',
  'documentation': '\nTests a type identifier.\n'
});

/*~
 * Attempts to parse a value using a type dictionary.
 * 
 * ---
 * type: |
 *   type JSONSerialisation = {
 *     "@@type":  String,
 *     "@@tag":   String,
 *     "@@value": Object Any
 *   }
 *   type JSONParser = {
 *     fromJSON: (JSONSerialisation, Array JSONParser) => Variant
 *   }
 * 
 *   (Object JSONParser) => (JSONSerialisation) => Any
 */
var parseValue = __metamagical_withMeta(function (parsers) {
  return function (value) {
    if (value !== null && typeof value[typeJsonKey] === 'string') {
      var type = value[typeJsonKey];
      if (parsers[type]) {
        return parsers[type].fromJSON(value, parsers, true);
      } else {
        return value;
      }
    } else {
      return value;
    }
  };
}, {
  'name': 'parseValue',
  'source': '(parsers) => (value) => {\n  if (value !== null && typeof value[typeJsonKey] === \'string\') {\n    const type = value[typeJsonKey];\n    if (parsers[type]) {\n      return parsers[type].fromJSON(value, parsers, true);\n    } else {\n      return value;\n    }\n  } else {\n    return value;\n  }\n}',
  'signature': 'parseValue(parsers)',
  'location': {
    'filename': 'src/core/adt/serialize.js',
    'start': {
      'line': 87,
      'column': 0
    },
    'end': {
      'line': 98,
      'column': 2
    }
  },
  'module': 'folktale/src/core/adt/serialize',
  'licence': 'MIT',
  'authors': ['Quildreen Motta'],
  'repository': 'https://github.com/origamitower/folktale',
  'npmPackage': 'folktale',
  'type': 'type JSONSerialisation = {\n  "@@type":  String,\n  "@@tag":   String,\n  "@@value": Object Any\n}\ntype JSONParser = {\n  fromJSON: (JSONSerialisation, Array JSONParser) => Variant\n}\n\n(Object JSONParser) => (JSONSerialisation) => Any\n',
  'documentation': '\nAttempts to parse a value using a type dictionary.\n'
});

/*~
 * Converts a value to its JSON representation.
 * 
 * ---
 * type: ('a) => JSON
 */
var serializeValue = __metamagical_withMeta(function (value) {
  return value !== null && typeof value.toJSON === 'function' ? value.toJSON() : /* otherwise */value;
}, {
  'name': 'serializeValue',
  'source': '(value) =>\n  value !== null && typeof value.toJSON === \'function\' ? value.toJSON()\n  : /* otherwise */                                      value',
  'signature': 'serializeValue(value)',
  'location': {
    'filename': 'src/core/adt/serialize.js',
    'start': {
      'line': 107,
      'column': 0
    },
    'end': {
      'line': 109,
      'column': 63
    }
  },
  'module': 'folktale/src/core/adt/serialize',
  'licence': 'MIT',
  'authors': ['Quildreen Motta'],
  'repository': 'https://github.com/origamitower/folktale',
  'npmPackage': 'folktale',
  'type': '(\'a) => JSON',
  'documentation': '\nConverts a value to its JSON representation.\n'
});

// --[ Implementation ]-------------------------------------------------

/*~
 * Provides JSON serialisation and parsing for ADTs.
 * 
 * The `serialize` derivation bestows `.toJSON()` and `.fromJSON(value)`
 * upon ADTs constructed by Core.ADT. Both serialisation and parsing
 * are recursive, and `.fromJSON` can automatically reify values of
 * other types.
 * 
 * 
 * ## Example::
 * 
 *     const { data, setoid } = require('folktale/core/adt');
 *     const Id = data('Id', {
 *       Id(value){ return { value } }
 *     }).derive(serialize, setoid);
 * 
 *     Id.Id(1).toJSON();
 *     // ==> { '@@type': 'Id', '@@tag': 'Id', '@@value': { value: 1 } }
 * 
 *     Id.fromJSON(Id.Id(1).toJSON());
 *     // ==> Id.Id(1)
 * 
 * 
 * ## JSON serialisation
 * 
 * This derivation provides JSON serialisation through the `.toJSON` method,
 * which converts rich ADTs into objects that can be safely serialised as
 * JSON. For example::
 * 
 *     const data = require('folktale/core/adt/core');
 *     const { Id } = data('Id', {
 *       Id(value){ return { value } }
 *     }).derive(serialize);
 * 
 *     Id(1).toJSON();
 *     // ==> { '@@type': 'Id', '@@tag': 'Id', '@@value': { value: 1 } }
 * 
 * During the transformation, if any of the values contains a `.toJSON`
 * method, that's called to serialise the structure. Otherwise the value is
 * just returned as-is::
 * 
 *     Id(Id(1)).toJSON();
 *     // ==> { '@@type': 'Id', '@@tag': 'Id', '@@value': { value: { '@@type': 'Id', '@@tag': 'Id', '@@value': { 'value': 1 } } } }
 * 
 * It's not necessary to call the `.toJSON()` method directly in most cases, since
 * `JSON.stringify` will already invoke that for you::
 * 
 *     JSON.stringify(Id(1));
 *     // ==> '{"@@type":"Id","@@tag":"Id","@@value":{"value":1}}'
 * 
 *     JSON.stringify(Id([Id(1)]));
 *     // ==> '{"@@type":"Id","@@tag":"Id","@@value":{"value":[{"@@type":"Id","@@tag":"Id","@@value":{"value":1}}]}}'
 * 
 * 
 * ## JSON parsing
 * 
 * The reverse process of serialisation is parsing, and the `.fromJSON` method
 * provided by this derivation is able to reconstruct the proper ADT from
 * serialised data::
 * 
 *     const { data, setoid } = require('folktale/core/adt');
 *     const Id = data('Id', {
 *       Id(value){ return { value } }
 *     }).derive(serialize, setoid);
 * 
 *     const json = Id.Id(1).toJSON();
 *     Id.fromJSON(json);
 *     // ==> Id.Id(1)
 * 
 * In general, as long as the values in an ADT are either ADT instances or simple
 * values supported by JSON, the following equivalence holds:
 * 
 *     ADT.fromJSON(adt.toJSON()) = adt
 * 
 * Some ADTs instances may contain other ADT instances as values. Serialising them
 * is simple because JavaScript's dispatch takes care of selecting the correct
 * serialisation for us. With parsing we don't have that luck, so instead the
 * ADT takes a list of parsers as argument::
 * 
 *     const A = data('A', { 
 *       A(value) { return { value } }
 *     }).derive(serialize, setoid);
 * 
 *     const B = data('B', {
 *       B(value) { return { value } }
 *     }).derive(serialize, setoid);
 * 
 *     A.fromJSON(A.A(B.B(1)).toJSON(), [A, B]);
 *     // ==> A.A(B.B(1))
 * 
 * 
 * ## The serialisation format
 * 
 * In order to support the serialisatio and parsing of ADTs, this module
 * uses a specific format that encodes that information in the serialised
 * data. This way, `.toJSON()` produces values of this interface, and
 * `.fromJSON(value)` expects values of this interface:
 * 
 *     type JSONSerialisation = {
 *       "@@type":  String,
 *       "@@tag":   String,
 *       "@@value": Object Any
 *     }
 * 
 * 
 * ---
 * category: Derivation
 * stability: experimental
 * authors:
 *   - "@boris-marinov"
 * 
 * type: |
 *   (Variant, ADT) => Void 
 */
var serialize = __metamagical_withMeta(function (variant, adt) {
  var typeName = adt[typeSymbol];
  var tagName = variant.prototype[tagSymbol];

  /*~
   * Serialises a variant to JSON.
   * 
   * ## Example::
   * 
   *     const { data, setoid } = require('folktale/core/adt/core');
   *     const Id = data('Id', {
   *       Id(value){ return { value } }
   *     }).derive(serialize, setoid);
   * 
   *     Id.Id(1).toJSON();
   *     // ==> { '@@type': 'Id', '@@tag': 'Id', '@@value': { value: 1 } }
   *
   * 
   * ---
   * category: Serialisation
   * stability: experimental
   * authors:
   *   - "@boris-marinov"
   * 
   * type: |
   *   type JSONSerialisation = {
   *     "@@type":  String,
   *     "@@tag":   String,
   *     "@@value": Object Any
   *   }
   * 
   *   Variant . () => JSONSerialisation
   */
  variant.prototype.toJSON = __metamagical_withMeta(function () {
    var _ref;

    return _ref = {}, _defineProperty(_ref, typeJsonKey, typeName), _defineProperty(_ref, tagJsonKey, tagName), _defineProperty(_ref, valueJsonKey, mapValues(this, serializeValue)), _ref;
  }, {
    'name': 'toJSON',
    'source': 'function() {\n    return { \n      [typeJsonKey]:  typeName, \n      [tagJsonKey]:   tagName, \n      [valueJsonKey]: mapValues(this, serializeValue) \n    };\n  }',
    'signature': 'toJSON()',
    'belongsTo': function belongsTo() {
      return variant.prototype;
    },
    'category': 'Serialisation',
    'stability': 'experimental',
    'authors': ['@boris-marinov'],
    'type': 'type JSONSerialisation = {\n  "@@type":  String,\n  "@@tag":   String,\n  "@@value": Object Any\n}\n\nVariant . () => JSONSerialisation\n \n',
    'documentation': '\nSerialises a variant to JSON.\n\n## Example:\n\n    const { data, setoid } = require(\'folktale/core/adt/core\');\n    const Id = data(\'Id\', {\n      Id(value){ return { value } }\n    }).derive(serialize, setoid);\n\n    Id.Id(1).toJSON();\n    // ==> { \'@@type\': \'Id\', \'@@tag\': \'Id\', \'@@value\': { value: 1 } }\n\n',
    'examples': [{
      'name': '',
      'call': __metamagical_withMeta(function () {}, {
        'source': ''
      }),
      'inferred': true
    }, {
      'name': 'Example::',
      'call': __metamagical_withMeta(function () {
        var _require2 = require('./core');

        var data = _require2.data;
        var setoid = _require2.setoid;
        var Id = data('Id', {
          Id: function Id(value) {
            return { value: value };
          }
        }).derive(serialize, setoid);__metamagical_assert_equals(require('assert'), Id.Id(1).toJSON(), _defineProperty({ '@@type': 'Id', '@@tag': 'Id', '@@value': _defineProperty({ value: 1 }, Symbol.for('@@meta:magical:assertion-type'), 'record') }, Symbol.for('@@meta:magical:assertion-type'), 'record'), 'Id.Id(1).toJSON() ==> { \'@@type\': \'Id\', \'@@tag\': \'Id\', \'@@value\': { value: 1 } }');; // ==> { '@@type': 'Id', '@@tag': 'Id', '@@value': { value: 1 } }
      }, {
        'source': 'const { data, setoid } = require(\'folktale/core/adt/core\');\nconst Id = data(\'Id\', {\n  Id(value){ return { value } }\n}).derive(serialize, setoid);\n\nId.Id(1).toJSON();\n// ==> { \'@@type\': \'Id\', \'@@tag\': \'Id\', \'@@value\': { value: 1 } }'
      }),
      'inferred': true
    }]
  });

  /*~
   * Parses a previously serialised ADT into a rich ADT object.
   * 
   * ## Example::
   * 
   *     const { data, setoid } = require('folktale/core/adt/core');
   *     const Id = data('Id', {
   *       Id(value){ return { value } }
   *     }).derive(serialize, setoid);
   * 
   *     Id.Id(1).toJSON();
   *     // ==> { '@@type': 'Id', '@@tag': 'Id', '@@value': { value: 1 } }
   * 
   *     Id.fromJSON(Id.Id(1).toJSON());
   *     // ==> Id.Id(1)
   * 
   * ---
   * category: Serialisation
   * stability: experimental
   * authors:
   *   - "@boris-marinov"
   * 
   * type: |
   *   type JSONSerialisation = {
   *     "@@type":  String,
   *     "@@tag":   String,
   *     "@@value": Object Any
   *   }
   *   type JSONParser = {
   *     fromJSON: (JSONSerialisation, Array JSONParser) => Variant
   *   }
   * 
   *   (JSONSerialisation, Array JSONParser) => Variant
   */
  adt.fromJSON = __metamagical_withMeta(function (value) {
    var parsers = arguments.length <= 1 || arguments[1] === undefined ? _defineProperty({}, typeName, adt) : arguments[1];
    var keysIndicateType = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

    var valueTypeName = value[typeJsonKey];
    var valueTagName = value[tagJsonKey];
    var valueContents = value[valueJsonKey];
    assertType(typeName, valueTypeName);
    var parsersByType = keysIndicateType ? parsers : /*otherwise*/indexByType(values(parsers));

    var parsedValue = mapValues(valueContents, parseValue(parsersByType));
    return Object.assign(Object.create(adt[valueTagName].prototype), parsedValue);
  }, {
    'name': 'fromJSON',
    'source': 'function(value, parsers = { [typeName]: adt }, keysIndicateType = false) {\n    const valueTypeName = value[typeJsonKey];\n    const valueTagName = value[tagJsonKey];\n    const valueContents = value[valueJsonKey];\n    assertType(typeName, valueTypeName);\n    const parsersByType = keysIndicateType ? parsers\n          : /*otherwise*/                    indexByType(values(parsers));\n\n    const parsedValue = mapValues(valueContents, parseValue(parsersByType));\n    return Object.assign(Object.create(adt[valueTagName].prototype), parsedValue);\n  }',
    'signature': 'fromJSON(value, parsers = {\n  [typeName]: adt\n}, keysIndicateType = false)',
    'belongsTo': function belongsTo() {
      return adt;
    },
    'category': 'Serialisation',
    'stability': 'experimental',
    'authors': ['@boris-marinov'],
    'type': 'type JSONSerialisation = {\n  "@@type":  String,\n  "@@tag":   String,\n  "@@value": Object Any\n}\ntype JSONParser = {\n  fromJSON: (JSONSerialisation, Array JSONParser) => Variant\n}\n\n(JSONSerialisation, Array JSONParser) => Variant\n \n',
    'documentation': '\nParses a previously serialised ADT into a rich ADT object.\n\n## Example:\n\n    const { data, setoid } = require(\'folktale/core/adt/core\');\n    const Id = data(\'Id\', {\n      Id(value){ return { value } }\n    }).derive(serialize, setoid);\n\n    Id.Id(1).toJSON();\n    // ==> { \'@@type\': \'Id\', \'@@tag\': \'Id\', \'@@value\': { value: 1 } }\n\n    Id.fromJSON(Id.Id(1).toJSON());\n    // ==> Id.Id(1)\n',
    'examples': [{
      'name': '',
      'call': __metamagical_withMeta(function () {}, {
        'source': ''
      }),
      'inferred': true
    }, {
      'name': 'Example::',
      'call': __metamagical_withMeta(function () {
        var _require3 = require('./core');

        var data = _require3.data;
        var setoid = _require3.setoid;
        var Id = data('Id', {
          Id: function Id(value) {
            return { value: value };
          }
        }).derive(serialize, setoid);__metamagical_assert_equals(require('assert'), Id.Id(1).toJSON(), _defineProperty({ '@@type': 'Id', '@@tag': 'Id', '@@value': _defineProperty({ value: 1 }, Symbol.for('@@meta:magical:assertion-type'), 'record') }, Symbol.for('@@meta:magical:assertion-type'), 'record'), 'Id.Id(1).toJSON() ==> { \'@@type\': \'Id\', \'@@tag\': \'Id\', \'@@value\': { value: 1 } }');;__metamagical_assert_equals(require('assert'), Id.fromJSON(Id.Id(1).toJSON()), Id.Id(1), 'Id.fromJSON(Id.Id(1).toJSON()) ==> Id.Id(1)');; // ==> Id.Id(1)
      }, {
        'source': 'const { data, setoid } = require(\'folktale/core/adt/core\');\nconst Id = data(\'Id\', {\n  Id(value){ return { value } }\n}).derive(serialize, setoid);\n\nId.Id(1).toJSON();\n// ==> { \'@@type\': \'Id\', \'@@tag\': \'Id\', \'@@value\': { value: 1 } }\n\nId.fromJSON(Id.Id(1).toJSON());\n// ==> Id.Id(1)'
      }),
      'inferred': true
    }]
  });
}, {
  'name': 'serialize',
  'source': '(variant, adt) => {\n  const typeName = adt[typeSymbol];\n  const tagName = variant.prototype[tagSymbol];\n\n  /*~\n   * Serialises a variant to JSON.\n   * \n   * ## Example::\n   * \n   *     const { data, setoid } = require(\'folktale/core/adt/core\');\n   *     const Id = data(\'Id\', {\n   *       Id(value){ return { value } }\n   *     }).derive(serialize, setoid);\n   * \n   *     Id.Id(1).toJSON();\n   *     // ==> { \'@@type\': \'Id\', \'@@tag\': \'Id\', \'@@value\': { value: 1 } }\n   *\n   * \n   * ---\n   * category: Serialisation\n   * stability: experimental\n   * authors:\n   *   - "@boris-marinov"\n   * \n   * type: |\n   *   type JSONSerialisation = {\n   *     "@@type":  String,\n   *     "@@tag":   String,\n   *     "@@value": Object Any\n   *   }\n   * \n   *   Variant . () => JSONSerialisation\n   */\n  variant.prototype.toJSON = function() {\n    return { \n      [typeJsonKey]:  typeName, \n      [tagJsonKey]:   tagName, \n      [valueJsonKey]: mapValues(this, serializeValue) \n    };\n  };\n\n  /*~\n   * Parses a previously serialised ADT into a rich ADT object.\n   * \n   * ## Example::\n   * \n   *     const { data, setoid } = require(\'folktale/core/adt/core\');\n   *     const Id = data(\'Id\', {\n   *       Id(value){ return { value } }\n   *     }).derive(serialize, setoid);\n   * \n   *     Id.Id(1).toJSON();\n   *     // ==> { \'@@type\': \'Id\', \'@@tag\': \'Id\', \'@@value\': { value: 1 } }\n   * \n   *     Id.fromJSON(Id.Id(1).toJSON());\n   *     // ==> Id.Id(1)\n   * \n   * ---\n   * category: Serialisation\n   * stability: experimental\n   * authors:\n   *   - "@boris-marinov"\n   * \n   * type: |\n   *   type JSONSerialisation = {\n   *     "@@type":  String,\n   *     "@@tag":   String,\n   *     "@@value": Object Any\n   *   }\n   *   type JSONParser = {\n   *     fromJSON: (JSONSerialisation, Array JSONParser) => Variant\n   *   }\n   * \n   *   (JSONSerialisation, Array JSONParser) => Variant\n   */\n  adt.fromJSON = function(value, parsers = { [typeName]: adt }, keysIndicateType = false) {\n    const valueTypeName = value[typeJsonKey];\n    const valueTagName = value[tagJsonKey];\n    const valueContents = value[valueJsonKey];\n    assertType(typeName, valueTypeName);\n    const parsersByType = keysIndicateType ? parsers\n          : /*otherwise*/                    indexByType(values(parsers));\n\n    const parsedValue = mapValues(valueContents, parseValue(parsersByType));\n    return Object.assign(Object.create(adt[valueTagName].prototype), parsedValue);\n  };\n}',
  'signature': 'serialize(variant, adt)',
  'location': {
    'filename': 'src/core/adt/serialize.js',
    'start': {
      'line': 228,
      'column': 0
    },
    'end': {
      'line': 314,
      'column': 2
    }
  },
  'module': 'folktale/src/core/adt/serialize',
  'licence': 'MIT',
  'authors': ['@boris-marinov'],
  'repository': 'https://github.com/origamitower/folktale',
  'npmPackage': 'folktale',
  'category': 'Derivation',
  'stability': 'experimental',
  'type': '(Variant, ADT) => Void \n',
  'documentation': '\nProvides JSON serialisation and parsing for ADTs.\n\nThe `serialize` derivation bestows `.toJSON()` and `.fromJSON(value)`\nupon ADTs constructed by Core.ADT. Both serialisation and parsing\nare recursive, and `.fromJSON` can automatically reify values of\nother types.\n\n\n## Example:\n\n    const { data, setoid } = require(\'folktale/core/adt\');\n    const Id = data(\'Id\', {\n      Id(value){ return { value } }\n    }).derive(serialize, setoid);\n\n    Id.Id(1).toJSON();\n    // ==> { \'@@type\': \'Id\', \'@@tag\': \'Id\', \'@@value\': { value: 1 } }\n\n    Id.fromJSON(Id.Id(1).toJSON());\n    // ==> Id.Id(1)\n\n\n## JSON serialisation\n\nThis derivation provides JSON serialisation through the `.toJSON` method,\nwhich converts rich ADTs into objects that can be safely serialised as\nJSON. For example:\n\n    const data = require(\'folktale/core/adt/core\');\n    const { Id } = data(\'Id\', {\n      Id(value){ return { value } }\n    }).derive(serialize);\n\n    Id(1).toJSON();\n    // ==> { \'@@type\': \'Id\', \'@@tag\': \'Id\', \'@@value\': { value: 1 } }\n\nDuring the transformation, if any of the values contains a `.toJSON`\nmethod, that\'s called to serialise the structure. Otherwise the value is\njust returned as-is:\n\n    Id(Id(1)).toJSON();\n    // ==> { \'@@type\': \'Id\', \'@@tag\': \'Id\', \'@@value\': { value: { \'@@type\': \'Id\', \'@@tag\': \'Id\', \'@@value\': { \'value\': 1 } } } }\n\nIt\'s not necessary to call the `.toJSON()` method directly in most cases, since\n`JSON.stringify` will already invoke that for you:\n\n    JSON.stringify(Id(1));\n    // ==> \'{"@@type":"Id","@@tag":"Id","@@value":{"value":1}}\'\n\n    JSON.stringify(Id([Id(1)]));\n    // ==> \'{"@@type":"Id","@@tag":"Id","@@value":{"value":[{"@@type":"Id","@@tag":"Id","@@value":{"value":1}}]}}\'\n\n\n## JSON parsing\n\nThe reverse process of serialisation is parsing, and the `.fromJSON` method\nprovided by this derivation is able to reconstruct the proper ADT from\nserialised data:\n\n    const { data, setoid } = require(\'folktale/core/adt\');\n    const Id = data(\'Id\', {\n      Id(value){ return { value } }\n    }).derive(serialize, setoid);\n\n    const json = Id.Id(1).toJSON();\n    Id.fromJSON(json);\n    // ==> Id.Id(1)\n\nIn general, as long as the values in an ADT are either ADT instances or simple\nvalues supported by JSON, the following equivalence holds:\n\n    ADT.fromJSON(adt.toJSON()) = adt\n\nSome ADTs instances may contain other ADT instances as values. Serialising them\nis simple because JavaScript\'s dispatch takes care of selecting the correct\nserialisation for us. With parsing we don\'t have that luck, so instead the\nADT takes a list of parsers as argument:\n\n    const A = data(\'A\', { \n      A(value) { return { value } }\n    }).derive(serialize, setoid);\n\n    const B = data(\'B\', {\n      B(value) { return { value } }\n    }).derive(serialize, setoid);\n\n    A.fromJSON(A.A(B.B(1)).toJSON(), [A, B]);\n    // ==> A.A(B.B(1))\n\n\n## The serialisation format\n\nIn order to support the serialisatio and parsing of ADTs, this module\nuses a specific format that encodes that information in the serialised\ndata. This way, `.toJSON()` produces values of this interface, and\n`.fromJSON(value)` expects values of this interface:\n\n    type JSONSerialisation = {\n      "@@type":  String,\n      "@@tag":   String,\n      "@@value": Object Any\n    }\n\n',
  'examples': [{
    'name': '',
    'call': __metamagical_withMeta(function () {}, {
      'source': ''
    }),
    'inferred': true
  }, {
    'name': 'Example::',
    'call': __metamagical_withMeta(function () {
      var _require4 = require('./');

      var data = _require4.data;
      var setoid = _require4.setoid;
      var Id = data('Id', {
        Id: function Id(value) {
          return { value: value };
        }
      }).derive(serialize, setoid);__metamagical_assert_equals(require('assert'), Id.Id(1).toJSON(), _defineProperty({ '@@type': 'Id', '@@tag': 'Id', '@@value': _defineProperty({ value: 1 }, Symbol.for('@@meta:magical:assertion-type'), 'record') }, Symbol.for('@@meta:magical:assertion-type'), 'record'), 'Id.Id(1).toJSON() ==> { \'@@type\': \'Id\', \'@@tag\': \'Id\', \'@@value\': { value: 1 } }');; // ==> { '@@type': 'Id', '@@tag': 'Id', '@@value': { value: 1 } }
      __metamagical_assert_equals(require('assert'), Id.fromJSON(Id.Id(1).toJSON()), Id.Id(1), 'Id.fromJSON(Id.Id(1).toJSON()) ==> Id.Id(1)');; // ==> Id.Id(1)
    }, {
      'source': 'const { data, setoid } = require(\'folktale/core/adt\');\nconst Id = data(\'Id\', {\n  Id(value){ return { value } }\n}).derive(serialize, setoid);\n\nId.Id(1).toJSON();\n// ==> { \'@@type\': \'Id\', \'@@tag\': \'Id\', \'@@value\': { value: 1 } }\n\nId.fromJSON(Id.Id(1).toJSON());\n// ==> Id.Id(1)'
    }),
    'inferred': true
  }, {
    'name': 'JSON serialisation',
    'call': __metamagical_withMeta(function () {
      var data = require('./core');
      var _data$derive = data('Id', {
        Id: function Id(value) {
          return { value: value };
        }
      }).derive(serialize);

      var Id = _data$derive.Id;
      __metamagical_assert_equals(require('assert'), Id(1).toJSON(), _defineProperty({ '@@type': 'Id', '@@tag': 'Id', '@@value': _defineProperty({ value: 1 }, Symbol.for('@@meta:magical:assertion-type'), 'record') }, Symbol.for('@@meta:magical:assertion-type'), 'record'), 'Id(1).toJSON() ==> { \'@@type\': \'Id\', \'@@tag\': \'Id\', \'@@value\': { value: 1 } }');; // ==> { '@@type': 'Id', '@@tag': 'Id', '@@value': { value: 1 } }
      __metamagical_assert_equals(require('assert'), Id(Id(1)).toJSON(), _defineProperty({ '@@type': 'Id', '@@tag': 'Id', '@@value': _defineProperty({ value: _defineProperty({ '@@type': 'Id', '@@tag': 'Id', '@@value': _defineProperty({ 'value': 1 }, Symbol.for('@@meta:magical:assertion-type'), 'record') }, Symbol.for('@@meta:magical:assertion-type'), 'record') }, Symbol.for('@@meta:magical:assertion-type'), 'record') }, Symbol.for('@@meta:magical:assertion-type'), 'record'), 'Id(Id(1)).toJSON() ==> { \'@@type\': \'Id\', \'@@tag\': \'Id\', \'@@value\': { value: { \'@@type\': \'Id\', \'@@tag\': \'Id\', \'@@value\': { \'value\': 1 } } } }');; // ==> { '@@type': 'Id', '@@tag': 'Id', '@@value': { value: { '@@type': 'Id', '@@tag': 'Id', '@@value': { 'value': 1 } } } }
      __metamagical_assert_equals(require('assert'), JSON.stringify(Id(1)), '{"@@type":"Id","@@tag":"Id","@@value":{"value":1}}', 'JSON.stringify(Id(1)) ==> \'{"@@type":"Id","@@tag":"Id","@@value":{"value":1}}\'');; // ==> '{"@@type":"Id","@@tag":"Id","@@value":{"value":1}}'
      __metamagical_assert_equals(require('assert'), JSON.stringify(Id([Id(1)])), '{"@@type":"Id","@@tag":"Id","@@value":{"value":[{"@@type":"Id","@@tag":"Id","@@value":{"value":1}}]}}', 'JSON.stringify(Id([Id(1)])) ==> \'{"@@type":"Id","@@tag":"Id","@@value":{"value":[{"@@type":"Id","@@tag":"Id","@@value":{"value":1}}]}}\'');; // ==> '{"@@type":"Id","@@tag":"Id","@@value":{"value":[{"@@type":"Id","@@tag":"Id","@@value":{"value":1}}]}}'
    }, {
      'source': 'const data = require(\'folktale/core/adt/core\');\nconst { Id } = data(\'Id\', {\n  Id(value){ return { value } }\n}).derive(serialize);\n\nId(1).toJSON();\n// ==> { \'@@type\': \'Id\', \'@@tag\': \'Id\', \'@@value\': { value: 1 } }\n\nId(Id(1)).toJSON();\n// ==> { \'@@type\': \'Id\', \'@@tag\': \'Id\', \'@@value\': { value: { \'@@type\': \'Id\', \'@@tag\': \'Id\', \'@@value\': { \'value\': 1 } } } }\n\nJSON.stringify(Id(1));\n// ==> \'{"@@type":"Id","@@tag":"Id","@@value":{"value":1}}\'\n\nJSON.stringify(Id([Id(1)]));\n// ==> \'{"@@type":"Id","@@tag":"Id","@@value":{"value":[{"@@type":"Id","@@tag":"Id","@@value":{"value":1}}]}}\''
    }),
    'inferred': true
  }, {
    'name': 'JSON parsing',
    'call': __metamagical_withMeta(function () {
      var _require5 = require('./');

      var data = _require5.data;
      var setoid = _require5.setoid;
      var Id = data('Id', {
        Id: function Id(value) {
          return { value: value };
        }
      }).derive(serialize, setoid);var json = Id.Id(1).toJSON();__metamagical_assert_equals(require('assert'), Id.fromJSON(json), Id.Id(1), 'Id.fromJSON(json) ==> Id.Id(1)');; // ==> Id.Id(1)
      var A = data('A', {
        A: function A(value) {
          return { value: value };
        }
      }).derive(serialize, setoid);var B = data('B', {
        B: function B(value) {
          return { value: value };
        }
      }).derive(serialize, setoid);__metamagical_assert_equals(require('assert'), A.fromJSON(A.A(B.B(1)).toJSON(), [A, B]), A.A(B.B(1)), 'A.fromJSON(A.A(B.B(1)).toJSON(), [A, B]) ==> A.A(B.B(1))');; // ==> A.A(B.B(1))
    }, {
      'source': 'const { data, setoid } = require(\'folktale/core/adt\');\nconst Id = data(\'Id\', {\n  Id(value){ return { value } }\n}).derive(serialize, setoid);\n\nconst json = Id.Id(1).toJSON();\nId.fromJSON(json);\n// ==> Id.Id(1)\n\nconst A = data(\'A\', { \n  A(value) { return { value } }\n}).derive(serialize, setoid);\n\nconst B = data(\'B\', {\n  B(value) { return { value } }\n}).derive(serialize, setoid);\n\nA.fromJSON(A.A(B.B(1)).toJSON(), [A, B]);\n// ==> A.A(B.B(1))'
    }),
    'inferred': true
  }]
});

// --[ Exports ]--------------------------------------------------------
module.exports = serialize;
},{"../object/map-values":27,"../object/values":29,"./":2,"./core":1,"assert":54}],4:[function(require,module,exports){
(function (process){
'use strict';

var __metamagical_withMeta = function metamagical_withMeta(object, meta) {
  var parent = Object.getPrototypeOf(object);var oldMeta = object[Symbol.for('@@meta:magical')] || {};if (parent && parent[Symbol.for('@@meta:magical')] === oldMeta) {
    oldMeta = {};
  }Object.keys(meta).forEach(function (key) {
    if (/^~/.test(key)) {
      oldMeta[key.slice(1)] = meta[key];
    } else {
      oldMeta[key] = meta[key];
    }
  });object[Symbol.for('@@meta:magical')] = oldMeta;return object;
},
    __metamagical_assert_equals = function metamagical_assert_equals(assert, actual, expected, message) {
  var assertionType = Symbol.for('@@meta:magical:assertion-type');var rest = Symbol.for('@@meta:magical:assertion-rest');var keys = Object.keys;function isSetoid(value) {
    return value && typeof value.equals === 'function';
  }function isRecord(value) {
    return value && value[assertionType] === 'record';
  }function check(predicate) {
    for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }return values.every(predicate);
  }function getSpecialArrayLength(array) {
    var rests = array.map(function (x, i) {
      return [x, i];
    }).filter(function (pair) {
      return pair[0] === rest;
    });if (rests.length > 1 || rests[0] && rests[0][1] !== array.length - 1) {
      assert.ok(false, message + '. Assertions only support a single trailing rest indication for arrays currently.');
    }return (rests[0] || [null, array.length])[1];
  }function compareArrays(left, right) {
    var expectedLength = getSpecialArrayLength(right);assert.ok(Array.isArray(left), message + '. The LHS is not an array.');if (left.length < expectedLength) {
      assert.ok(false, message + '. The LHS does not have the minimum expected length (' + left.length + ' < ' + expectedLength + ')');
    }for (var i = 0; i < expectedLength; ++i) {
      compare(left[i], right[i]);
    }
  }function compareRecord(left, right) {
    var isPartial = right[rest];assert.ok(Object(left) === left, message);if (!isPartial) {
      assert.deepStrictEqual(keys(left).sort(), keys(right).sort(), message + '. The objects have different keys ([' + keys(left).sort().join(', ') + '] vs. [' + keys(right).sort().join(', ') + '])');
    }Object.keys(right).forEach(function (key) {
      if (!(key in left)) {
        assert.ok(false, message + '. The expected key ' + key + ' is not present in the actual object.');
      }compare(left[key], right[key]);
    });
  }function compare(l, r) {
    return check(isSetoid, l, r) ? assert.ok(l.equals(r), message + '. The LHS (' + l + ') setoid instance says the LHS and RHS (' + r + ') are not equal.') : Array.isArray(r) ? compareArrays(l, r) : isRecord(r) ? compareRecord(l, r) : /* otherwise */assert.deepStrictEqual(l, r, message + '. The LHS (' + l + ') and the RHS (' + r + ') are not structually equal.');
  }compare(actual, expected);
};

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

// --[ Dependencies ]---------------------------------------------------
var assertType = require('../../helpers/assertType');

var _require = require('../fantasy-land');

var flEquals = _require.equals;

var fl = require('../../helpers/fantasy-land');
var provideAliases = require('../../helpers/provide-fantasy-land-aliases');

var _require2 = require('./core');

var tagSymbol = _require2.tagSymbol;
var typeSymbol = _require2.typeSymbol;

// --[ Helpers ]--------------------------------------------------------

/*~
 * True if the value conforms to the Setoid interface.
 * 
 * ---
 * type: (Any) => Boolean
 */

var isSetoid = __metamagical_withMeta(function (value) {
  return value != null && (typeof value[fl.equals] === 'function' || typeof value.equals === 'function');
}, {
  'name': 'isSetoid',
  'source': '(value) => value != null \n                         && (typeof value[fl.equals] === \'function\' || typeof value.equals === \'function\')',
  'signature': 'isSetoid(value)',
  'location': {
    'filename': 'src/core/adt/setoid.js',
    'start': {
      'line': 26,
      'column': 0
    },
    'end': {
      'line': 27,
      'column': 107
    }
  },
  'module': 'folktale/src/core/adt/setoid',
  'licence': 'MIT',
  'authors': ['Quildreen Motta'],
  'repository': 'https://github.com/origamitower/folktale',
  'npmPackage': 'folktale',
  'type': '(Any) => Boolean',
  'documentation': '\nTrue if the value conforms to the Setoid interface.\n'
});

/*~
 * True if two variant instances are of the same type/tag.
 * 
 * ---
 * type: (Variant, Variant) => Boolean
 */
var sameType = __metamagical_withMeta(function (a, b) {
  return a[typeSymbol] === b[typeSymbol] && a[tagSymbol] === b[tagSymbol];
}, {
  'name': 'sameType',
  'source': '(a, b) => a[typeSymbol] === b[typeSymbol] \n                        && a[tagSymbol] === b[tagSymbol]',
  'signature': 'sameType(a, b)',
  'location': {
    'filename': 'src/core/adt/setoid.js',
    'start': {
      'line': 35,
      'column': 0
    },
    'end': {
      'line': 36,
      'column': 57
    }
  },
  'module': 'folktale/src/core/adt/setoid',
  'licence': 'MIT',
  'authors': ['Quildreen Motta'],
  'repository': 'https://github.com/origamitower/folktale',
  'npmPackage': 'folktale',
  'type': '(Variant, Variant) => Boolean',
  'documentation': '\nTrue if two variant instances are of the same type/tag.\n'
});

// --[ Implementation ]------------------------------------------------
/*~
 * Provides structural equality for ADTs.
 * 
 * The `setoid` derivation bestows Fantasy Land's `fantasy-land/equals`
 * method upon ADTs constructed by Core.ADT, as well as an `equals`
 * alias. This `equals` method performs structural equality, and may
 * be configured on how to compare values that aren't themselves setoids.
 * 
 * 
 * ## Example::
 * 
 *     const { data, setoid } = require('folktale/core/adt');
 *     const Result = data('Result', {
 *       Ok(value){
 *         return { value };
 *       },
 *       Error(value) {
 *         return { value };
 *       }
 *     }).derive(setoid);
 *     const { Ok, Error } = Result;
 * 
 *     Ok(1).equals(Ok(1));
 *     // ==> true
 * 
 *     Ok(1).equals(Error(1));
 *     // ==> false
 * 
 *     Error(Error(1)).equals(Error(Error(1)));
 *     // ==> true
 * 
 * 
 * ## Structural equality
 * 
 * The `equals` method provided by this derivation checks for structural
 * equivalence. That is, two values are considered equal if they have the
 * same content.
 * 
 * For simple ADTs this is pretty easy to see. For example, consider the
 * following definition::
 * 
 *     const { data, setoid } = require('folktale/core/adt');
 *     const Id = data('Id', {
 *       Id(value){ return { value } }
 *     }).derive(setoid);
 * 
 *     const a = Id.Id(1);
 *     const b = Id.Id(1);
 * 
 * Here we have an ADT with a single case, `Id`, and we've made two
 * instances of this data structure, each containing the value `1`.
 * However, if we try to compare them using JavaScript standard
 * operators, we'll not be comparing their contents, but rather whether
 * or not they are the same object::
 * 
 *     a === a; // ==> true
 *     b === b; // ==> true
 *     a === b; // ==> false
 * 
 * So `a === b` is false, even though both `a` and `b` have the same
 * contents. This is because `===` compares values by their identity,
 * and each object has a different identity.
 * 
 * If we want to compare things by value, we can use the `equals` method
 * provided by this setoid derivation instead::
 * 
 *     a.equals(b);        // ==> true
 *     a.equals(a);        // ==> true
 *     a.equals(Id.Id(2)); // ==> false
 * 
 * When comparing with the `equals` method, two values are considered
 * equal if they represent the same value. This is called *structural
 * equality*.
 * 
 * 
 * ## Equality in details
 * 
 * Given two data structures, they are considered equal if:
 * 
 *   - They have the same *type*;
 *   - They have the same *tag*;
 *   - They have the same keys, and these keys have the same values;
 * 
 * The following example shows these in practice::
 * 
 *     const { data, setoid } = require('folktale/core/adt');
 * 
 *     //                    â”Œâ—¦ TYPE
 *     //                  â”Œâ•Œâ”´â•Œâ•Œâ•Œâ•Œâ”
 *     const Result = data('Result', {
 *     //  â”Œâ—¦ TAG             â”Œâ—¦ KEYS
 *     // â”Œâ”´â”               â”Œâ•Œâ”´â•Œâ•Œâ•Œâ•Œâ•Œâ”
 *        Ok(value){ return { value } },
 * 
 *     //   â”Œâ—¦ TAG               â”Œâ—¦ KEYS
 *     // â”Œâ•Œâ”´â•Œâ”                â”Œâ•Œâ”´â•Œâ•Œâ•Œâ•Œâ•Œâ”
 *        Error(value){ return { value } }
 *     }).derive(setoid);
 * 
 *     const { Ok, Error } = Result;
 * 
 * So here we have the `Result` ADT. Values created from this ADT always
 * have the same type: "Result". A type is expected to be unique within
 * all ADTs in a program::
 * 
 *     Ok(1)[data.typeSymbol];    // ==> 'Result'
 *     Error(1)[data.typeSymbol]; // ==> 'Result'
 * 
 * Each variant has its own tag, which is the name you give to the
 * constructor. A tag is unique within an ADT, but not necessarily unique
 * amongst other ADTs::
 * 
 *     Ok(1)[data.tagSymbol];     // ==> 'Ok'
 *     Error(1)[data.tagSymbol];  // ==> 'Error'
 * 
 * Finally, the keys in an ADT are the same as the keys in the constructor
 * returns. So, in this case, both Ok and Errors have `[value]` as the key::
 * 
 *     Object.keys(Ok(1));    // ==> ['value']
 *     Object.keys(Error(1)); // ==> ['value']
 * 
 * So if we compare these two for equality::
 * 
 *     Ok(1).equals(Ok(1)); // ==> true
 *     // same type, tag, keys and values.
 * 
 *     Ok(1).equals(Ok(2)); // ==> false
 *     // same type, tag, and keys. Different values (1 !== 2).
 * 
 *     Ok(1).equals(Error(1)); // ==> false
 *     // same type, keys, and values. Different tags ('Ok' !== 'Error').
 * 
 *     const { Error: E } = data('Res', {
 *       Error(value){ return { value } }
 *     }).derive(setoid);
 * 
 *     E(1).equals(Error(1)); // ==> false
 *     // same tag, keys, and values. Different types ('Result' !== 'Res')
 * 
 * 
 * ## How complex equality works?
 * 
 * The values in an ADT aren't always a JS primitive, such as numbers and
 * strings. Setoid's `equals` method handles these in two different ways:
 * 
 *   - If the values are a setoid, then the values are compared using the
 *     left Setoid's `equals` method. This means that if all values are
 *     setoids or primitives, then deep equality just works.
 * 
 *   - If the values are not a setoid, the provided equality comparison is
 *     used to compare both values. By default, this comparison just uses
 *     reference equality, so it's the equivalent of `a === b`.
 * 
 * Here's an example::
 * 
 *     const { data, setoid } = require('folktale/core/adt');
 *     const { Id } = data('Id', {
 *       Id(value){ return { value } }
 *     }).derive(setoid);
 * 
 *     // This is fine, because all values are either Setoids or primitives
 *     Id(Id(1)).equals(Id(Id(1))); // ==> true
 * 
 *     // This is not fine, because it compares `[1] === [1]`
 *     Id([1]).equals(Id([1]));     // ==> false
 * 
 * To handle complex JS values, one must provide their own deep equality
 * function. Folktale does not have a deep equality function yet, but
 * most functional libraries have a `equals` function for that.
 * 
 * Here's an example of an equality function that checks array equality::
 * 
 *     const isEqual = (a, b) =>
 *       Array.isArray(a) && Array.isArray(b) ?  arrayEquals(a, b)
 *     : a == null                            ?  a === b
 *     : a['fantasy-land/equals']             ?  a['fantasy-land/equals'](b)
 *     : a.equals                             ?  a.equals(b)
 *     :                                         a === b;
 * 
 *     const arrayEquals = (a, b) =>
 *        Array.isArray(a) && Array.isArray(b)
 *     && a.length === b.length
 *     && a.every((x, i) => isEqual(x, b[i]));
 * 
 *     const { Id: Id2 } = data('Id', {
 *       Id(value){ return { value } }
 *     }).derive(setoid.withEquality(isEqual));
 * 
 *     Id2([1]).equals(Id2([1]));       // ==> true
 *     Id2(Id2(1)).equals(Id2(Id2(1))); // ==> true
 *     Id2(2).equals(Id2(1));           // ==> false
 * 
 * 
 * ## Setoid equality and the asymmetry problem::
 * 
 * Because the Setoid `equals` method is defined directly in objects,
 * and invoked using the method call syntax, it creates an asymmetry
 * problem. That is, if there are two objects, `a` and `b`, then
 * `a equals b` is not the same as `b equals a`, since the `equals`
 * method may be different on those objects!
 * 
 * Here's an example of the asymmetry problem::
 * 
 *     const { data, setoid } = require('folktale/core/adt');
 *     const { Id } = data('Id', {
 *       Id(value){ return { value } }
 *     }).derive(setoid);
 * 
 *     const bogus = {
 *       equals(that){ return that.value === this.value },
 *       value: 1
 *     };
 * 
 *     // This is what you expect
 *     Id(1).equals(bogus); // ==> false
 * 
 *     // And so is this
 *     Id(Id(1)).equals(Id(bogus)); // ==> false
 * 
 *     // But this is not
 *     Id(bogus).equals(Id(Id(1))); // ==> true
 * 
 * To avoid this problem all Setoid implementations should do type
 * checking and make sure that they have the same `equals` method.
 * Setoid implementations derived by this derivation do so by
 * checking the `type` and `tag` of the ADTs being compared.
 * 
 * 
 * ## Performance considerations
 * 
 * There are no optimisations for deep equality provided by this method,
 * thus you should expect it to visit every value starting from the root.
 * This can be quite expensive for larger data structures.
 * 
 * If you expect to be working with larger data structures, and check
 * equality between them often, you are, usually, very out of luck. You
 * may consider providing your own Setoid isntance with the following
 * optimisations:
 * 
 *   - If two objects are the same reference, you don't need to check
 *     them structurally, for they must be equal â€” Setoid does this,
 *     but if you're providing your own equality function, you must
 *     do this there as well;
 * 
 *   - If two objects have the same type, but different hashes, then
 *     they must have different values (assuming you haven't messed up
 *     your hash function);
 * 
 *   - If two objects have the same type, and the same hashes, then they
 *     *might* be equal, but you can't tell without looking at all of its
 *     values.
 * 
 * 
 * Here's an example of this optimisation applied to linked lists that
 * can only hold numbers (with a very naive hash function)::
 * 
 *     const hash = Symbol('hash code');
 *     const { data, setoid } = require('folktale/core/adt');
 * 
 *     const { Cons, Nil } = data('List', {
 *       Nil(){ return { [hash]: 0 } },
 *       Cons(value, rest) {
 *         return {
 *           [hash]: value + rest[hash],
 *           value, rest
 *         }
 *       }
 *     });
 * 
 *     Nil.prototype.equals = function(that) {
 *       return Nil.hasInstance(that);
 *     }
 * 
 *     Cons.prototype.equals = function(that) {
 *       if (this === that)              return true
 *       if (!Cons.hasInstance(that))    return false
 *       if (this[hash] !== that[hash])  return false
 *       
 *       return this.value === that.value
 *       &&     this.rest.equals(that.rest)
 *     }
 * 
 *     const a = Cons(1, Cons(2, Cons(3, Nil())));
 *     const b = Cons(1, Cons(2, Cons(3, Nil())));
 *     const c = Cons(1, b);
 * 
 *     a.equals(b); // ==> true
 *     a.equals(c); // ==> false
 * 
 * 
 * > **NOTE**:  
 * > You should use a suitable hashing algorithm for your data structures.
 * 
 * 
 * ---
 * category: Derivation
 * stability: experimental
 * authors:
 *   - "@boris-marinov"
 * 
 * type: |
 *   (('a, 'a) => Boolean) => (Variant, ADT) => Void
 */
var createDerivation = __metamagical_withMeta(function (valuesEqual) {
  /*~
   * Tests if two objects are equal.
   * ---
   * type: ('a, 'a) => Boolean
   */
  var equals = __metamagical_withMeta(function (a, b) {
    // identical objects must be equal
    if (a === b) return true;

    // we require both values to be setoids if one of them is
    var leftSetoid = isSetoid(a);
    var rightSetoid = isSetoid(b);
    if (leftSetoid) {
      if (rightSetoid) return flEquals(b, a);else return false;
    }

    // fall back to the provided equality
    return valuesEqual(a, b);
  }, {
    'name': 'equals',
    'source': '(a, b) => {\n    // identical objects must be equal\n    if (a === b)  return true;\n\n    // we require both values to be setoids if one of them is\n    const leftSetoid  = isSetoid(a);\n    const rightSetoid = isSetoid(b);\n    if (leftSetoid) {\n      if (rightSetoid)  return flEquals(b, a);\n      else              return false;\n    }\n\n    // fall back to the provided equality\n    return valuesEqual(a, b);\n  }',
    'signature': 'equals(a, b)',
    'location': {
      'filename': 'src/core/adt/setoid.js',
      'start': {
        'line': 349,
        'column': 2
      },
      'end': {
        'line': 363,
        'column': 4
      }
    },
    'module': 'folktale/src/core/adt/setoid',
    'licence': 'MIT',
    'authors': ['Quildreen Motta'],
    'repository': 'https://github.com/origamitower/folktale',
    'npmPackage': 'folktale',
    'type': '(\'a, \'a) => Boolean',
    'documentation': '\nTests if two objects are equal.'
  });

  /*~
   * Tests if two variants are equal.
   * ---
   * type: (Object Any, Object Any, Array String) => Boolean
   */
  var compositesEqual = __metamagical_withMeta(function (a, b, keys) {
    for (var i = 0; i < keys.length; ++i) {
      var keyA = a[keys[i]];
      var keyB = b[keys[i]];
      if (!equals(keyA, keyB)) {
        return false;
      }
    }
    return true;
  }, {
    'name': 'compositesEqual',
    'source': '(a, b, keys) => {\n    for (let i = 0; i < keys.length; ++i) {\n      const keyA = a[keys[i]];\n      const keyB = b[keys[i]];\n      if (!(equals(keyA, keyB))) {\n        return false;\n      }\n    }\n    return true;\n  }',
    'signature': 'compositesEqual(a, b, keys)',
    'location': {
      'filename': 'src/core/adt/setoid.js',
      'start': {
        'line': 371,
        'column': 2
      },
      'end': {
        'line': 380,
        'column': 4
      }
    },
    'module': 'folktale/src/core/adt/setoid',
    'licence': 'MIT',
    'authors': ['Quildreen Motta'],
    'repository': 'https://github.com/origamitower/folktale',
    'npmPackage': 'folktale',
    'type': '(Object Any, Object Any, Array String) => Boolean',
    'documentation': '\nTests if two variants are equal.'
  });

  var derivation = function derivation(variant, adt) {
    variant.prototype.equals = function (value) {
      assertType(adt)(this[tagSymbol] + '#equals', value);
      return sameType(this, value) && compositesEqual(this, value, Object.keys(this));
    };
    provideAliases(variant.prototype);
    return variant;
  };
  if (process.env.FOLKTALE_DOCS !== 'false') {
    derivation[Symbol.for('@@meta:magical')] = createDerivation[Symbol.for('@@meta:magical')];
    derivation[Symbol.for('@@meta:magical')].type = '(Variant, ADT) => Void';
  }

  return derivation;
}, {
  'name': 'createDerivation',
  'source': '(valuesEqual) => {\n  /*~\n   * Tests if two objects are equal.\n   * ---\n   * type: (\'a, \'a) => Boolean\n   */\n  const equals = (a, b) => {\n    // identical objects must be equal\n    if (a === b)  return true;\n\n    // we require both values to be setoids if one of them is\n    const leftSetoid  = isSetoid(a);\n    const rightSetoid = isSetoid(b);\n    if (leftSetoid) {\n      if (rightSetoid)  return flEquals(b, a);\n      else              return false;\n    }\n\n    // fall back to the provided equality\n    return valuesEqual(a, b);\n  };\n\n\n  /*~\n   * Tests if two variants are equal.\n   * ---\n   * type: (Object Any, Object Any, Array String) => Boolean\n   */\n  const compositesEqual = (a, b, keys) => {\n    for (let i = 0; i < keys.length; ++i) {\n      const keyA = a[keys[i]];\n      const keyB = b[keys[i]];\n      if (!(equals(keyA, keyB))) {\n        return false;\n      }\n    }\n    return true;\n  };\n\n\n  const derivation = (variant, adt) => {\n    variant.prototype.equals = function(value) {\n      assertType(adt)(`${this[tagSymbol]}#equals`, value);\n      return sameType(this, value) && compositesEqual(this, value, Object.keys(this));\n    };\n    provideAliases(variant.prototype);\n    return variant;\n  };\n  if (process.env.FOLKTALE_DOCS !== \'false\') {\n    derivation[Symbol.for(\'@@meta:magical\')] = createDerivation[Symbol.for(\'@@meta:magical\')];\n    derivation[Symbol.for(\'@@meta:magical\')].type = \'(Variant, ADT) => Void\';\n  }\n\n\n  return derivation;\n}',
  'signature': 'createDerivation(valuesEqual)',
  'location': {
    'filename': 'src/core/adt/setoid.js',
    'start': {
      'line': 343,
      'column': 0
    },
    'end': {
      'line': 398,
      'column': 2
    }
  },
  'module': 'folktale/src/core/adt/setoid',
  'licence': 'MIT',
  'authors': ['@boris-marinov'],
  'repository': 'https://github.com/origamitower/folktale',
  'npmPackage': 'folktale',
  'category': 'Derivation',
  'stability': 'experimental',
  'type': '((\'a, \'a) => Boolean) => (Variant, ADT) => Void\n',
  'documentation': '\nProvides structural equality for ADTs.\n\nThe `setoid` derivation bestows Fantasy Land\'s `fantasy-land/equals`\nmethod upon ADTs constructed by Core.ADT, as well as an `equals`\nalias. This `equals` method performs structural equality, and may\nbe configured on how to compare values that aren\'t themselves setoids.\n\n\n## Example:\n\n    const { data, setoid } = require(\'folktale/core/adt\');\n    const Result = data(\'Result\', {\n      Ok(value){\n        return { value };\n      },\n      Error(value) {\n        return { value };\n      }\n    }).derive(setoid);\n    const { Ok, Error } = Result;\n\n    Ok(1).equals(Ok(1));\n    // ==> true\n\n    Ok(1).equals(Error(1));\n    // ==> false\n\n    Error(Error(1)).equals(Error(Error(1)));\n    // ==> true\n\n\n## Structural equality\n\nThe `equals` method provided by this derivation checks for structural\nequivalence. That is, two values are considered equal if they have the\nsame content.\n\nFor simple ADTs this is pretty easy to see. For example, consider the\nfollowing definition:\n\n    const { data, setoid } = require(\'folktale/core/adt\');\n    const Id = data(\'Id\', {\n      Id(value){ return { value } }\n    }).derive(setoid);\n\n    const a = Id.Id(1);\n    const b = Id.Id(1);\n\nHere we have an ADT with a single case, `Id`, and we\'ve made two\ninstances of this data structure, each containing the value `1`.\nHowever, if we try to compare them using JavaScript standard\noperators, we\'ll not be comparing their contents, but rather whether\nor not they are the same object:\n\n    a === a; // ==> true\n    b === b; // ==> true\n    a === b; // ==> false\n\nSo `a === b` is false, even though both `a` and `b` have the same\ncontents. This is because `===` compares values by their identity,\nand each object has a different identity.\n\nIf we want to compare things by value, we can use the `equals` method\nprovided by this setoid derivation instead:\n\n    a.equals(b);        // ==> true\n    a.equals(a);        // ==> true\n    a.equals(Id.Id(2)); // ==> false\n\nWhen comparing with the `equals` method, two values are considered\nequal if they represent the same value. This is called *structural\nequality*.\n\n\n## Equality in details\n\nGiven two data structures, they are considered equal if:\n\n  - They have the same *type*;\n  - They have the same *tag*;\n  - They have the same keys, and these keys have the same values;\n\nThe following example shows these in practice:\n\n    const { data, setoid } = require(\'folktale/core/adt\');\n\n    //                    â”Œâ—¦ TYPE\n    //                  â”Œâ•Œâ”´â•Œâ•Œâ•Œâ•Œâ”\n    const Result = data(\'Result\', {\n    //  â”Œâ—¦ TAG             â”Œâ—¦ KEYS\n    // â”Œâ”´â”               â”Œâ•Œâ”´â•Œâ•Œâ•Œâ•Œâ•Œâ”\n       Ok(value){ return { value } },\n\n    //   â”Œâ—¦ TAG               â”Œâ—¦ KEYS\n    // â”Œâ•Œâ”´â•Œâ”                â”Œâ•Œâ”´â•Œâ•Œâ•Œâ•Œâ•Œâ”\n       Error(value){ return { value } }\n    }).derive(setoid);\n\n    const { Ok, Error } = Result;\n\nSo here we have the `Result` ADT. Values created from this ADT always\nhave the same type: "Result". A type is expected to be unique within\nall ADTs in a program:\n\n    Ok(1)[data.typeSymbol];    // ==> \'Result\'\n    Error(1)[data.typeSymbol]; // ==> \'Result\'\n\nEach variant has its own tag, which is the name you give to the\nconstructor. A tag is unique within an ADT, but not necessarily unique\namongst other ADTs:\n\n    Ok(1)[data.tagSymbol];     // ==> \'Ok\'\n    Error(1)[data.tagSymbol];  // ==> \'Error\'\n\nFinally, the keys in an ADT are the same as the keys in the constructor\nreturns. So, in this case, both Ok and Errors have `[value]` as the key:\n\n    Object.keys(Ok(1));    // ==> [\'value\']\n    Object.keys(Error(1)); // ==> [\'value\']\n\nSo if we compare these two for equality:\n\n    Ok(1).equals(Ok(1)); // ==> true\n    // same type, tag, keys and values.\n\n    Ok(1).equals(Ok(2)); // ==> false\n    // same type, tag, and keys. Different values (1 !== 2).\n\n    Ok(1).equals(Error(1)); // ==> false\n    // same type, keys, and values. Different tags (\'Ok\' !== \'Error\').\n\n    const { Error: E } = data(\'Res\', {\n      Error(value){ return { value } }\n    }).derive(setoid);\n\n    E(1).equals(Error(1)); // ==> false\n    // same tag, keys, and values. Different types (\'Result\' !== \'Res\')\n\n\n## How complex equality works?\n\nThe values in an ADT aren\'t always a JS primitive, such as numbers and\nstrings. Setoid\'s `equals` method handles these in two different ways:\n\n  - If the values are a setoid, then the values are compared using the\n    left Setoid\'s `equals` method. This means that if all values are\n    setoids or primitives, then deep equality just works.\n\n  - If the values are not a setoid, the provided equality comparison is\n    used to compare both values. By default, this comparison just uses\n    reference equality, so it\'s the equivalent of `a === b`.\n\nHere\'s an example:\n\n    const { data, setoid } = require(\'folktale/core/adt\');\n    const { Id } = data(\'Id\', {\n      Id(value){ return { value } }\n    }).derive(setoid);\n\n    // This is fine, because all values are either Setoids or primitives\n    Id(Id(1)).equals(Id(Id(1))); // ==> true\n\n    // This is not fine, because it compares `[1] === [1]`\n    Id([1]).equals(Id([1]));     // ==> false\n\nTo handle complex JS values, one must provide their own deep equality\nfunction. Folktale does not have a deep equality function yet, but\nmost functional libraries have a `equals` function for that.\n\nHere\'s an example of an equality function that checks array equality:\n\n    const isEqual = (a, b) =>\n      Array.isArray(a) && Array.isArray(b) ?  arrayEquals(a, b)\n    : a == null                            ?  a === b\n    : a[\'fantasy-land/equals\']             ?  a[\'fantasy-land/equals\'](b)\n    : a.equals                             ?  a.equals(b)\n    :                                         a === b;\n\n    const arrayEquals = (a, b) =>\n       Array.isArray(a) && Array.isArray(b)\n    && a.length === b.length\n    && a.every((x, i) => isEqual(x, b[i]));\n\n    const { Id: Id2 } = data(\'Id\', {\n      Id(value){ return { value } }\n    }).derive(setoid.withEquality(isEqual));\n\n    Id2([1]).equals(Id2([1]));       // ==> true\n    Id2(Id2(1)).equals(Id2(Id2(1))); // ==> true\n    Id2(2).equals(Id2(1));           // ==> false\n\n\n## Setoid equality and the asymmetry problem:\n\nBecause the Setoid `equals` method is defined directly in objects,\nand invoked using the method call syntax, it creates an asymmetry\nproblem. That is, if there are two objects, `a` and `b`, then\n`a equals b` is not the same as `b equals a`, since the `equals`\nmethod may be different on those objects!\n\nHere\'s an example of the asymmetry problem:\n\n    const { data, setoid } = require(\'folktale/core/adt\');\n    const { Id } = data(\'Id\', {\n      Id(value){ return { value } }\n    }).derive(setoid);\n\n    const bogus = {\n      equals(that){ return that.value === this.value },\n      value: 1\n    };\n\n    // This is what you expect\n    Id(1).equals(bogus); // ==> false\n\n    // And so is this\n    Id(Id(1)).equals(Id(bogus)); // ==> false\n\n    // But this is not\n    Id(bogus).equals(Id(Id(1))); // ==> true\n\nTo avoid this problem all Setoid implementations should do type\nchecking and make sure that they have the same `equals` method.\nSetoid implementations derived by this derivation do so by\nchecking the `type` and `tag` of the ADTs being compared.\n\n\n## Performance considerations\n\nThere are no optimisations for deep equality provided by this method,\nthus you should expect it to visit every value starting from the root.\nThis can be quite expensive for larger data structures.\n\nIf you expect to be working with larger data structures, and check\nequality between them often, you are, usually, very out of luck. You\nmay consider providing your own Setoid isntance with the following\noptimisations:\n\n  - If two objects are the same reference, you don\'t need to check\n    them structurally, for they must be equal â€” Setoid does this,\n    but if you\'re providing your own equality function, you must\n    do this there as well;\n\n  - If two objects have the same type, but different hashes, then\n    they must have different values (assuming you haven\'t messed up\n    your hash function);\n\n  - If two objects have the same type, and the same hashes, then they\n    *might* be equal, but you can\'t tell without looking at all of its\n    values.\n\n\nHere\'s an example of this optimisation applied to linked lists that\ncan only hold numbers (with a very naive hash function):\n\n    const hash = Symbol(\'hash code\');\n    const { data, setoid } = require(\'folktale/core/adt\');\n\n    const { Cons, Nil } = data(\'List\', {\n      Nil(){ return { [hash]: 0 } },\n      Cons(value, rest) {\n        return {\n          [hash]: value + rest[hash],\n          value, rest\n        }\n      }\n    });\n\n    Nil.prototype.equals = function(that) {\n      return Nil.hasInstance(that);\n    }\n\n    Cons.prototype.equals = function(that) {\n      if (this === that)              return true\n      if (!Cons.hasInstance(that))    return false\n      if (this[hash] !== that[hash])  return false\n      \n      return this.value === that.value\n      &&     this.rest.equals(that.rest)\n    }\n\n    const a = Cons(1, Cons(2, Cons(3, Nil())));\n    const b = Cons(1, Cons(2, Cons(3, Nil())));\n    const c = Cons(1, b);\n\n    a.equals(b); // ==> true\n    a.equals(c); // ==> false\n\n\n> **NOTE**:  \n> You should use a suitable hashing algorithm for your data structures.\n\n',
  'examples': [{
    'name': '',
    'call': __metamagical_withMeta(function () {}, {
      'source': ''
    }),
    'inferred': true
  }, {
    'name': 'Example::',
    'call': __metamagical_withMeta(function () {
      var _require3 = require('./');

      var data = _require3.data;
      var setoid = _require3.setoid;
      var Result = data('Result', {
        Ok: function Ok(value) {
          return { value: value };
        },
        Error: function Error(value) {
          return { value: value };
        }
      }).derive(setoid);var Ok = Result.Ok;
      var Error = Result.Error;
      __metamagical_assert_equals(require('assert'), Ok(1).equals(Ok(1)), true, 'Ok(1).equals(Ok(1)) ==> true');; // ==> true
      __metamagical_assert_equals(require('assert'), Ok(1).equals(Error(1)), false, 'Ok(1).equals(Error(1)) ==> false');; // ==> false
      __metamagical_assert_equals(require('assert'), Error(Error(1)).equals(Error(Error(1))), true, 'Error(Error(1)).equals(Error(Error(1))) ==> true');; // ==> true
    }, {
      'source': 'const { data, setoid } = require(\'folktale/core/adt\');\nconst Result = data(\'Result\', {\n  Ok(value){\n    return { value };\n  },\n  Error(value) {\n    return { value };\n  }\n}).derive(setoid);\nconst { Ok, Error } = Result;\n\nOk(1).equals(Ok(1));\n// ==> true\n\nOk(1).equals(Error(1));\n// ==> false\n\nError(Error(1)).equals(Error(Error(1)));\n// ==> true'
    }),
    'inferred': true
  }, {
    'name': 'Structural equality',
    'call': __metamagical_withMeta(function () {
      var _require4 = require('./');

      var data = _require4.data;
      var setoid = _require4.setoid;
      var Id = data('Id', {
        Id: function Id(value) {
          return { value: value };
        }
      }).derive(setoid);var a = Id.Id(1);var b = Id.Id(1);__metamagical_assert_equals(require('assert'), a === a, true, 'a === a ==> true');; // ==> true
      __metamagical_assert_equals(require('assert'), b === b, true, 'b === b ==> true');; // ==> true
      __metamagical_assert_equals(require('assert'), a === b, false, 'a === b ==> false');; // ==> false
      __metamagical_assert_equals(require('assert'), a.equals(b), true, 'a.equals(b) ==> true');; // ==> true
      __metamagical_assert_equals(require('assert'), a.equals(a), true, 'a.equals(a) ==> true');; // ==> true
      __metamagical_assert_equals(require('assert'), a.equals(Id.Id(2)), false, 'a.equals(Id.Id(2)) ==> false');; // ==> false
    }, {
      'source': 'const { data, setoid } = require(\'folktale/core/adt\');\nconst Id = data(\'Id\', {\n  Id(value){ return { value } }\n}).derive(setoid);\n\nconst a = Id.Id(1);\nconst b = Id.Id(1);\n\na === a; // ==> true\nb === b; // ==> true\na === b; // ==> false\n\na.equals(b);        // ==> true\na.equals(a);        // ==> true\na.equals(Id.Id(2)); // ==> false'
    }),
    'inferred': true
  }, {
    'name': 'Equality in details',
    'call': __metamagical_withMeta(function () {
      var _require5 = require('./');

      var data = _require5.data;
      var setoid = _require5.setoid; //                    â”Œâ—¦ TYPE
      //                  â”Œâ•Œâ”´â•Œâ•Œâ•Œâ•Œâ”

      var Result = data('Result', {
        //  â”Œâ—¦ TAG             â”Œâ—¦ KEYS
        // â”Œâ”´â”               â”Œâ•Œâ”´â•Œâ•Œâ•Œâ•Œâ•Œâ”
        Ok: function Ok(value) {
          return { value: value };
        },
        //   â”Œâ—¦ TAG               â”Œâ—¦ KEYS
        Error: function Error(value) {
          return { value: value };
        }
      }).derive(setoid);var Ok = Result.Ok;
      var Error = Result.Error;
      __metamagical_assert_equals(require('assert'), Ok(1)[data.typeSymbol], 'Result', 'Ok(1)[data.typeSymbol] ==> \'Result\'');; // ==> 'Result'
      __metamagical_assert_equals(require('assert'), Error(1)[data.typeSymbol], 'Result', 'Error(1)[data.typeSymbol] ==> \'Result\'');; // ==> 'Result'
      __metamagical_assert_equals(require('assert'), Ok(1)[data.tagSymbol], 'Ok', 'Ok(1)[data.tagSymbol] ==> \'Ok\'');; // ==> 'Ok'
      __metamagical_assert_equals(require('assert'), Error(1)[data.tagSymbol], 'Error', 'Error(1)[data.tagSymbol] ==> \'Error\'');; // ==> 'Error'
      __metamagical_assert_equals(require('assert'), Object.keys(Ok(1)), ['value'], 'Object.keys(Ok(1)) ==> [\'value\']');; // ==> ['value']
      __metamagical_assert_equals(require('assert'), Object.keys(Error(1)), ['value'], 'Object.keys(Error(1)) ==> [\'value\']');; // ==> ['value']
      __metamagical_assert_equals(require('assert'), Ok(1).equals(Ok(1)), true, 'Ok(1).equals(Ok(1)) ==> true');; // ==> true
      // same type, tag, keys and values.
      __metamagical_assert_equals(require('assert'), Ok(1).equals(Ok(2)), false, 'Ok(1).equals(Ok(2)) ==> false');; // ==> false
      // same type, tag, and keys. Different values (1 !== 2).
      __metamagical_assert_equals(require('assert'), Ok(1).equals(Error(1)), false, 'Ok(1).equals(Error(1)) ==> false');; // ==> false
      // same type, keys, and values. Different tags ('Ok' !== 'Error').

      var _data$derive = data('Res', {
        Error: function Error(value) {
          return { value: value };
        }
      }).derive(setoid);

      var E = _data$derive.Error;
      __metamagical_assert_equals(require('assert'), E(1).equals(Error(1)), false, 'E(1).equals(Error(1)) ==> false');; // ==> false
      // same tag, keys, and values. Different types ('Result' !== 'Res')
    }, {
      'source': 'const { data, setoid } = require(\'folktale/core/adt\');\n\n//                    â”Œâ—¦ TYPE\n//                  â”Œâ•Œâ”´â•Œâ•Œâ•Œâ•Œâ”\nconst Result = data(\'Result\', {\n//  â”Œâ—¦ TAG             â”Œâ—¦ KEYS\n// â”Œâ”´â”               â”Œâ•Œâ”´â•Œâ•Œâ•Œâ•Œâ•Œâ”\n   Ok(value){ return { value } },\n\n//   â”Œâ—¦ TAG               â”Œâ—¦ KEYS\n// â”Œâ•Œâ”´â•Œâ”                â”Œâ•Œâ”´â•Œâ•Œâ•Œâ•Œâ•Œâ”\n   Error(value){ return { value } }\n}).derive(setoid);\n\nconst { Ok, Error } = Result;\n\nOk(1)[data.typeSymbol];    // ==> \'Result\'\nError(1)[data.typeSymbol]; // ==> \'Result\'\n\nOk(1)[data.tagSymbol];     // ==> \'Ok\'\nError(1)[data.tagSymbol];  // ==> \'Error\'\n\nObject.keys(Ok(1));    // ==> [\'value\']\nObject.keys(Error(1)); // ==> [\'value\']\n\nOk(1).equals(Ok(1)); // ==> true\n// same type, tag, keys and values.\n\nOk(1).equals(Ok(2)); // ==> false\n// same type, tag, and keys. Different values (1 !== 2).\n\nOk(1).equals(Error(1)); // ==> false\n// same type, keys, and values. Different tags (\'Ok\' !== \'Error\').\n\nconst { Error: E } = data(\'Res\', {\n  Error(value){ return { value } }\n}).derive(setoid);\n\nE(1).equals(Error(1)); // ==> false\n// same tag, keys, and values. Different types (\'Result\' !== \'Res\')'
    }),
    'inferred': true
  }, {
    'name': 'How complex equality works?',
    'call': __metamagical_withMeta(function () {
      var _require6 = require('./');

      var data = _require6.data;
      var setoid = _require6.setoid;

      var _data$derive2 = data('Id', {
        Id: function Id(value) {
          return { value: value };
        }
      }).derive(setoid);

      var Id = _data$derive2.Id; // This is fine, because all values are either Setoids or primitives

      __metamagical_assert_equals(require('assert'), Id(Id(1)).equals(Id(Id(1))), true, 'Id(Id(1)).equals(Id(Id(1))) ==> true');; // ==> true
      // This is not fine, because it compares `[1] === [1]`
      __metamagical_assert_equals(require('assert'), Id([1]).equals(Id([1])), false, 'Id([1]).equals(Id([1])) ==> false');; // ==> false
      var isEqual = function isEqual(a, b) {
        return Array.isArray(a) && Array.isArray(b) ? arrayEquals(a, b) : a == null ? a === b : a['fantasy-land/equals'] ? a['fantasy-land/equals'](b) : a.equals ? a.equals(b) : a === b;
      };var arrayEquals = function arrayEquals(a, b) {
        return Array.isArray(a) && Array.isArray(b) && a.length === b.length && a.every(function (x, i) {
          return isEqual(x, b[i]);
        });
      };
      var _data$derive3 = data('Id', {
        Id: function Id(value) {
          return { value: value };
        }
      }).derive(setoid.withEquality(isEqual));

      var Id2 = _data$derive3.Id;
      __metamagical_assert_equals(require('assert'), Id2([1]).equals(Id2([1])), true, 'Id2([1]).equals(Id2([1])) ==> true');; // ==> true
      __metamagical_assert_equals(require('assert'), Id2(Id2(1)).equals(Id2(Id2(1))), true, 'Id2(Id2(1)).equals(Id2(Id2(1))) ==> true');; // ==> true
      __metamagical_assert_equals(require('assert'), Id2(2).equals(Id2(1)), false, 'Id2(2).equals(Id2(1)) ==> false');; // ==> false
    }, {
      'source': 'const { data, setoid } = require(\'folktale/core/adt\');\nconst { Id } = data(\'Id\', {\n  Id(value){ return { value } }\n}).derive(setoid);\n\n// This is fine, because all values are either Setoids or primitives\nId(Id(1)).equals(Id(Id(1))); // ==> true\n\n// This is not fine, because it compares `[1] === [1]`\nId([1]).equals(Id([1]));     // ==> false\n\nconst isEqual = (a, b) =>\n  Array.isArray(a) && Array.isArray(b) ?  arrayEquals(a, b)\n: a == null                            ?  a === b\n: a[\'fantasy-land/equals\']             ?  a[\'fantasy-land/equals\'](b)\n: a.equals                             ?  a.equals(b)\n:                                         a === b;\n\nconst arrayEquals = (a, b) =>\n   Array.isArray(a) && Array.isArray(b)\n&& a.length === b.length\n&& a.every((x, i) => isEqual(x, b[i]));\n\nconst { Id: Id2 } = data(\'Id\', {\n  Id(value){ return { value } }\n}).derive(setoid.withEquality(isEqual));\n\nId2([1]).equals(Id2([1]));       // ==> true\nId2(Id2(1)).equals(Id2(Id2(1))); // ==> true\nId2(2).equals(Id2(1));           // ==> false'
    }),
    'inferred': true
  }, {
    'name': 'Setoid equality and the asymmetry problem::',
    'call': __metamagical_withMeta(function () {
      var _require7 = require('./');

      var data = _require7.data;
      var setoid = _require7.setoid;

      var _data$derive4 = data('Id', {
        Id: function Id(value) {
          return { value: value };
        }
      }).derive(setoid);

      var Id = _data$derive4.Id;
      var bogus = {
        equals: function equals(that) {
          return that.value === this.value;
        },
        value: 1 }; // This is what you expect
      __metamagical_assert_equals(require('assert'), Id(1).equals(bogus), false, 'Id(1).equals(bogus) ==> false');; // ==> false
      // And so is this
      __metamagical_assert_equals(require('assert'), Id(Id(1)).equals(Id(bogus)), false, 'Id(Id(1)).equals(Id(bogus)) ==> false');; // ==> false
      // But this is not
      __metamagical_assert_equals(require('assert'), Id(bogus).equals(Id(Id(1))), true, 'Id(bogus).equals(Id(Id(1))) ==> true');; // ==> true
    }, {
      'source': 'const { data, setoid } = require(\'folktale/core/adt\');\nconst { Id } = data(\'Id\', {\n  Id(value){ return { value } }\n}).derive(setoid);\n\nconst bogus = {\n  equals(that){ return that.value === this.value },\n  value: 1\n};\n\n// This is what you expect\nId(1).equals(bogus); // ==> false\n\n// And so is this\nId(Id(1)).equals(Id(bogus)); // ==> false\n\n// But this is not\nId(bogus).equals(Id(Id(1))); // ==> true'
    }),
    'inferred': true
  }, {
    'name': 'Performance considerations',
    'call': __metamagical_withMeta(function () {
      var hash = Symbol('hash code');
      var _require8 = require('./');

      var data = _require8.data;
      var setoid = _require8.setoid;

      var _data = data('List', {
        Nil: function Nil() {
          return _defineProperty({}, hash, 0);
        },
        Cons: function Cons(value, rest) {
          var _ref2;

          return _ref2 = {}, _defineProperty(_ref2, hash, value + rest[hash]), _defineProperty(_ref2, 'value', value), _defineProperty(_ref2, 'rest', rest), _ref2;
        }
      });

      var Cons = _data.Cons;
      var Nil = _data.Nil;
      Nil.prototype.equals = function (that) {
        return Nil.hasInstance(that);
      };Cons.prototype.equals = function (that) {
        if (this === that) return true;if (!Cons.hasInstance(that)) return false;if (this[hash] !== that[hash]) return false;return this.value === that.value && this.rest.equals(that.rest);
      };var a = Cons(1, Cons(2, Cons(3, Nil())));var b = Cons(1, Cons(2, Cons(3, Nil())));var c = Cons(1, b);__metamagical_assert_equals(require('assert'), a.equals(b), true, 'a.equals(b) ==> true');; // ==> true
      __metamagical_assert_equals(require('assert'), a.equals(c), false, 'a.equals(c) ==> false');; // ==> false
    }, {
      'source': 'const hash = Symbol(\'hash code\');\nconst { data, setoid } = require(\'folktale/core/adt\');\n\nconst { Cons, Nil } = data(\'List\', {\n  Nil(){ return { [hash]: 0 } },\n  Cons(value, rest) {\n    return {\n      [hash]: value + rest[hash],\n      value, rest\n    }\n  }\n});\n\nNil.prototype.equals = function(that) {\n  return Nil.hasInstance(that);\n}\n\nCons.prototype.equals = function(that) {\n  if (this === that)              return true\n  if (!Cons.hasInstance(that))    return false\n  if (this[hash] !== that[hash])  return false\n\n  return this.value === that.value\n  &&     this.rest.equals(that.rest)\n}\n\nconst a = Cons(1, Cons(2, Cons(3, Nil())));\nconst b = Cons(1, Cons(2, Cons(3, Nil())));\nconst c = Cons(1, b);\n\na.equals(b); // ==> true\na.equals(c); // ==> false'
    }),
    'inferred': true
  }]
});

// --[ Exports ]-------------------------------------------------------
module.exports = createDerivation(function (a, b) {
  return a === b;
});
module.exports.withEquality = createDerivation;
}).call(this,require('_process'))
},{"../../helpers/assertType":47,"../../helpers/fantasy-land":48,"../../helpers/provide-fantasy-land-aliases":49,"../fantasy-land":16,"./":2,"./core":1,"_process":391,"assert":54}],5:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var __metamagical_withMeta = function metamagical_withMeta(object, meta) {
  var parent = Object.getPrototypeOf(object);var oldMeta = object[Symbol.for('@@meta:magical')] || {};if (parent && parent[Symbol.for('@@meta:magical')] === oldMeta) {
    oldMeta = {};
  }Object.keys(meta).forEach(function (key) {
    if (/^~/.test(key)) {
      oldMeta[key.slice(1)] = meta[key];
    } else {
      oldMeta[key] = meta[key];
    }
  });object[Symbol.for('@@meta:magical')] = oldMeta;return object;
},
    __metamagical_assert_equals = function metamagical_assert_equals(assert, actual, expected, message) {
  var assertionType = Symbol.for('@@meta:magical:assertion-type');var rest = Symbol.for('@@meta:magical:assertion-rest');var keys = Object.keys;function isSetoid(value) {
    return value && typeof value.equals === 'function';
  }function isRecord(value) {
    return value && value[assertionType] === 'record';
  }function check(predicate) {
    for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }return values.every(predicate);
  }function getSpecialArrayLength(array) {
    var rests = array.map(function (x, i) {
      return [x, i];
    }).filter(function (pair) {
      return pair[0] === rest;
    });if (rests.length > 1 || rests[0] && rests[0][1] !== array.length - 1) {
      assert.ok(false, message + '. Assertions only support a single trailing rest indication for arrays currently.');
    }return (rests[0] || [null, array.length])[1];
  }function compareArrays(left, right) {
    var expectedLength = getSpecialArrayLength(right);assert.ok(Array.isArray(left), message + '. The LHS is not an array.');if (left.length < expectedLength) {
      assert.ok(false, message + '. The LHS does not have the minimum expected length (' + left.length + ' < ' + expectedLength + ')');
    }for (var i = 0; i < expectedLength; ++i) {
      compare(left[i], right[i]);
    }
  }function compareRecord(left, right) {
    var isPartial = right[rest];assert.ok(Object(left) === left, message);if (!isPartial) {
      assert.deepStrictEqual(keys(left).sort(), keys(right).sort(), message + '. The objects have different keys ([' + keys(left).sort().join(', ') + '] vs. [' + keys(right).sort().join(', ') + '])');
    }Object.keys(right).forEach(function (key) {
      if (!(key in left)) {
        assert.ok(false, message + '. The expected key ' + key + ' is not present in the actual object.');
      }compare(left[key], right[key]);
    });
  }function compare(l, r) {
    return check(isSetoid, l, r) ? assert.ok(l.equals(r), message + '. The LHS (' + l + ') setoid instance says the LHS and RHS (' + r + ') are not equal.') : Array.isArray(r) ? compareArrays(l, r) : isRecord(r) ? compareRecord(l, r) : /* otherwise */assert.deepStrictEqual(l, r, message + '. The LHS (' + l + ') and the RHS (' + r + ') are not structually equal.');
  }compare(actual, expected);
};

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

// --[ Dependencies ]---------------------------------------------------
var _require = require('./core');

var tagSymbol = _require.tagSymbol;
var typeSymbol = _require.typeSymbol;

// --[ Helpers ]--------------------------------------------------------
/*~
 * Returns a string representing `key: value` pairs separated by
 * commas.
 * ---
 * type: (Object Any) => String
 */

var objectToKeyValuePairs = __metamagical_withMeta(function (object) {
  return Object.keys(object).map(function (key) {
    return key + ': ' + showValue(object[key]);
  }).join(', ');
}, {
  'name': 'objectToKeyValuePairs',
  'source': '(object) =>\n  Object.keys(object)\n        .map((key) => `${key}: ${showValue(object[key])}`)\n        .join(\', \')',
  'signature': 'objectToKeyValuePairs(object)',
  'location': {
    'filename': 'src/core/adt/show.js',
    'start': {
      'line': 21,
      'column': 0
    },
    'end': {
      'line': 24,
      'column': 20
    }
  },
  'module': 'folktale/src/core/adt/show',
  'licence': 'MIT',
  'authors': ['Quildreen Motta'],
  'repository': 'https://github.com/origamitower/folktale',
  'npmPackage': 'folktale',
  'type': '(Object Any) => String',
  'documentation': '\nReturns a string representing `key: value` pairs separated by\ncommas.'
});

/*~
 * Returns a presentation of a plain object.
 * ---
 * type: (Object Any).() => String
 */
var plainObjectToString = __metamagical_withMeta(function () {
  return '{ ' + objectToKeyValuePairs(this) + ' }';
}, {
  'name': 'plainObjectToString',
  'source': 'function() {\n  return `{ ${objectToKeyValuePairs(this)} }`;\n}',
  'signature': 'plainObjectToString()',
  'location': {
    'filename': 'src/core/adt/show.js',
    'start': {
      'line': 31,
      'column': 0
    },
    'end': {
      'line': 33,
      'column': 2
    }
  },
  'module': 'folktale/src/core/adt/show',
  'licence': 'MIT',
  'authors': ['Quildreen Motta'],
  'repository': 'https://github.com/origamitower/folktale',
  'npmPackage': 'folktale',
  'type': '(Object Any).() => String',
  'documentation': '\nReturns a presentation of a plain object.'
});

/*~
 * Returns a representation of an array.
 * ---
 * type: (Array Any).() => String
 */
var arrayToString = __metamagical_withMeta(function () {
  return '[' + this.map(showValue).join(', ') + ']';
}, {
  'name': 'arrayToString',
  'source': 'function() {\n  return `[${this.map(showValue).join(\', \')}]`;\n}',
  'signature': 'arrayToString()',
  'location': {
    'filename': 'src/core/adt/show.js',
    'start': {
      'line': 40,
      'column': 0
    },
    'end': {
      'line': 42,
      'column': 2
    }
  },
  'module': 'folktale/src/core/adt/show',
  'licence': 'MIT',
  'authors': ['Quildreen Motta'],
  'repository': 'https://github.com/origamitower/folktale',
  'npmPackage': 'folktale',
  'type': '(Array Any).() => String',
  'documentation': '\nReturns a representation of an array.'
});

/*~
 * Returns a representation of a function's name.
 * ---
 * type: (Function) => String
 */
var functionNameToString = __metamagical_withMeta(function (fn) {
  return fn.name !== '' ? ': ' + fn.name : '';
}, {
  'name': 'functionNameToString',
  'source': '(fn) => fn.name !== \'\' ? `: ${fn.name}` : \'\'',
  'signature': 'functionNameToString(fn)',
  'location': {
    'filename': 'src/core/adt/show.js',
    'start': {
      'line': 49,
      'column': 0
    },
    'end': {
      'line': 49,
      'column': 74
    }
  },
  'module': 'folktale/src/core/adt/show',
  'licence': 'MIT',
  'authors': ['Quildreen Motta'],
  'repository': 'https://github.com/origamitower/folktale',
  'npmPackage': 'folktale',
  'type': '(Function) => String',
  'documentation': '\nReturns a representation of a function\'s name.'
});

/*~
 * Returns a representation of a function.
 * ---
 * type: (Function) => String
 */
var functionToString = __metamagical_withMeta(function (fn) {
  return '[Function' + functionNameToString(fn) + ']';
}, {
  'name': 'functionToString',
  'source': '(fn) => `[Function${functionNameToString(fn)}]`',
  'signature': 'functionToString(fn)',
  'location': {
    'filename': 'src/core/adt/show.js',
    'start': {
      'line': 56,
      'column': 0
    },
    'end': {
      'line': 56,
      'column': 73
    }
  },
  'module': 'folktale/src/core/adt/show',
  'licence': 'MIT',
  'authors': ['Quildreen Motta'],
  'repository': 'https://github.com/origamitower/folktale',
  'npmPackage': 'folktale',
  'type': '(Function) => String',
  'documentation': '\nReturns a representation of a function.'
});

/*~
 * Returns a representation of a null value.
 * ---
 * type: () => String
 */
var nullToString = __metamagical_withMeta(function () {
  return 'null';
}, {
  'name': 'nullToString',
  'source': '() => \'null\'',
  'signature': 'nullToString()',
  'location': {
    'filename': 'src/core/adt/show.js',
    'start': {
      'line': 63,
      'column': 0
    },
    'end': {
      'line': 63,
      'column': 34
    }
  },
  'module': 'folktale/src/core/adt/show',
  'licence': 'MIT',
  'authors': ['Quildreen Motta'],
  'repository': 'https://github.com/origamitower/folktale',
  'npmPackage': 'folktale',
  'type': '() => String',
  'documentation': '\nReturns a representation of a null value.'
});

/*~
 * Returns a representation of any JS object.
 * ---
 * type: (Null | Object Any) => String
 */
var objectToString = __metamagical_withMeta(function (object) {
  return object === null ? nullToString : Array.isArray(object) ? arrayToString : object.toString() === {}.toString() ? plainObjectToString : /* otherwise */object.toString;
}, {
  'name': 'objectToString',
  'source': '(object) =>\n    object === null                       ?  nullToString\n  : Array.isArray(object)                 ?  arrayToString\n  : object.toString() === ({}).toString() ?  plainObjectToString\n  : /* otherwise */                          object.toString',
  'signature': 'objectToString(object)',
  'location': {
    'filename': 'src/core/adt/show.js',
    'start': {
      'line': 70,
      'column': 0
    },
    'end': {
      'line': 74,
      'column': 61
    }
  },
  'module': 'folktale/src/core/adt/show',
  'licence': 'MIT',
  'authors': ['Quildreen Motta'],
  'repository': 'https://github.com/origamitower/folktale',
  'npmPackage': 'folktale',
  'type': '(Null | Object Any) => String',
  'documentation': '\nReturns a representation of any JS object.'
});

/*~
 * Returns a representation of any JS value.
 * ---
 * type: (Any) => String
 */
var showValue = __metamagical_withMeta(function (value) {
  return typeof value === 'undefined' ? 'undefined' : typeof value === 'function' ? functionToString(value) : (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'symbol' ? value.toString() : (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' ? objectToString(value).call(value) : /* otherwise */JSON.stringify(value);
}, {
  'name': 'showValue',
  'source': '(value) =>\n    typeof value === \'undefined\' ?  \'undefined\'\n  : typeof value === \'function\'  ?  functionToString(value)\n  : typeof value === \'symbol\'    ?  value.toString()\n  : typeof value === \'object\'    ?  objectToString(value).call(value)\n  : /* otherwise */                 JSON.stringify(value)',
  'signature': 'showValue(value)',
  'location': {
    'filename': 'src/core/adt/show.js',
    'start': {
      'line': 82,
      'column': 0
    },
    'end': {
      'line': 87,
      'column': 58
    }
  },
  'module': 'folktale/src/core/adt/show',
  'licence': 'MIT',
  'authors': ['Quildreen Motta'],
  'repository': 'https://github.com/origamitower/folktale',
  'npmPackage': 'folktale',
  'type': '(Any) => String',
  'documentation': '\nReturns a representation of any JS value.'
});

// --[ Implementation ]------------------------------------------------

/*~
 * Provides a textual representation for ADTs.
 * 
 * The `show` serialisation bestows ES2015's `Symbol.toStringTag`, used
 * for the native `Object.prototype.toString`, along with a `.toString()`
 * method and Node's REPL `.inspect()` method.
 * 
 * 
 * ## Example::
 * 
 *     const { data, show } = require('folktale/core/adt');
 *     const { Id } = data('Id', {
 *       Id(value){ return { value } }
 *     }).derive(show);
 * 
 *     Object.prototype.toString.call(Id(1));
 *     // => '[object Id.Id]'
 * 
 *     Id(1).toString();
 *     // ==> 'Id.Id({ value: 1 })'
 * 
 *     Id(1).inspect();
 *     // ==> 'Id.Id({ value: 1 })'
 * 
 * 
 * ## ES2015's ToStringTag
 * 
 * This derivation defines ES2015's `ToStringTag` symbol, which is used
 * by [Object.prototype.toString][toString] to construct a default textual
 * representation of the object.
 * 
 * This means that instead of getting `'[object Object]'`, you'll get
 * a more helpful `'[object <Type>.<Tag>]'` representation, where this
 * function is used.
 * 
 * [toString]: http://www.ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring
 * 
 * 
 * ## Textual representation
 * 
 * This derivation defines a `.toString()` method. `.toString` is called
 * in many places to define how to represent an object, but also called
 * when JS operators want to convert an object to a String. This derivation
 * only cares about representation that's suitable for debugging.
 * 
 * The representation includes the type, tag, and key/value pairs of the
 * data structure.
 * 
 * 
 * ## Node REPL representation
 * 
 * Node's REPL uses `.inspect()` instead of the regular `.toString()`.
 * This derivation also provides the `.inspect()` method, but just as
 * an alias for the `.toString()` method.
 * 
 * 
 * ---
 * category: Derivation
 * stability: experimental
 * authors:
 *   - "@boris-marinov"
 * 
 * type: |
 *   (Variant, ADT) => Void
 */
var show = __metamagical_withMeta(function (variant, adt) {
  var typeName = adt[typeSymbol];
  var variantName = adt[typeSymbol] + '.' + variant.prototype[tagSymbol];

  // (for Object.prototype.toString)
  adt[Symbol.toStringTag] = typeName;
  variant.prototype[Symbol.toStringTag] = variantName;

  // (regular JavaScript representations)
  /*~
   * Returns a textual representation of the ADT.
   * ---
   * category: Debug Representation
   * stability: experimental
   * authors:
   *   - "@boris-marinov"
   * 
   * type: |
   *   () => String
   */
  adt.toString = __metamagical_withMeta(function () {
    return typeName;
  }, {
    'name': 'toString',
    'source': '() => typeName',
    'signature': 'toString()',
    'belongsTo': function belongsTo() {
      return adt;
    },
    'category': 'Debug Representation',
    'stability': 'experimental',
    'authors': ['@boris-marinov'],
    'type': '() => String\n \n',
    'documentation': '\nReturns a textual representation of the ADT.'
  });

  /*~
   * Returns a textual representation of the Variant.
   * ---
   * category: Debug Representation
   * stability: experimental
   * authors:
   *   - "@boris-marinov"
   * 
   * type: |
   *   () => String
   */
  variant.toString = __metamagical_withMeta(function () {
    return variantName;
  }, {
    'name': 'toString',
    'source': '() => variantName',
    'signature': 'toString()',
    'belongsTo': function belongsTo() {
      return variant;
    },
    'category': 'Debug Representation',
    'stability': 'experimental',
    'authors': ['@boris-marinov'],
    'type': '() => String\n \n',
    'documentation': '\nReturns a textual representation of the Variant.'
  });

  /*~
   * Returns a textual representation of the ADT instance.
   * ---
   * category: Debug Representation
   * stability: experimental
   * authors:
   *   - "@boris-marinov"
   * 
   * type: |
   *   (ADT).() => String
   */
  variant.prototype.toString = __metamagical_withMeta(function () {
    return variantName + '(' + plainObjectToString.call(this) + ')';
  }, {
    'name': 'toString',
    'source': 'function() {\n    return `${variantName}(${plainObjectToString.call(this)})`;\n  }',
    'signature': 'toString()',
    'belongsTo': function belongsTo() {
      return variant.prototype;
    },
    'category': 'Debug Representation',
    'stability': 'experimental',
    'authors': ['@boris-marinov'],
    'type': '(ADT).() => String\n \n',
    'documentation': '\nReturns a textual representation of the ADT instance.'
  });

  // (Node REPL representations)
  adt.inspect = adt.toString;
  variant.inspect = variant.toString;
  variant.prototype.inspect = variant.prototype.toString;

  return variant;
}, {
  'name': 'show',
  'source': '(variant, adt) => {\n  const typeName    = adt[typeSymbol];\n  const variantName = `${adt[typeSymbol]}.${variant.prototype[tagSymbol]}`;\n\n  // (for Object.prototype.toString)\n  adt[Symbol.toStringTag]               = typeName;\n  variant.prototype[Symbol.toStringTag] = variantName;\n\n  // (regular JavaScript representations)\n  /*~\n   * Returns a textual representation of the ADT.\n   * ---\n   * category: Debug Representation\n   * stability: experimental\n   * authors:\n   *   - "@boris-marinov"\n   * \n   * type: |\n   *   () => String\n   */\n  adt.toString = () => typeName;\n\n  /*~\n   * Returns a textual representation of the Variant.\n   * ---\n   * category: Debug Representation\n   * stability: experimental\n   * authors:\n   *   - "@boris-marinov"\n   * \n   * type: |\n   *   () => String\n   */\n  variant.toString = () => variantName;\n\n  /*~\n   * Returns a textual representation of the ADT instance.\n   * ---\n   * category: Debug Representation\n   * stability: experimental\n   * authors:\n   *   - "@boris-marinov"\n   * \n   * type: |\n   *   (ADT).() => String\n   */\n  variant.prototype.toString = function() {\n    return `${variantName}(${plainObjectToString.call(this)})`;\n  };\n\n  // (Node REPL representations)\n  adt.inspect                = adt.toString;\n  variant.inspect            = variant.toString;\n  variant.prototype.inspect  = variant.prototype.toString;\n\n  return variant;\n}',
  'signature': 'show(variant, adt)',
  'location': {
    'filename': 'src/core/adt/show.js',
    'start': {
      'line': 156,
      'column': 0
    },
    'end': {
      'line': 212,
      'column': 2
    }
  },
  'module': 'folktale/src/core/adt/show',
  'licence': 'MIT',
  'authors': ['@boris-marinov'],
  'repository': 'https://github.com/origamitower/folktale',
  'npmPackage': 'folktale',
  'category': 'Derivation',
  'stability': 'experimental',
  'type': '(Variant, ADT) => Void\n',
  'documentation': '\nProvides a textual representation for ADTs.\n\nThe `show` serialisation bestows ES2015\'s `Symbol.toStringTag`, used\nfor the native `Object.prototype.toString`, along with a `.toString()`\nmethod and Node\'s REPL `.inspect()` method.\n\n\n## Example:\n\n    const { data, show } = require(\'folktale/core/adt\');\n    const { Id } = data(\'Id\', {\n      Id(value){ return { value } }\n    }).derive(show);\n\n    Object.prototype.toString.call(Id(1));\n    // => \'[object Id.Id]\'\n\n    Id(1).toString();\n    // ==> \'Id.Id({ value: 1 })\'\n\n    Id(1).inspect();\n    // ==> \'Id.Id({ value: 1 })\'\n\n\n## ES2015\'s ToStringTag\n\nThis derivation defines ES2015\'s `ToStringTag` symbol, which is used\nby [Object.prototype.toString][toString] to construct a default textual\nrepresentation of the object.\n\nThis means that instead of getting `\'[object Object]\'`, you\'ll get\na more helpful `\'[object <Type>.<Tag>]\'` representation, where this\nfunction is used.\n\n[toString]: http://www.ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring\n\n\n## Textual representation\n\nThis derivation defines a `.toString()` method. `.toString` is called\nin many places to define how to represent an object, but also called\nwhen JS operators want to convert an object to a String. This derivation\nonly cares about representation that\'s suitable for debugging.\n\nThe representation includes the type, tag, and key/value pairs of the\ndata structure.\n\n\n## Node REPL representation\n\nNode\'s REPL uses `.inspect()` instead of the regular `.toString()`.\nThis derivation also provides the `.inspect()` method, but just as\nan alias for the `.toString()` method.\n\n',
  'examples': [{
    'name': '',
    'call': __metamagical_withMeta(function () {}, {
      'source': ''
    }),
    'inferred': true
  }, {
    'name': 'Example::',
    'call': __metamagical_withMeta(function () {
      var _require2 = require('./');

      var data = _require2.data;
      var show = _require2.show;

      var _data$derive = data('Id', {
        Id: function Id(value) {
          return { value: value };
        }
      }).derive(show);

      var Id = _data$derive.Id;
      Object.prototype.toString.call(Id(1)); // => '[object Id.Id]'
      __metamagical_assert_equals(require('assert'), Id(1).toString(), 'Id.Id({ value: 1 })', 'Id(1).toString() ==> \'Id.Id({ value: 1 })\'');; // ==> 'Id.Id({ value: 1 })'
      __metamagical_assert_equals(require('assert'), Id(1).inspect(), 'Id.Id({ value: 1 })', 'Id(1).inspect() ==> \'Id.Id({ value: 1 })\'');; // ==> 'Id.Id({ value: 1 })'
    }, {
      'source': 'const { data, show } = require(\'folktale/core/adt\');\nconst { Id } = data(\'Id\', {\n  Id(value){ return { value } }\n}).derive(show);\n\nObject.prototype.toString.call(Id(1));\n// => \'[object Id.Id]\'\n\nId(1).toString();\n// ==> \'Id.Id({ value: 1 })\'\n\nId(1).inspect();\n// ==> \'Id.Id({ value: 1 })\''
    }),
    'inferred': true
  }, {
    'name': 'ES2015\'s ToStringTag',
    'call': __metamagical_withMeta(function () {}, {
      'source': ''
    }),
    'inferred': true
  }, {
    'name': 'Textual representation',
    'call': __metamagical_withMeta(function () {}, {
      'source': ''
    }),
    'inferred': true
  }]
});

// --[ Exports ]-------------------------------------------------------
module.exports = show;
},{"./":2,"./core":1,"assert":54}],6:[function(require,module,exports){
'use strict';

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

var _require = require('../../../helpers/fantasy-land');

var ap = _require.ap;

var warn = require('../../../helpers/warn-deprecated')('ap');
var unsupported = require('../../../helpers/unsupported-method')('ap');

module.exports = function (a, b) {
  return typeof a[ap] === 'function' ? b[ap](a) : typeof a.ap === 'function' ? warn(a.ap(b)) : /*otherwise*/unsupported(a);
};
},{"../../../helpers/fantasy-land":48,"../../../helpers/unsupported-method":50,"../../../helpers/warn-deprecated":51}],7:[function(require,module,exports){
'use strict';

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

var _require = require('../../../helpers/fantasy-land');

var bimap = _require.bimap;

var warn = require('../../../helpers/warn-deprecated')('bimap');
var unsupported = require('../../../helpers/unsupported-method')('bimap');

module.exports = function (f, g, a) {
  return typeof a[bimap] === 'function' ? a[bimap](f, g) : typeof a.bimap === 'function' ? warn(a.bimap(f, g)) : /*otherwise*/unsupported(a);
};
},{"../../../helpers/fantasy-land":48,"../../../helpers/unsupported-method":50,"../../../helpers/warn-deprecated":51}],8:[function(require,module,exports){
'use strict';

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

var _require = require('../../../helpers/fantasy-land');

var chain = _require.chain;

var warn = require('../../../helpers/warn-deprecated')('chain');
var unsupported = require('../../../helpers/unsupported-method')('chain');

module.exports = function (f, a) {
  return typeof a[chain] === 'function' ? a[chain](f) : typeof a.chain === 'function' ? warn(a.chain(f)) : /*otherwise*/unsupported(a);
};
},{"../../../helpers/fantasy-land":48,"../../../helpers/unsupported-method":50,"../../../helpers/warn-deprecated":51}],9:[function(require,module,exports){
'use strict';

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

var _require = require('../../../helpers/fantasy-land');

var concat = _require.concat;

var warn = require('../../../helpers/warn-deprecated')('concat');
var unsupported = require('../../../helpers/unsupported-method')('concat');

module.exports = function (b, a) {
  return typeof a[concat] === 'function' ? a[concat](b) : typeof a.concat === 'function' ? warn(a.concat(b)) : /*otherwise*/unsupported(a);
};
},{"../../../helpers/fantasy-land":48,"../../../helpers/unsupported-method":50,"../../../helpers/warn-deprecated":51}],10:[function(require,module,exports){
'use strict';

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

var _require = require('../../../helpers/fantasy-land');

var empty = _require.empty;

var warn = require('../../../helpers/warn-deprecated')('empty');
var unsupported = require('../../../helpers/unsupported-method')('empty');

module.exports = function (a) {
  return typeof a[empty] === 'function' ? a[empty]() : typeof a.constructor[empty] === 'function' ? a.constructor[empty]() : typeof a.empty === 'function' ? warn(a.empty()) : typeof a.constructor.empty === 'function' ? warn(a.constructor.empty()) : /*otherwise*/unsupported(a);
};
},{"../../../helpers/fantasy-land":48,"../../../helpers/unsupported-method":50,"../../../helpers/warn-deprecated":51}],11:[function(require,module,exports){
'use strict';

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

var _require = require('../../../helpers/fantasy-land');

var equals = _require.equals;

var warn = require('../../../helpers/warn-deprecated')('equals');
var unsupported = require('../../../helpers/unsupported-method')('equals');

module.exports = function (b, a) {
  return typeof a[equals] === 'function' ? a[equals](b) : typeof a.equals === 'function' ? warn(a.equals(b)) : /*otherwise*/unsupported(a);
};
},{"../../../helpers/fantasy-land":48,"../../../helpers/unsupported-method":50,"../../../helpers/warn-deprecated":51}],12:[function(require,module,exports){
'use strict';

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

module.exports = {
  ap: require('./ap'),
  concat: require('./concat'),
  chain: require('./chain'),
  empty: require('./empty'),
  map: require('./map'),
  of: require('./of'),
  equals: require('./equals'),
  bimap: require('./bimap')
};
},{"./ap":6,"./bimap":7,"./chain":8,"./concat":9,"./empty":10,"./equals":11,"./map":13,"./of":14}],13:[function(require,module,exports){
'use strict';

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

var _require = require('../../../helpers/fantasy-land');

var map = _require.map;

var warn = require('../../../helpers/warn-deprecated')('map');
var unsupported = require('../../../helpers/unsupported-method')('map');

module.exports = function (f, a) {
  return typeof a[map] === 'function' ? a[map](f) : typeof a.map === 'function' ? warn(a.map(f)) : /*otherwise*/unsupported(a);
};
},{"../../../helpers/fantasy-land":48,"../../../helpers/unsupported-method":50,"../../../helpers/warn-deprecated":51}],14:[function(require,module,exports){
'use strict';

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

var _require = require('../../../helpers/fantasy-land');

var of = _require.of;

var warn = require('../../../helpers/warn-deprecated')('of');
var unsupported = require('../../../helpers/unsupported-method')('of');

module.exports = function (f, a) {
  return typeof f[of] === 'function' ? f[of](a) : typeof f.constructor[of] === 'function' ? f.constructor[of](a) : typeof f.of === 'function' ? warn(f.of(a)) : typeof f.constructor.of === 'function' ? warn(f.constructor.of(a)) : /*otherwise*/unsupported(f);
};
},{"../../../helpers/fantasy-land":48,"../../../helpers/unsupported-method":50,"../../../helpers/warn-deprecated":51}],15:[function(require,module,exports){
'use strict';

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

var mapValues = require('../object/map-values');
var curry = require('../lambda/curry');

module.exports = mapValues(require('./core'), function (f) {
  return curry(f.length, f);
});
},{"../lambda/curry":20,"../object/map-values":27,"./core":12}],16:[function(require,module,exports){
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var __metamagical_withMeta = function metamagical_withMeta(object, meta) {
  var parent = Object.getPrototypeOf(object);var oldMeta = object[Symbol.for('@@meta:magical')] || {};if (parent && parent[Symbol.for('@@meta:magical')] === oldMeta) {
    oldMeta = {};
  }Object.keys(meta).forEach(function (key) {
    if (/^~/.test(key)) {
      oldMeta[key.slice(1)] = meta[key];
    } else {
      oldMeta[key] = meta[key];
    }
  });object[Symbol.for('@@meta:magical')] = oldMeta;return object;
};

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

/*~
 * Essential building blocks and compositional operations which are
 * likely to be used by most programs are provided by this module.
 *
 * These operations usually don't fit in more specific categories,
 * like `data`, or provide a better alternative to functionality
 * that's already provided by the language itself.
 *
 * --------------------------------------------------------------------
 * name        : module folktale/core
 * module      : folktale/core
 * copyright   : (c) 2015-2016 Quildreen Motta, and CONTRIBUTORS
 * licence     : MIT
 * repository  : https://github.com/origamitower/folktale
 *
 * category    : Essential Operations
 *
 * maintainers:
 *   - Quildreen Motta <queen@robotlolita.me>
 */
module.exports = __metamagical_withMeta(_extends({}, require('./core'), {
  curried: require('./curried')
}), {
  'name': 'module folktale/core',
  'source': '{\n  ...require(\'./core\'),\n  curried: require(\'./curried\')\n}',
  'location': {
    'filename': 'src/core/fantasy-land/index.js',
    'start': {
      'line': 30,
      'column': 0
    },
    'end': {
      'line': 33,
      'column': 2
    }
  },
  'module': 'folktale/core',
  'licence': 'MIT',
  'authors': ['Quildreen Motta'],
  'repository': 'https://github.com/origamitower/folktale',
  'npmPackage': 'folktale',
  'isModule': true,
  'copyright': '(c) 2015-2016 Quildreen Motta, and CONTRIBUTORS',
  'category': 'Essential Operations',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me>'],
  'documentation': '\nEssential building blocks and compositional operations which are\nlikely to be used by most programs are provided by this module.\n\nThese operations usually don\'t fit in more specific categories,\nlike `data`, or provide a better alternative to functionality\nthat\'s already provided by the language itself.\n'
});
},{"./core":12,"./curried":15}],17:[function(require,module,exports){
'use strict';

var __metamagical_withMeta = function metamagical_withMeta(object, meta) {
  var parent = Object.getPrototypeOf(object);var oldMeta = object[Symbol.for('@@meta:magical')] || {};if (parent && parent[Symbol.for('@@meta:magical')] === oldMeta) {
    oldMeta = {};
  }Object.keys(meta).forEach(function (key) {
    if (/^~/.test(key)) {
      oldMeta[key.slice(1)] = meta[key];
    } else {
      oldMeta[key] = meta[key];
    }
  });object[Symbol.for('@@meta:magical')] = oldMeta;return object;
};

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

/*~
 * Provides essential functionality for functional programs.
 * 
 * 
 * ## What's in Core?
 * 
 * This module provides a range of features that are often used as
 * foundational building blocks in functional programming. It also
 * provides features for handling some common built-in JavaScript
 * structures in a functional way.
 * 
 * The operations are divided as follows:
 * 
 *   - **Modelling Data**: The Core.ADT module provides an
 *     implementation of Tagged Unions with limited pattern matching.
 *     This can be used to model your application's data more accurately,
 *     and thus make it harder to misuse that data;
 * 
 *   - **Combining Functions**: The Core.Lambda module provides
 *     operations on functions that allow combining functions together
 *     (like `compose`) or changing how you apply functions (like `curry`
 *     or `partialise`);
 * 
 *   - **Working with Objects as Dictionaries**: The Core.Object module
 *     provides operations that let you treat regular JavaScript objects
 *     as dictionaries. Several JavaScript APIs expect that usage of
 *     objects, but the built-in operations don't support  this well,
 *     so the Core.Object module addresses that.
 *
 * ---
 * name        : module folktale/core
 * category    : Essential Operations
 */
module.exports = __metamagical_withMeta({
  lambda: require('./lambda'),
  adt: require('./adt'),
  object: require('./object'),
  fantasyLand: require('./fantasy-land')
}, {
  'name': 'module folktale/core',
  'source': '{\n  lambda: require(\'./lambda\'),\n  adt: require(\'./adt\'),\n  object: require(\'./object\'),\n  fantasyLand: require(\'./fantasy-land\')\n}',
  'location': {
    'filename': 'src/core/index.js',
    'start': {
      'line': 43,
      'column': 0
    },
    'end': {
      'line': 48,
      'column': 2
    }
  },
  'module': 'folktale/src/core',
  'licence': 'MIT',
  'authors': ['Quildreen Motta'],
  'repository': 'https://github.com/origamitower/folktale',
  'npmPackage': 'folktale',
  'isModule': true,
  'category': 'Essential Operations',
  'documentation': '\nProvides essential functionality for functional programs.\n\n\n## What\'s in Core?\n\nThis module provides a range of features that are often used as\nfoundational building blocks in functional programming. It also\nprovides features for handling some common built-in JavaScript\nstructures in a functional way.\n\nThe operations are divided as follows:\n\n  - **Modelling Data**: The Core.ADT module provides an\n    implementation of Tagged Unions with limited pattern matching.\n    This can be used to model your application\'s data more accurately,\n    and thus make it harder to misuse that data;\n\n  - **Combining Functions**: The Core.Lambda module provides\n    operations on functions that allow combining functions together\n    (like `compose`) or changing how you apply functions (like `curry`\n    or `partialise`);\n\n  - **Working with Objects as Dictionaries**: The Core.Object module\n    provides operations that let you treat regular JavaScript objects\n    as dictionaries. Several JavaScript APIs expect that usage of\n    objects, but the built-in operations don\'t support  this well,\n    so the Core.Object module addresses that.\n',
  'examples': [{
    'name': '',
    'call': __metamagical_withMeta(function () {}, {
      'source': ''
    }),
    'inferred': true
  }]
});
},{"./adt":2,"./fantasy-land":16,"./lambda":22,"./object":25}],18:[function(require,module,exports){
"use strict";

var __metamagical_withMeta = function metamagical_withMeta(object, meta) {
  var parent = Object.getPrototypeOf(object);var oldMeta = object[Symbol.for('@@meta:magical')] || {};if (parent && parent[Symbol.for('@@meta:magical')] === oldMeta) {
    oldMeta = {};
  }Object.keys(meta).forEach(function (key) {
    if (/^~/.test(key)) {
      oldMeta[key.slice(1)] = meta[key];
    } else {
      oldMeta[key] = meta[key];
    }
  });object[Symbol.for('@@meta:magical')] = oldMeta;return object;
},
    __metamagical_assert_equals = function metamagical_assert_equals(assert, actual, expected, message) {
  var assertionType = Symbol.for('@@meta:magical:assertion-type');var rest = Symbol.for('@@meta:magical:assertion-rest');var keys = Object.keys;function isSetoid(value) {
    return value && typeof value.equals === 'function';
  }function isRecord(value) {
    return value && value[assertionType] === 'record';
  }function check(predicate) {
    for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }return values.every(predicate);
  }function getSpecialArrayLength(array) {
    var rests = array.map(function (x, i) {
      return [x, i];
    }).filter(function (pair) {
      return pair[0] === rest;
    });if (rests.length > 1 || rests[0] && rests[0][1] !== array.length - 1) {
      assert.ok(false, message + '. Assertions only support a single trailing rest indication for arrays currently.');
    }return (rests[0] || [null, array.length])[1];
  }function compareArrays(left, right) {
    var expectedLength = getSpecialArrayLength(right);assert.ok(Array.isArray(left), message + '. The LHS is not an array.');if (left.length < expectedLength) {
      assert.ok(false, message + '. The LHS does not have the minimum expected length (' + left.length + ' < ' + expectedLength + ')');
    }for (var i = 0; i < expectedLength; ++i) {
      compare(left[i], right[i]);
    }
  }function compareRecord(left, right) {
    var isPartial = right[rest];assert.ok(Object(left) === left, message);if (!isPartial) {
      assert.deepStrictEqual(keys(left).sort(), keys(right).sort(), message + '. The objects have different keys ([' + keys(left).sort().join(', ') + '] vs. [' + keys(right).sort().join(', ') + '])');
    }Object.keys(right).forEach(function (key) {
      if (!(key in left)) {
        assert.ok(false, message + '. The expected key ' + key + ' is not present in the actual object.');
      }compare(left[key], right[key]);
    });
  }function compare(l, r) {
    return check(isSetoid, l, r) ? assert.ok(l.equals(r), message + '. The LHS (' + l + ') setoid instance says the LHS and RHS (' + r + ') are not equal.') : Array.isArray(r) ? compareArrays(l, r) : isRecord(r) ? compareRecord(l, r) : /* otherwise */assert.deepStrictEqual(l, r, message + '. The LHS (' + l + ') and the RHS (' + r + ') are not structually equal.');
  }compare(actual, expected);
};

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

/*~
 * Composes two functions.
 *
 *
 * ## Example::
 *
 *     const inc       = (x) => x + 1;
 *     const double    = (x) => x * 2;
 *     const incDouble = compose(double, inc);
 *
 *     incDouble(3);
 *     // ==> 8
 *
 *
 * ## Why Composition Matters?
 *
 * Composition is a way of creating new functionality by combining
 * existing functionality. It helps managing complexity in software
 * projects, since newer functionality can be defined in terms of
 * existing ones, reducing both the amount of code needed to implement
 * newer features, and the amount of time one needs to spend to understand
 * them.
 *
 * This technique is used very often in regular JavaScript code, when
 * we feed the results of a function into another function::
 *
 *     const names = [
 *       'Alissa', 'Max', 'Talib'
 *     ];
 *     const upcase = (name) => name.toUpperCase();
 *
 *     names.map(upcase).join(', ');
 *     // ==> 'ALISSA, MAX, TALIB'
 *
 * Here `names` is fed into the `map` function, which returns an array
 * of the same names in capitals. This new array is then fed into the
 * `join` function, which returns a String where the items are separated
 * by a comma.
 *
 * If we need to use `.map(upcase).join(', ')` in a lot of places, it
 * makes sense to create a new function that captures that composition,
 * so we don't have to type it everywhere::
 *
 *     const showNames = (names) =>
 *       names.map(upcase).join(', ');
 *
 * Now we can use `showNames` instead of `.map(upcase).join(', ')`, and
 * we get the same functionality::
 *
 *     showNames(names);
 *     // ==> 'ALISSA, MAX, TALIB'
 *
 *
 * ## The Problem With Methods in JavaScript
 *
 * JavaScript is a hybrid language, where you can express programs by
 * using object oriented techniques, functional programming techniques,
 * and some other paradigms. It's not uncommon to see parts of a program
 * expressed in OOP, as in the examples from the previous section.
 *
 * However, objects in JavaScript can't be safely extended. Ideally, we'd
 * like to write:
 *
 *     names.show();
 *
 * Instead of:
 *
 *     showNames(names);
 *
 * Which would be more consistent with the rest of the program. Because
 * this involves mutating the array, all sorts of problems could happen
 * so it's better to keep the new functionality as a separate function.
 *
 * Expressing things in functional programming doesn't have this problem
 * because functions exist on their own, rather than being part of an
 * object.
 *
 *
 * ## Composition in Functional Programming
 *
 * In functional programming, functions are the basic building block,
 * and we compose functions to create bigger things. To do this, we often
 * have to rephrase the common method calls in terms of regular functions::
 *
 *     const names = [
 *       'Alissa', 'Max', 'Talib'
 *     ];
 *
 *     const upcase = (name) => name.toUpperCase();
 *     const map    = (transform, items) => items.map(transform);
 *     const join   = (separator, items) => items.join(separator);
 *
 * With this we can express the composition in terms of regular function
 * calls::
 *
 *     const showNames = (names) =>
 *       join(', ', map(upcase, names));
 *
 *     showNames(names);
 *     // ==> 'ALISSA, MAX, TALIB'
 *
 * Now, while the way this program expresses its functions is consistent,
 * we still have to move the whole expression into the function, and
 * our code is not as easy to follow as before. Rather than reading from
 * left to right, we have to first read the inside of a function application
 * before we read what's outside of it.
 *
 * These issues are not a problem with simple expressions such as these,
 * and most of the expressions in functional programming tend to be very
 * simple. But we can improve this by abstracting over the idea of
 * composition. That is, instead of requiring syntactic composition, by
 * having people write out the whole expression, we can ask the program
 * to combine these functions for us. This is what the `compose` function
 * does::
 *
 *     const showNames2 = compose(
 *       capitals => join(', ', capitals),
 *       names    => map(upcase, names)
 *     );
 *
 * Instead of reading from inside of a complex expression to the outside,
 * now you can read each expression on its own, and visualise the flow of
 * data linearly.
 *
 * > **CONVENIENCE**  
 * > `compose` does right-to-left composition, so the last function is
 * > applied first. You can use the `infix` version of compose to avoid
 * > this.
 *
 *
 * ## Currying and Composition
 *
 * Composing unary functions is trivial, as seen on the first example
 * of this documentation::
 *
 *     const inc       = (x) => x + 1;
 *     const double    = (x) => x * 2;
 *     const incDouble = compose(double, inc);
 *
 * But composing functions that take more than one argument doesn't read
 * as naturally::
 *
 *     const upcase = (name) => name.toUpperCase();
 *     const map    = (transform, items) => items.map(transform);
 *     const join   = (separator, items) => items.join(separator);
 *
 *     const showNames = compose(
 *       capitals => join(', ', capitals),
 *       names    => map(upcase, names)
 *     );
 *
 * The problem is that `compose` can only safely compose unary functions,
 * so you have to do some additional work to place the values in the
 * "right places" when your function takes more than one argument.
 *
 * One way to solve this problem is to curry the functions that will be
 * composed. That is, turn a function of arity N, into N functions of
 * arity 1::
 *
 *     const upcase2 = (name) => name.toUpperCase();
 *     const map2    = (transform) => (items) => items.map(transform);
 *     const join2   = (separator) => (items) => items.join(separator);
 *
 *     const showNames2 = compose(join2(', '), map2(upcase2));
 *
 * Note that with a small change to how `map` and `join` are defined, we
 * can make a much better use of the `compose` function. This is not
 * without its drawbacks, however, as now `join` has to be called as
 * `join(',')(names)`.
 *
 * > **CONVENIECE**  
 * > Folktale offers a `curry` function as a convenience for automatically
 * > creating curried versions of existing functions, which also works
 * > around the 1-argument limitation.
 * >
 * > See `folktale/core/lambda/curry` for details.
 *
 * Another way to work around this problem is by using the `partialise`
 * function provided by Folktale. This function creates a new function
 * that specifies only parts of the argument for the original function::
 *
 *     const partialise = require('folktale/core/lambda/partialise');
 *     const _          = partialise.hole;
 *
 *     const upcase3 = (name) => name.toUpperCase();
 *     const map3    = partialise(2, (transform, items) => items.map(transform));
 *     const join3   = partialise(2, (separator, items) => items.join(separator));
 *
 *     const showNames3 = compose(
 *       join3(', ', _),
 *       map3(upcase, _)
 *     );
 *
 * See `folktale/core/lambda/partialise` for more information on how the
 * `partialise` function works.
 *
 *
 * ## Composing More Than Two Functions
 *
 * The `compose` operation is limited to composing only two functions.
 * This might sound limiting, but it ensures that function composition
 * is well-defined.
 *
 * Because a lot of functions in JavaScript are expected to be variadic,
 * and just ignore the additional parameters, you'd get some very
 * surprising behaviour when trying to pass `compose` to them. For example,
 * the following would throw a type error:
 *
 *     const inc    = (x) => x + 1;
 *     const double = (x) => x * 2;
 *     const square = (x) => x * x;
 *
 *     [inc, double, square].reduce(compose)(3);
 *     // ==> throws TypeError: '1 is not a function'
 *
 * Because it's equivalent to:
 *
 *     const fns = [inc, double, square];
 *     compose(
 *       compose(
 *         square,
 *         double,
 *         1,
 *         fns
 *       ),
 *       inc
 *       0,
 *       fns
 *     )(3);
 *
 *
 * If you need to compose more than two functions, you can use the
 * `infix` syntax, or the `all` convenience function.
 *
 *
 * ### Composition With The Infix Syntax
 *
 * With the [This-Binding syntax][es-bind] proposed for JavaScript, it's
 * possible to compose multiple functions in an, arguably, more natural way::
 *
 *      const then  = compose.infix;
 *      const inc   = (x) => x + 1;
 *      const plus4 = inc::then(inc)::then(inc)::then(inc);
 *
 *      plus4(2);
 *      // ==> 6
 *
 *
 * ### Composition With The `all` Function
 *
 * If you need to compose more than two functions, you might consider using
 * the `all` convenience function instead, which is variadic::
 *
 *     const inc   = (x) => x + 1;
 *     const plus4 = compose.all(inc, inc, inc, inc);
 *
 *     plus4(2);
 *     // ==> 6
 *
 * Composition with the `all` convenience still happens from right to left.
 *
 *
 * [es-bind]: https://github.com/zenparsing/es-function-bind
 *
 * ---
 * category  : Combining
 * stability : stable
 * authors:
 *   - Quildreen Motta
 *
 * signature: compose(f, g)(value)
 * type: |
 *   (('b) => 'c, ('a) => 'b) => (('a) => 'c)
 */
var compose = __metamagical_withMeta(function (f, g) {
  return function (value) {
    return f(g(value));
  };
}, {
  "name": "compose",
  "source": "(f, g) => (value) => f(g(value))",
  "signature": "compose(f, g)(value)",
  "location": {
    "filename": "src/core/lambda/compose.js",
    "start": {
      "line": 284,
      "column": 0
    },
    "end": {
      "line": 284,
      "column": 49
    }
  },
  "module": "folktale/src/core/lambda/compose",
  "licence": "MIT",
  "authors": ["Quildreen Motta"],
  "repository": "https://github.com/origamitower/folktale",
  "npmPackage": "folktale",
  "category": "Combining",
  "stability": "stable",
  "type": "(('b) => 'c, ('a) => 'b) => (('a) => 'c)\n",
  "documentation": "\nComposes two functions.\n\n\n## Example:\n\n    const inc       = (x) => x + 1;\n    const double    = (x) => x * 2;\n    const incDouble = compose(double, inc);\n\n    incDouble(3);\n    // ==> 8\n\n\n## Why Composition Matters?\n\nComposition is a way of creating new functionality by combining\nexisting functionality. It helps managing complexity in software\nprojects, since newer functionality can be defined in terms of\nexisting ones, reducing both the amount of code needed to implement\nnewer features, and the amount of time one needs to spend to understand\nthem.\n\nThis technique is used very often in regular JavaScript code, when\nwe feed the results of a function into another function:\n\n    const names = [\n      'Alissa', 'Max', 'Talib'\n    ];\n    const upcase = (name) => name.toUpperCase();\n\n    names.map(upcase).join(', ');\n    // ==> 'ALISSA, MAX, TALIB'\n\nHere `names` is fed into the `map` function, which returns an array\nof the same names in capitals. This new array is then fed into the\n`join` function, which returns a String where the items are separated\nby a comma.\n\nIf we need to use `.map(upcase).join(', ')` in a lot of places, it\nmakes sense to create a new function that captures that composition,\nso we don't have to type it everywhere:\n\n    const showNames = (names) =>\n      names.map(upcase).join(', ');\n\nNow we can use `showNames` instead of `.map(upcase).join(', ')`, and\nwe get the same functionality:\n\n    showNames(names);\n    // ==> 'ALISSA, MAX, TALIB'\n\n\n## The Problem With Methods in JavaScript\n\nJavaScript is a hybrid language, where you can express programs by\nusing object oriented techniques, functional programming techniques,\nand some other paradigms. It's not uncommon to see parts of a program\nexpressed in OOP, as in the examples from the previous section.\n\nHowever, objects in JavaScript can't be safely extended. Ideally, we'd\nlike to write:\n\n    names.show();\n\nInstead of:\n\n    showNames(names);\n\nWhich would be more consistent with the rest of the program. Because\nthis involves mutating the array, all sorts of problems could happen\nso it's better to keep the new functionality as a separate function.\n\nExpressing things in functional programming doesn't have this problem\nbecause functions exist on their own, rather than being part of an\nobject.\n\n\n## Composition in Functional Programming\n\nIn functional programming, functions are the basic building block,\nand we compose functions to create bigger things. To do this, we often\nhave to rephrase the common method calls in terms of regular functions:\n\n    const names = [\n      'Alissa', 'Max', 'Talib'\n    ];\n\n    const upcase = (name) => name.toUpperCase();\n    const map    = (transform, items) => items.map(transform);\n    const join   = (separator, items) => items.join(separator);\n\nWith this we can express the composition in terms of regular function\ncalls:\n\n    const showNames = (names) =>\n      join(', ', map(upcase, names));\n\n    showNames(names);\n    // ==> 'ALISSA, MAX, TALIB'\n\nNow, while the way this program expresses its functions is consistent,\nwe still have to move the whole expression into the function, and\nour code is not as easy to follow as before. Rather than reading from\nleft to right, we have to first read the inside of a function application\nbefore we read what's outside of it.\n\nThese issues are not a problem with simple expressions such as these,\nand most of the expressions in functional programming tend to be very\nsimple. But we can improve this by abstracting over the idea of\ncomposition. That is, instead of requiring syntactic composition, by\nhaving people write out the whole expression, we can ask the program\nto combine these functions for us. This is what the `compose` function\ndoes:\n\n    const showNames2 = compose(\n      capitals => join(', ', capitals),\n      names    => map(upcase, names)\n    );\n\nInstead of reading from inside of a complex expression to the outside,\nnow you can read each expression on its own, and visualise the flow of\ndata linearly.\n\n> **CONVENIENCE**  \n> `compose` does right-to-left composition, so the last function is\n> applied first. You can use the `infix` version of compose to avoid\n> this.\n\n\n## Currying and Composition\n\nComposing unary functions is trivial, as seen on the first example\nof this documentation:\n\n    const inc       = (x) => x + 1;\n    const double    = (x) => x * 2;\n    const incDouble = compose(double, inc);\n\nBut composing functions that take more than one argument doesn't read\nas naturally:\n\n    const upcase = (name) => name.toUpperCase();\n    const map    = (transform, items) => items.map(transform);\n    const join   = (separator, items) => items.join(separator);\n\n    const showNames = compose(\n      capitals => join(', ', capitals),\n      names    => map(upcase, names)\n    );\n\nThe problem is that `compose` can only safely compose unary functions,\nso you have to do some additional work to place the values in the\n\"right places\" when your function takes more than one argument.\n\nOne way to solve this problem is to curry the functions that will be\ncomposed. That is, turn a function of arity N, into N functions of\narity 1:\n\n    const upcase2 = (name) => name.toUpperCase();\n    const map2    = (transform) => (items) => items.map(transform);\n    const join2   = (separator) => (items) => items.join(separator);\n\n    const showNames2 = compose(join2(', '), map2(upcase2));\n\nNote that with a small change to how `map` and `join` are defined, we\ncan make a much better use of the `compose` function. This is not\nwithout its drawbacks, however, as now `join` has to be called as\n`join(',')(names)`.\n\n> **CONVENIECE**  \n> Folktale offers a `curry` function as a convenience for automatically\n> creating curried versions of existing functions, which also works\n> around the 1-argument limitation.\n>\n> See `folktale/core/lambda/curry` for details.\n\nAnother way to work around this problem is by using the `partialise`\nfunction provided by Folktale. This function creates a new function\nthat specifies only parts of the argument for the original function:\n\n    const partialise = require('folktale/core/lambda/partialise');\n    const _          = partialise.hole;\n\n    const upcase3 = (name) => name.toUpperCase();\n    const map3    = partialise(2, (transform, items) => items.map(transform));\n    const join3   = partialise(2, (separator, items) => items.join(separator));\n\n    const showNames3 = compose(\n      join3(', ', _),\n      map3(upcase, _)\n    );\n\nSee `folktale/core/lambda/partialise` for more information on how the\n`partialise` function works.\n\n\n## Composing More Than Two Functions\n\nThe `compose` operation is limited to composing only two functions.\nThis might sound limiting, but it ensures that function composition\nis well-defined.\n\nBecause a lot of functions in JavaScript are expected to be variadic,\nand just ignore the additional parameters, you'd get some very\nsurprising behaviour when trying to pass `compose` to them. For example,\nthe following would throw a type error:\n\n    const inc    = (x) => x + 1;\n    const double = (x) => x * 2;\n    const square = (x) => x * x;\n\n    [inc, double, square].reduce(compose)(3);\n    // ==> throws TypeError: '1 is not a function'\n\nBecause it's equivalent to:\n\n    const fns = [inc, double, square];\n    compose(\n      compose(\n        square,\n        double,\n        1,\n        fns\n      ),\n      inc\n      0,\n      fns\n    )(3);\n\n\nIf you need to compose more than two functions, you can use the\n`infix` syntax, or the `all` convenience function.\n\n\n### Composition With The Infix Syntax\n\nWith the [This-Binding syntax][es-bind] proposed for JavaScript, it's\npossible to compose multiple functions in an, arguably, more natural way:\n\n     const then  = compose.infix;\n     const inc   = (x) => x + 1;\n     const plus4 = inc::then(inc)::then(inc)::then(inc);\n\n     plus4(2);\n     // ==> 6\n\n\n### Composition With The `all` Function\n\nIf you need to compose more than two functions, you might consider using\nthe `all` convenience function instead, which is variadic:\n\n    const inc   = (x) => x + 1;\n    const plus4 = compose.all(inc, inc, inc, inc);\n\n    plus4(2);\n    // ==> 6\n\nComposition with the `all` convenience still happens from right to left.\n\n\n[es-bind]: https://github.com/zenparsing/es-function-bind\n",
  "examples": [{
    "name": "",
    "call": __metamagical_withMeta(function () {}, {
      "source": ""
    }),
    "inferred": true
  }, {
    "name": "Example::",
    "call": __metamagical_withMeta(function () {
      var inc = function inc(x) {
        return x + 1;
      };var double = function double(x) {
        return x * 2;
      };var incDouble = compose(double, inc);__metamagical_assert_equals(require("assert"), incDouble(3), 8, "incDouble(3) ==> 8");; // ==> 8
    }, {
      "source": "const inc       = (x) => x + 1;\nconst double    = (x) => x * 2;\nconst incDouble = compose(double, inc);\n\nincDouble(3);\n// ==> 8"
    }),
    "inferred": true
  }, {
    "name": "Why Composition Matters?",
    "call": __metamagical_withMeta(function () {
      var names = ['Alissa', 'Max', 'Talib'];var upcase = function upcase(name) {
        return name.toUpperCase();
      };__metamagical_assert_equals(require("assert"), names.map(upcase).join(', '), 'ALISSA, MAX, TALIB', "names.map(upcase).join(', ') ==> 'ALISSA, MAX, TALIB'");; // ==> 'ALISSA, MAX, TALIB'
      var showNames = function showNames(names) {
        return names.map(upcase).join(', ');
      };__metamagical_assert_equals(require("assert"), showNames(names), 'ALISSA, MAX, TALIB', "showNames(names) ==> 'ALISSA, MAX, TALIB'");; // ==> 'ALISSA, MAX, TALIB'
    }, {
      "source": "const names = [\n  'Alissa', 'Max', 'Talib'\n];\nconst upcase = (name) => name.toUpperCase();\n\nnames.map(upcase).join(', ');\n// ==> 'ALISSA, MAX, TALIB'\n\nconst showNames = (names) =>\n  names.map(upcase).join(', ');\n\nshowNames(names);\n// ==> 'ALISSA, MAX, TALIB'"
    }),
    "inferred": true
  }, {
    "name": "The Problem With Methods in JavaScript",
    "call": __metamagical_withMeta(function () {}, {
      "source": ""
    }),
    "inferred": true
  }, {
    "name": "Composition in Functional Programming",
    "call": __metamagical_withMeta(function () {
      var names = ['Alissa', 'Max', 'Talib'];var upcase = function upcase(name) {
        return name.toUpperCase();
      };var map = function map(transform, items) {
        return items.map(transform);
      };var join = function join(separator, items) {
        return items.join(separator);
      };var showNames = function showNames(names) {
        return join(', ', map(upcase, names));
      };__metamagical_assert_equals(require("assert"), showNames(names), 'ALISSA, MAX, TALIB', "showNames(names) ==> 'ALISSA, MAX, TALIB'");; // ==> 'ALISSA, MAX, TALIB'
      var showNames2 = compose(function (capitals) {
        return join(', ', capitals);
      }, function (names) {
        return map(upcase, names);
      });
    }, {
      "source": "const names = [\n  'Alissa', 'Max', 'Talib'\n];\n\nconst upcase = (name) => name.toUpperCase();\nconst map    = (transform, items) => items.map(transform);\nconst join   = (separator, items) => items.join(separator);\n\nconst showNames = (names) =>\n  join(', ', map(upcase, names));\n\nshowNames(names);\n// ==> 'ALISSA, MAX, TALIB'\n\nconst showNames2 = compose(\n  capitals => join(', ', capitals),\n  names    => map(upcase, names)\n);"
    }),
    "inferred": true
  }, {
    "name": "Currying and Composition",
    "call": __metamagical_withMeta(function () {
      var inc = function inc(x) {
        return x + 1;
      };var double = function double(x) {
        return x * 2;
      };var incDouble = compose(double, inc);var upcase = function upcase(name) {
        return name.toUpperCase();
      };var map = function map(transform, items) {
        return items.map(transform);
      };var join = function join(separator, items) {
        return items.join(separator);
      };var showNames = compose(function (capitals) {
        return join(', ', capitals);
      }, function (names) {
        return map(upcase, names);
      });var upcase2 = function upcase2(name) {
        return name.toUpperCase();
      };var map2 = function map2(transform) {
        return function (items) {
          return items.map(transform);
        };
      };var join2 = function join2(separator) {
        return function (items) {
          return items.join(separator);
        };
      };var showNames2 = compose(join2(', '), map2(upcase2));var partialise = require("./partialise");var _ = partialise.hole;var upcase3 = function upcase3(name) {
        return name.toUpperCase();
      };var map3 = partialise(2, function (transform, items) {
        return items.map(transform);
      });var join3 = partialise(2, function (separator, items) {
        return items.join(separator);
      });var showNames3 = compose(join3(', ', _), map3(upcase, _));
    }, {
      "source": "const inc       = (x) => x + 1;\nconst double    = (x) => x * 2;\nconst incDouble = compose(double, inc);\n\nconst upcase = (name) => name.toUpperCase();\nconst map    = (transform, items) => items.map(transform);\nconst join   = (separator, items) => items.join(separator);\n\nconst showNames = compose(\n  capitals => join(', ', capitals),\n  names    => map(upcase, names)\n);\n\nconst upcase2 = (name) => name.toUpperCase();\nconst map2    = (transform) => (items) => items.map(transform);\nconst join2   = (separator) => (items) => items.join(separator);\n\nconst showNames2 = compose(join2(', '), map2(upcase2));\n\nconst partialise = require('folktale/core/lambda/partialise');\nconst _          = partialise.hole;\n\nconst upcase3 = (name) => name.toUpperCase();\nconst map3    = partialise(2, (transform, items) => items.map(transform));\nconst join3   = partialise(2, (separator, items) => items.join(separator));\n\nconst showNames3 = compose(\n  join3(', ', _),\n  map3(upcase, _)\n);"
    }),
    "inferred": true
  }, {
    "name": "Composing More Than Two Functions",
    "call": __metamagical_withMeta(function () {}, {
      "source": ""
    }),
    "inferred": true
  }, {
    "name": "Composition With The Infix Syntax",
    "call": __metamagical_withMeta(function () {
      var _context;

      var then = compose.infix;var inc = function inc(x) {
        return x + 1;
      };var plus4 = (_context = (_context = then.call(inc, inc), then).call(_context, inc), then).call(_context, inc);__metamagical_assert_equals(require("assert"), plus4(2), 6, "plus4(2) ==> 6");; // ==> 6
    }, {
      "source": " const then  = compose.infix;\n const inc   = (x) => x + 1;\n const plus4 = inc::then(inc)::then(inc)::then(inc);\n\n plus4(2);\n // ==> 6"
    }),
    "inferred": true
  }, {
    "name": "Composition With The `all` Function",
    "call": __metamagical_withMeta(function () {
      var inc = function inc(x) {
        return x + 1;
      };var plus4 = compose.all(inc, inc, inc, inc);__metamagical_assert_equals(require("assert"), plus4(2), 6, "plus4(2) ==> 6");; // ==> 6
    }, {
      "source": "const inc   = (x) => x + 1;\nconst plus4 = compose.all(inc, inc, inc, inc);\n\nplus4(2);\n// ==> 6"
    }),
    "inferred": true
  }]
});

// --[ Convenience ]---------------------------------------------------

/*~
 * Conveniently composes function with the This-Binding syntax.
 *
 * This is a free-method version of `compose` that applies the `this`
 * argument first, then the function it takes as argument. It's meant
 * to be used with the [This-Binding Syntax][es-bind] proposal.
 *
 *     const then   = compose.infix;
 *     const inc    = (x) => x + 1;
 *     const double = (x) => x * 2;
 *
 *     inc::then(double)(2);  // ==> 6
 *
 *
 * [es-bind]: https://github.com/zenparsing/es-function-bind
 *
 * ---
 * category  : Convenience
 * stability : experimental
 * authors:
 *   - Quildreen Motta
 *
 * type: |
 *   (('b) => 'c) . (('a) => 'b) => (('a) => 'c)
 */
compose.infix = __metamagical_withMeta(function (that) {
  return compose(that, this);
}, {
  "name": "infix",
  "source": "function(that) {\n  return compose(that, this);\n}",
  "signature": "infix(that)",
  "belongsTo": function belongsTo() {
    return compose;
  },
  "category": "Convenience",
  "stability": "experimental",
  "authors": ["Quildreen Motta"],
  "type": "(('b) => 'c) . (('a) => 'b) => (('a) => 'c)\n",
  "documentation": "\nConveniently composes function with the This-Binding syntax.\n\nThis is a free-method version of `compose` that applies the `this`\nargument first, then the function it takes as argument. It's meant\nto be used with the [This-Binding Syntax][es-bind] proposal.\n\n    const then   = compose.infix;\n    const inc    = (x) => x + 1;\n    const double = (x) => x * 2;\n\n    inc::then(double)(2);  // ==> 6\n\n\n[es-bind]: https://github.com/zenparsing/es-function-bind\n"
});

/*~
 * Conveniently composes multiple functions.
 *
 * Because `compose` is limited to two functions, composing more than that
 * is awkward::
 *
 *     const inc    = (x) => x + 1;
 *     const double = (x) => x * 2;
 *     const square = (x) => x * x;
 *
 *     const incDoubleSquare = compose(inc, compose(double, square));
 *     incDoubleSquare(3);
 *     // ==> 19
 *
 * In these cases one may use `compose.all`, which is a variadic convenience
 * for composing multiple functions::
 *
 *     const incDoubleSquare2 = compose.all(inc, double, square);
 *     incDoubleSquare2(3);
 *     // ==> 19
 *
 * ---
 * category  : Convenience
 * stability : experimental
 * authors:
 *   - Quildreen Motta
 * 
 * type: |
 *   (Function...) -> Function 
 */
compose.all = __metamagical_withMeta(function () {
  for (var _len = arguments.length, fns = Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }

  if (fns.length < 1) {
    // eslint-disable-next-line prefer-rest-params
    throw new TypeError("compose.all requires at least one argument, " + arguments.length + " given.");
  }
  return fns.reduce(compose);
}, {
  "name": "all",
  "source": "function(...fns) {\n  if (fns.length < 1) { // eslint-disable-next-line prefer-rest-params\n    throw new TypeError(`compose.all requires at least one argument, ${arguments.length} given.`);\n  }\n  return fns.reduce(compose);\n}",
  "signature": "all(...fns)",
  "belongsTo": function belongsTo() {
    return compose;
  },
  "category": "Convenience",
  "stability": "experimental",
  "authors": ["Quildreen Motta"],
  "type": "(Function...) -> Function \n",
  "documentation": "\nConveniently composes multiple functions.\n\nBecause `compose` is limited to two functions, composing more than that\nis awkward:\n\n    const inc    = (x) => x + 1;\n    const double = (x) => x * 2;\n    const square = (x) => x * x;\n\n    const incDoubleSquare = compose(inc, compose(double, square));\n    incDoubleSquare(3);\n    // ==> 19\n\nIn these cases one may use `compose.all`, which is a variadic convenience\nfor composing multiple functions:\n\n    const incDoubleSquare2 = compose.all(inc, double, square);\n    incDoubleSquare2(3);\n    // ==> 19\n",
  "examples": [{
    "name": "",
    "call": __metamagical_withMeta(function () {
      var inc = function inc(x) {
        return x + 1;
      };var double = function double(x) {
        return x * 2;
      };var square = function square(x) {
        return x * x;
      };var incDoubleSquare = compose(inc, compose(double, square));__metamagical_assert_equals(require("assert"), incDoubleSquare(3), 19, "incDoubleSquare(3) ==> 19");; // ==> 19
      ;var incDoubleSquare2 = compose.all(inc, double, square);__metamagical_assert_equals(require("assert"), incDoubleSquare2(3), 19, "incDoubleSquare2(3) ==> 19");; // ==> 19
    }, {
      "source": "const inc    = (x) => x + 1;\nconst double = (x) => x * 2;\nconst square = (x) => x * x;\n\nconst incDoubleSquare = compose(inc, compose(double, square));\nincDoubleSquare(3);\n// ==> 19\n;\nconst incDoubleSquare2 = compose.all(inc, double, square);\nincDoubleSquare2(3);\n// ==> 19"
    }),
    "inferred": true
  }]
});

// --[ Exports ]-------------------------------------------------------
module.exports = compose;
},{"./partialise":23,"assert":54}],19:[function(require,module,exports){
"use strict";

var __metamagical_withMeta = function metamagical_withMeta(object, meta) {
  var parent = Object.getPrototypeOf(object);var oldMeta = object[Symbol.for('@@meta:magical')] || {};if (parent && parent[Symbol.for('@@meta:magical')] === oldMeta) {
    oldMeta = {};
  }Object.keys(meta).forEach(function (key) {
    if (/^~/.test(key)) {
      oldMeta[key.slice(1)] = meta[key];
    } else {
      oldMeta[key] = meta[key];
    }
  });object[Symbol.for('@@meta:magical')] = oldMeta;return object;
},
    __metamagical_assert_equals = function metamagical_assert_equals(assert, actual, expected, message) {
  var assertionType = Symbol.for('@@meta:magical:assertion-type');var rest = Symbol.for('@@meta:magical:assertion-rest');var keys = Object.keys;function isSetoid(value) {
    return value && typeof value.equals === 'function';
  }function isRecord(value) {
    return value && value[assertionType] === 'record';
  }function check(predicate) {
    for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }return values.every(predicate);
  }function getSpecialArrayLength(array) {
    var rests = array.map(function (x, i) {
      return [x, i];
    }).filter(function (pair) {
      return pair[0] === rest;
    });if (rests.length > 1 || rests[0] && rests[0][1] !== array.length - 1) {
      assert.ok(false, message + '. Assertions only support a single trailing rest indication for arrays currently.');
    }return (rests[0] || [null, array.length])[1];
  }function compareArrays(left, right) {
    var expectedLength = getSpecialArrayLength(right);assert.ok(Array.isArray(left), message + '. The LHS is not an array.');if (left.length < expectedLength) {
      assert.ok(false, message + '. The LHS does not have the minimum expected length (' + left.length + ' < ' + expectedLength + ')');
    }for (var i = 0; i < expectedLength; ++i) {
      compare(left[i], right[i]);
    }
  }function compareRecord(left, right) {
    var isPartial = right[rest];assert.ok(Object(left) === left, message);if (!isPartial) {
      assert.deepStrictEqual(keys(left).sort(), keys(right).sort(), message + '. The objects have different keys ([' + keys(left).sort().join(', ') + '] vs. [' + keys(right).sort().join(', ') + '])');
    }Object.keys(right).forEach(function (key) {
      if (!(key in left)) {
        assert.ok(false, message + '. The expected key ' + key + ' is not present in the actual object.');
      }compare(left[key], right[key]);
    });
  }function compare(l, r) {
    return check(isSetoid, l, r) ? assert.ok(l.equals(r), message + '. The LHS (' + l + ') setoid instance says the LHS and RHS (' + r + ') are not equal.') : Array.isArray(r) ? compareArrays(l, r) : isRecord(r) ? compareRecord(l, r) : /* otherwise */assert.deepStrictEqual(l, r, message + '. The LHS (' + l + ') and the RHS (' + r + ') are not structually equal.');
  }compare(actual, expected);
};

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

/*~
 * The constant combinator; always returns the first argument given.
 *
 *
 * ## Example::
 *
 *     [1, 2, 3].map(constant(0));
 *     // ==> [0, 0, 0]
 *
 *
 * ## Why?
 *
 * Constant combinators can be passed to higher-order operations if you
 * want to provide a plain value, but the operation expects a function
 * providing a value::
 *
 *     [1, 2, 3].map(constant(0));
 *     // ==> [0, 0, 0]
 *
 * For a primitive, there's usually not much of a difference between
 * using the `constant` combinator or an arrow function. In fact, for
 * most cases, using the arrow function is preferred::
 *
 *     [1, 2, 3].map(() => 0);
 *     // ==> [0, 0, 0]
 *
 * The problem with using arrows is that the value is computed lazily.
 * That is, it's computed only when the arrow is evaluated, and recomputed
 * many times if the arrow is evaluated many times. The `constant` combinator
 * lets you evaluate something eagerly instead.
 *
 * You can see the importance of this when effects are involved::
 *
 *     let counter = 0;
 *     const next = () => ++counter;
 *
 *     ['a', 'b', 'c'].map(constant(next()));
 *     // ==> [1, 1, 1]
 *
 *     counter = 0;
 *     ['a', 'b', 'c'].map(_ => next());
 *     // ==> [1, 2, 3]
 *
 * Expensive pure computations are another place where `constant` is desirable
 * over plain arrows, given that one'd rather avoid re-evaluating the
 * computation unnecessarily.
 *
 *
 * ---
 * category  : Combinators
 * stability : stable
 *
 * authors:
 *   - Quildreen Motta
 *
 * type: |
 *   ('a) => ('b) => 'a
 */
var constant = __metamagical_withMeta(function (value) {
  return function (_) {
    return value;
  };
}, {
  "name": "constant",
  "source": "(value) => (_) => value",
  "signature": "constant(value)",
  "location": {
    "filename": "src/core/lambda/constant.js",
    "start": {
      "line": 68,
      "column": 0
    },
    "end": {
      "line": 68,
      "column": 41
    }
  },
  "module": "folktale/src/core/lambda/constant",
  "licence": "MIT",
  "authors": ["Quildreen Motta"],
  "repository": "https://github.com/origamitower/folktale",
  "npmPackage": "folktale",
  "category": "Combinators",
  "stability": "stable",
  "type": "('a) => ('b) => 'a\n",
  "documentation": "\nThe constant combinator; always returns the first argument given.\n\n\n## Example:\n\n    [1, 2, 3].map(constant(0));\n    // ==> [0, 0, 0]\n\n\n## Why?\n\nConstant combinators can be passed to higher-order operations if you\nwant to provide a plain value, but the operation expects a function\nproviding a value:\n\n    [1, 2, 3].map(constant(0));\n    // ==> [0, 0, 0]\n\nFor a primitive, there's usually not much of a difference between\nusing the `constant` combinator or an arrow function. In fact, for\nmost cases, using the arrow function is preferred:\n\n    [1, 2, 3].map(() => 0);\n    // ==> [0, 0, 0]\n\nThe problem with using arrows is that the value is computed lazily.\nThat is, it's computed only when the arrow is evaluated, and recomputed\nmany times if the arrow is evaluated many times. The `constant` combinator\nlets you evaluate something eagerly instead.\n\nYou can see the importance of this when effects are involved:\n\n    let counter = 0;\n    const next = () => ++counter;\n\n    ['a', 'b', 'c'].map(constant(next()));\n    // ==> [1, 1, 1]\n\n    counter = 0;\n    ['a', 'b', 'c'].map(_ => next());\n    // ==> [1, 2, 3]\n\nExpensive pure computations are another place where `constant` is desirable\nover plain arrows, given that one'd rather avoid re-evaluating the\ncomputation unnecessarily.\n\n",
  "examples": [{
    "name": "",
    "call": __metamagical_withMeta(function () {}, {
      "source": ""
    }),
    "inferred": true
  }, {
    "name": "Example::",
    "call": __metamagical_withMeta(function () {
      __metamagical_assert_equals(require("assert"), [1, 2, 3].map(constant(0)), [0, 0, 0], "[1, 2, 3].map(constant(0)) ==> [0, 0, 0]");; // ==> [0, 0, 0]
    }, {
      "source": "[1, 2, 3].map(constant(0));\n// ==> [0, 0, 0]"
    }),
    "inferred": true
  }, {
    "name": "Why?",
    "call": __metamagical_withMeta(function () {
      __metamagical_assert_equals(require("assert"), [1, 2, 3].map(constant(0)), [0, 0, 0], "[1, 2, 3].map(constant(0)) ==> [0, 0, 0]");;;__metamagical_assert_equals(require("assert"), [1, 2, 3].map(function () {
        return 0;
      }), [0, 0, 0], "[1, 2, 3].map(() => 0) ==> [0, 0, 0]");; // ==> [0, 0, 0]
      ;var counter = 0;var next = function next() {
        return ++counter;
      };__metamagical_assert_equals(require("assert"), ['a', 'b', 'c'].map(constant(next())), [1, 1, 1], "['a', 'b', 'c'].map(constant(next())) ==> [1, 1, 1]");; // ==> [1, 1, 1]
      counter = 0;__metamagical_assert_equals(require("assert"), ['a', 'b', 'c'].map(function (_) {
        return next();
      }), [1, 2, 3], "['a', 'b', 'c'].map(_ => next()) ==> [1, 2, 3]");; // ==> [1, 2, 3]
    }, {
      "source": "[1, 2, 3].map(constant(0));\n// ==> [0, 0, 0]\n;\n[1, 2, 3].map(() => 0);\n// ==> [0, 0, 0]\n;\nlet counter = 0;\nconst next = () => ++counter;\n\n['a', 'b', 'c'].map(constant(next()));\n// ==> [1, 1, 1]\n\ncounter = 0;\n['a', 'b', 'c'].map(_ => next());\n// ==> [1, 2, 3]"
    }),
    "inferred": true
  }]
});

// --[ Exports ]-------------------------------------------------------
module.exports = constant;
},{"assert":54}],20:[function(require,module,exports){
"use strict";

var __metamagical_withMeta = function metamagical_withMeta(object, meta) {
  var parent = Object.getPrototypeOf(object);var oldMeta = object[Symbol.for('@@meta:magical')] || {};if (parent && parent[Symbol.for('@@meta:magical')] === oldMeta) {
    oldMeta = {};
  }Object.keys(meta).forEach(function (key) {
    if (/^~/.test(key)) {
      oldMeta[key.slice(1)] = meta[key];
    } else {
      oldMeta[key] = meta[key];
    }
  });object[Symbol.for('@@meta:magical')] = oldMeta;return object;
},
    __metamagical_assert_equals = function metamagical_assert_equals(assert, actual, expected, message) {
  var assertionType = Symbol.for('@@meta:magical:assertion-type');var rest = Symbol.for('@@meta:magical:assertion-rest');var keys = Object.keys;function isSetoid(value) {
    return value && typeof value.equals === 'function';
  }function isRecord(value) {
    return value && value[assertionType] === 'record';
  }function check(predicate) {
    for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }return values.every(predicate);
  }function getSpecialArrayLength(array) {
    var rests = array.map(function (x, i) {
      return [x, i];
    }).filter(function (pair) {
      return pair[0] === rest;
    });if (rests.length > 1 || rests[0] && rests[0][1] !== array.length - 1) {
      assert.ok(false, message + '. Assertions only support a single trailing rest indication for arrays currently.');
    }return (rests[0] || [null, array.length])[1];
  }function compareArrays(left, right) {
    var expectedLength = getSpecialArrayLength(right);assert.ok(Array.isArray(left), message + '. The LHS is not an array.');if (left.length < expectedLength) {
      assert.ok(false, message + '. The LHS does not have the minimum expected length (' + left.length + ' < ' + expectedLength + ')');
    }for (var i = 0; i < expectedLength; ++i) {
      compare(left[i], right[i]);
    }
  }function compareRecord(left, right) {
    var isPartial = right[rest];assert.ok(Object(left) === left, message);if (!isPartial) {
      assert.deepStrictEqual(keys(left).sort(), keys(right).sort(), message + '. The objects have different keys ([' + keys(left).sort().join(', ') + '] vs. [' + keys(right).sort().join(', ') + '])');
    }Object.keys(right).forEach(function (key) {
      if (!(key in left)) {
        assert.ok(false, message + '. The expected key ' + key + ' is not present in the actual object.');
      }compare(left[key], right[key]);
    });
  }function compare(l, r) {
    return check(isSetoid, l, r) ? assert.ok(l.equals(r), message + '. The LHS (' + l + ') setoid instance says the LHS and RHS (' + r + ') are not equal.') : Array.isArray(r) ? compareArrays(l, r) : isRecord(r) ? compareRecord(l, r) : /* otherwise */assert.deepStrictEqual(l, r, message + '. The LHS (' + l + ') and the RHS (' + r + ') are not structually equal.');
  }compare(actual, expected);
};

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

/*~
 * Transforms functions of arity N into a chain of N unary functions
 * 
 * 
 * ## Example::
 * 
 *     const property = curry(2, (key, object) => object[key]);
 *     const people = [
 *       { name: 'Alissa', age: 26 },
 *       { name: 'Max',    age: 19 },
 *       { name: 'Talib',  age: 28 }
 *     ];
 * 
 *     people.map(property('name'));
 *     // ==> ['Alissa', 'Max', 'Talib']
 *
 *
 * 
 * ## What is "Currying"?
 * 
 * Currying is the process of transforming a function that takes N arguments
 * all at once, into a series of functions that take one argument at a time.
 * This makes it possible to construct new funcionality by specialising part
 * of the arguments.
 * 
 * For example, the `property` function takes two arguments: the object that
 * contains the property, and the name of the property to retrieve::
 * 
 *     const property = (object, key) => object[key];
 * 
 * Because of this, every time someone call `property` they must provide both
 * arguments::
 * 
 *     property({ greeting: 'Hi' }, 'greeting');
 *     // ==> 'Hi'
 * 
 * Some of the time, you only have some of the arguments, however. For example,
 * if you wanted to create a function that always gets the `greeting` of a
 * particular object, you would have to do so manually::
 * 
 *     const greeting = (object) => property(object, 'greeting');
 * 
 *     greeting({ greeting: 'Hi' });
 *     // ==> 'Hi'
 * 
 * Currying alleviates the need for constructing these functions manually. If
 * `property` was curried, you'd be able to create a new `greeting` function
 * by just specifying some of the arguments, like you would do when invoking
 * the function::
 * 
 *     const property2 = (key) => (object) => object[key];
 *     const greeting2 = property2('greeting');
 * 
 *     greeting({ greeting: 'Hi' });
 * 
 * Note that the way we use arguments in a curried function is slightly
 * different. When designing a function to be curried, you should consider
 * which parameters are most likely to be fixed, and which parameters will
 * be provided afterwards. In this case, it's much more likely for someone
 * to have the name of a property than it is for them to have the object
 * in which that property lives::
 * 
 *     const score = [{ type: 'win' }, { type: 'draw' }];
 *     score.map(property2('type'));
 *     // ==> ['win', 'draw']
 * 
 * 
 * ## Why Use Currying?
 * 
 * Functional programming places a heavy emphasis on function composition,
 * but sometimes we have functions that don't exactly fit the places we
 * want to use them. For example, `Array.prototype.map` expects a function
 * that takes three arguments:
 * 
 *     type Array.prototype.map =
 *       Array<'element> . (
 *         ('element, index is Number, Array<'element>) => 'newElement
 *       ) => Array<'newElement>
 * 
 * That is, given an array of of some `element` type, our callback, which
 * receives not only this `element`, but also the index of that element in
 * the array, and even the original array, is supposed to return a `newElement`
 * to put in the old element's place.
 * 
 * We can use `Array.prototype.map` to easily transform the data in the
 * array by some function. To expand a bit on the initial example, suppose
 * we have an array of people::
 * 
 *     const people = [
 *       { name: 'Alissa', age: 26, pronoun: 'she'  },
 *       { name: 'Max',    age: 19, pronoun: 'they' },
 *       { name: 'Talib',  age: 28, pronoun: 'he'   }
 *     ];
 * 
 * And then you want to get the name of one of those people. We can use
 * `Array.prototype.map` for this::
 * 
 *     people.map((element, index, array) => element.name);
 *     // ==> ['Alissa', 'Max', 'Talib']
 * 
 * 
 * > **NOTE**  
 * > Because functions in JavaScript are variadic, you don't need to
 * > create a function with three parameters here. The following code
 * > is strictly equivalent::
 * >
 * >     people.map(person => person.name);
 * >     // ==> ['Alissa', 'Max', 'Talib']
 * 
 * 
 * This is all well and good, because this is the only place where we use
 * this kind of functionality. But what if we have very similar functionality
 * in more places. For example, just like we got the names of these people,
 * we could get their ages::
 * 
 *     people.map(person => person.age);
 *     // ==> [26, 19, 28]
 * 
 * Or the pronoun they use::
 * 
 *     people.map(person => person.pronoun);
 *     // ==> ['she', 'they', 'he']
 * 
 * At this point, we're duplicating this functionality in many places. It
 * would be more productive to move it to a function we can reuse. And this
 * is easy enough:
 * 
 *     const property = (object, key) => object[key];
 * 
 * But this attempt is not really a good one in this case. Now composing
 * things is even more trouble:
 * 
 *     people.map(person => property(person, 'name'));
 * 
 * Ideally, we'd want:
 * 
 *     people.map(property);
 * 
 * But `property` takes two arguments, and `Array.prototype.map` can only
 * provide one of them: the object we should retrieve the property from.
 * Where do we get the other one from? Well, the name of the property is
 * static. We know exactly what we need from the callsite.
 * 
 * As said in the previous section, thinking about which arguments are likely
 * to be specified, and what aren't is important when designing curried
 * functions. For this case, we want to specialise the `key`, and leave
 * `object` to be provided by some other piece of code::
 * 
 *      const property = (key) => (object) => object[key];
 * 
 *      people.map(property('name'));
 *      // ==> ['Alissa', 'Max', 'Talib']
 * 
 *      people.map(property('age'));
 *      // ==> [26, 19, 28]
 * 
 *      people.map(property('pronoun'));
 *      // ==> ['she', 'they', 'he'] 
 * 
 * So, with currying, it becomes much simpler to shape a function so it
 * fits the expectations of the place where you want to use it. It alleviates
 * the need of making this translation manually, but it also requires some
 * prior thought on how these functions are likely to be used.
 * 
 * 
 * ## How Folktale's `curry` Works?
 * 
 * The `curry` operation makes it simpler to construct curried functions
 * that work well with JavaScript, where functions may, and often do, take
 * more than one argument.
 * 
 * Consider the following example::
 * 
 *     const joinedBy = (separator) => (list) => (item) =>
 *       list.concat([separator, item]);
 * 
 * It's a curried function that takes 3 arguments, one at a time. To invoke
 * it one must do so like this::
 * 
 *     joinedBy(',')(['a'])('b');
 *     // ==> ['a', ',', 'b']
 * 
 * This makes it harder to use it for functions that pass two arguments to
 * their callbacks, like `Array.prototype.reduce`, because JavaScript passes
 * them all at once:
 * 
 *     ['b'].reduce(joinedBy(','), ['a']);
 *     // ==> [<function>, <function>]
 * 
 * This is where `curry` helps. It allows you to curry functions, while
 * unrolling application of more than one argument::
 * 
 *     const joinedBy2 = curry(3, (separator, list, item) =>
 *       list.concat([separator, item]) 
 *     );
 * 
 *     joinedBy2(',', ['a'], 'b');
 *     // ==> ['a', ',', 'b']
 * 
 *     ['b'].reduce(joinedBy2(','), ['a']);
 *     // ==> ['a', ',', 'b']
 * 
 * 
 * ## `curry`, Under The Hood
 * 
 * How can `curry` construct functions that support such different styles
 * of passing arguments? The secret is in how `curry` does unrolling. A
 * function constructed by `curry` takes two arguments:
 * 
 *  1) The number of arguments that are expected for that function (arity);
 *  2) The function that should be called when those arguments are collected.
 * 
 * In return, `curry` gives you back a function that, at first, only collects
 * arguments. That is, until we reach the amount of arguments expected (arity),
 * applying the `curry`ed function gives you back a new function that you
 * continue to apply::
 * 
 *     const f = curry(4, (a, b, c, d) => [a, b, c, d]);
 * 
 *     // Previous arguments: []
 *     const f1 = f();
 *     // New arguments:      []
 * 
 *     // Previous arguments: []
 *     const f2 = f1(1);
 *     // New arguments:      [1]
 * 
 *     // Previous arguments: [1]
 *     const f3 = f2(2, 3);
 *     // New arguments:      [1, 2, 3]
 * 
 *     // Previous arguments: [1, 2, 3]
 *     f3(4);
 *     // ==> [1, 2, 3, 4]
 *     
 * The curried function keeps track of these arguments in an internal array.
 * This array is not modified when you apply a curried function. Instead, you
 * get a new function with a separate "internal arguments array"::
 * 
 *     // Previous arguments: [1]
 *     const f2_a = f2(4);  // => [1, 4]
 *     const f2_b = f2(5);  // => [1, 5]
 * 
 *     f2_a(5, 6); // ==> [1, 4, 5, 6]
 *     f2_b(5, 6); // ==> [1, 5, 5, 6]
 * 
 * Once the curried function has collected all of the arguments it needs to,
 * it "unrolls" the application. That is, it provides the arguments collected
 * to the original function::
 * 
 *     const plus  = (a, b, c) => a + b + c;
 *     const plus2 = curry(3, plus);
 * 
 *         plus2(1)(2)(3)
 *     === plus2(1, 2)(3)
 *     === plus2(1, 2, 3)
 *     === plus(1, 2, 3)
 *     === 1 + 2 + 3;
 *     
 * What happens if a curried function receives more arguments than it expects,
 * though? If the wrapped function is a regular JavaScript function, it's the
 * same. `curry` passes all of the arguments to it, and because JavaScript
 * functions are variadic, those additional arguments get (usually) ignored::
 * 
 *         plus2(1)(2)(3, 4, 5)
 *     === plus2(1, 2)(3, 4, 5)
 *     === plus2(1, 2, 3, 4, 5)
 *     === plus(1, 2, 3, 4, 5)
 *     === 1 + 2 + 3;
 * 
 * If the wrapped function is itself a curried function, things get more
 * interesting though, because the curried functio will, itself, unroll
 * the rest of the application!
 * ::
 * 
 *     const subtract = curry(2, (x, y) => x - y);
 *     const flip     = curry(3, (f, x, y) => f(y, x));
 * 
 *         subtract(1)(2)
 *     === subtract(1, 2)
 *     === 1 - 2;
 * 
 *         flip(subtract)(1)(2)
 *     === flip(subtract, 1)(2)
 *     === flip(subtract, 1, 2)
 *     === subtract(2, 1)
 *     === 2 - 1;
 * 
 * Unrolling makes it possible to compose curried functions naturally, without
 * getting in the way of regular JavaScript functions.
 * 
 * > **NOTE**  
 * > Using `curry` for real variadic functions is strongly discouraged, given
 * > that it's hard to predict which arguments will end up being provided to
 * > the variadic function.
 * 
 * 
 * ## Drawbacks of Using `curry`
 * 
 * While `curry` certainly helps composing functions, it's important to note
 * that, because a lot of functions in JavaScript are variadic, and because
 * people take advantage of this (by relying on the number of arguments
 * provided for optional parameters or overloading the signature),
 * composition of such functions is not well-defined, and `curry` makes
 * things even less predictable for these cases.
 * 
 * Because of this, the use of `curry` for variadic functions is strongly
 * discouraged.
 * 
 * One also must consider the overhead of introducing `curry` in a codebase.
 * For most code, this overhead is negligible, but `curry` should be avoided
 * in code paths that require more performance.
 * 
 * 
 * ---
 * category  : Currying and Partialisation
 * stability : experimental
 *
 * authors:
 *   - Quildreen Motta
 *
 * seeAlso:
 *   - type: link
 *     title: Does Curry Help?
 *     url: https://hughfdjackson.com/javascript/does-curry-help/
 *
 * type: |
 *   (Number, (Any...) => 'a) => Any... => 'a or ((Any...) => 'a)
 */
var curry = __metamagical_withMeta(function (arity, fn) {
  var curried = function curried(oldArgs) {
    return function () {
      for (var _len = arguments.length, newArgs = Array(_len), _key = 0; _key < _len; _key++) {
        newArgs[_key] = arguments[_key];
      }

      var allArgs = oldArgs.concat(newArgs);
      var argCount = allArgs.length;

      return argCount < arity ? curried(allArgs) : /* otherwise */fn.apply(undefined, _toConsumableArray(allArgs));
    };
  };

  return curried([]);
}, {
  "name": "curry",
  "source": "(arity, fn) => {\n  const curried = (oldArgs) => (...newArgs) => {\n    const allArgs  = oldArgs.concat(newArgs);\n    const argCount = allArgs.length;\n\n    return argCount < arity   ?  curried(allArgs)\n    :      /* otherwise */       fn(...allArgs);\n  };\n\n  return curried([]);\n}",
  "signature": "curry(arity, fn)",
  "location": {
    "filename": "src/core/lambda/curry.js",
    "start": {
      "line": 339,
      "column": 0
    },
    "end": {
      "line": 349,
      "column": 2
    }
  },
  "module": "folktale/src/core/lambda/curry",
  "licence": "MIT",
  "authors": ["Quildreen Motta"],
  "repository": "https://github.com/origamitower/folktale",
  "npmPackage": "folktale",
  "category": "Currying and Partialisation",
  "stability": "experimental",
  "seeAlso": [{
    "type": "link",
    "title": "Does Curry Help?",
    "url": "https://hughfdjackson.com/javascript/does-curry-help/"
  }],
  "type": "(Number, (Any...) => 'a) => Any... => 'a or ((Any...) => 'a)\n",
  "documentation": "\nTransforms functions of arity N into a chain of N unary functions\n\n\n## Example:\n\n    const property = curry(2, (key, object) => object[key]);\n    const people = [\n      { name: 'Alissa', age: 26 },\n      { name: 'Max',    age: 19 },\n      { name: 'Talib',  age: 28 }\n    ];\n\n    people.map(property('name'));\n    // ==> ['Alissa', 'Max', 'Talib']\n\n\n\n## What is \"Currying\"?\n\nCurrying is the process of transforming a function that takes N arguments\nall at once, into a series of functions that take one argument at a time.\nThis makes it possible to construct new funcionality by specialising part\nof the arguments.\n\nFor example, the `property` function takes two arguments: the object that\ncontains the property, and the name of the property to retrieve:\n\n    const property = (object, key) => object[key];\n\nBecause of this, every time someone call `property` they must provide both\narguments:\n\n    property({ greeting: 'Hi' }, 'greeting');\n    // ==> 'Hi'\n\nSome of the time, you only have some of the arguments, however. For example,\nif you wanted to create a function that always gets the `greeting` of a\nparticular object, you would have to do so manually:\n\n    const greeting = (object) => property(object, 'greeting');\n\n    greeting({ greeting: 'Hi' });\n    // ==> 'Hi'\n\nCurrying alleviates the need for constructing these functions manually. If\n`property` was curried, you'd be able to create a new `greeting` function\nby just specifying some of the arguments, like you would do when invoking\nthe function:\n\n    const property2 = (key) => (object) => object[key];\n    const greeting2 = property2('greeting');\n\n    greeting({ greeting: 'Hi' });\n\nNote that the way we use arguments in a curried function is slightly\ndifferent. When designing a function to be curried, you should consider\nwhich parameters are most likely to be fixed, and which parameters will\nbe provided afterwards. In this case, it's much more likely for someone\nto have the name of a property than it is for them to have the object\nin which that property lives:\n\n    const score = [{ type: 'win' }, { type: 'draw' }];\n    score.map(property2('type'));\n    // ==> ['win', 'draw']\n\n\n## Why Use Currying?\n\nFunctional programming places a heavy emphasis on function composition,\nbut sometimes we have functions that don't exactly fit the places we\nwant to use them. For example, `Array.prototype.map` expects a function\nthat takes three arguments:\n\n    type Array.prototype.map =\n      Array<'element> . (\n        ('element, index is Number, Array<'element>) => 'newElement\n      ) => Array<'newElement>\n\nThat is, given an array of of some `element` type, our callback, which\nreceives not only this `element`, but also the index of that element in\nthe array, and even the original array, is supposed to return a `newElement`\nto put in the old element's place.\n\nWe can use `Array.prototype.map` to easily transform the data in the\narray by some function. To expand a bit on the initial example, suppose\nwe have an array of people:\n\n    const people = [\n      { name: 'Alissa', age: 26, pronoun: 'she'  },\n      { name: 'Max',    age: 19, pronoun: 'they' },\n      { name: 'Talib',  age: 28, pronoun: 'he'   }\n    ];\n\nAnd then you want to get the name of one of those people. We can use\n`Array.prototype.map` for this:\n\n    people.map((element, index, array) => element.name);\n    // ==> ['Alissa', 'Max', 'Talib']\n\n\n> **NOTE**  \n> Because functions in JavaScript are variadic, you don't need to\n> create a function with three parameters here. The following code\n> is strictly equivalent:\n>\n>     people.map(person => person.name);\n>     // ==> ['Alissa', 'Max', 'Talib']\n\n\nThis is all well and good, because this is the only place where we use\nthis kind of functionality. But what if we have very similar functionality\nin more places. For example, just like we got the names of these people,\nwe could get their ages:\n\n    people.map(person => person.age);\n    // ==> [26, 19, 28]\n\nOr the pronoun they use:\n\n    people.map(person => person.pronoun);\n    // ==> ['she', 'they', 'he']\n\nAt this point, we're duplicating this functionality in many places. It\nwould be more productive to move it to a function we can reuse. And this\nis easy enough:\n\n    const property = (object, key) => object[key];\n\nBut this attempt is not really a good one in this case. Now composing\nthings is even more trouble:\n\n    people.map(person => property(person, 'name'));\n\nIdeally, we'd want:\n\n    people.map(property);\n\nBut `property` takes two arguments, and `Array.prototype.map` can only\nprovide one of them: the object we should retrieve the property from.\nWhere do we get the other one from? Well, the name of the property is\nstatic. We know exactly what we need from the callsite.\n\nAs said in the previous section, thinking about which arguments are likely\nto be specified, and what aren't is important when designing curried\nfunctions. For this case, we want to specialise the `key`, and leave\n`object` to be provided by some other piece of code:\n\n     const property = (key) => (object) => object[key];\n\n     people.map(property('name'));\n     // ==> ['Alissa', 'Max', 'Talib']\n\n     people.map(property('age'));\n     // ==> [26, 19, 28]\n\n     people.map(property('pronoun'));\n     // ==> ['she', 'they', 'he'] \n\nSo, with currying, it becomes much simpler to shape a function so it\nfits the expectations of the place where you want to use it. It alleviates\nthe need of making this translation manually, but it also requires some\nprior thought on how these functions are likely to be used.\n\n\n## How Folktale's `curry` Works?\n\nThe `curry` operation makes it simpler to construct curried functions\nthat work well with JavaScript, where functions may, and often do, take\nmore than one argument.\n\nConsider the following example:\n\n    const joinedBy = (separator) => (list) => (item) =>\n      list.concat([separator, item]);\n\nIt's a curried function that takes 3 arguments, one at a time. To invoke\nit one must do so like this:\n\n    joinedBy(',')(['a'])('b');\n    // ==> ['a', ',', 'b']\n\nThis makes it harder to use it for functions that pass two arguments to\ntheir callbacks, like `Array.prototype.reduce`, because JavaScript passes\nthem all at once:\n\n    ['b'].reduce(joinedBy(','), ['a']);\n    // ==> [<function>, <function>]\n\nThis is where `curry` helps. It allows you to curry functions, while\nunrolling application of more than one argument:\n\n    const joinedBy2 = curry(3, (separator, list, item) =>\n      list.concat([separator, item]) \n    );\n\n    joinedBy2(',', ['a'], 'b');\n    // ==> ['a', ',', 'b']\n\n    ['b'].reduce(joinedBy2(','), ['a']);\n    // ==> ['a', ',', 'b']\n\n\n## `curry`, Under The Hood\n\nHow can `curry` construct functions that support such different styles\nof passing arguments? The secret is in how `curry` does unrolling. A\nfunction constructed by `curry` takes two arguments:\n\n 1) The number of arguments that are expected for that function (arity);\n 2) The function that should be called when those arguments are collected.\n\nIn return, `curry` gives you back a function that, at first, only collects\narguments. That is, until we reach the amount of arguments expected (arity),\napplying the `curry`ed function gives you back a new function that you\ncontinue to apply:\n\n    const f = curry(4, (a, b, c, d) => [a, b, c, d]);\n\n    // Previous arguments: []\n    const f1 = f();\n    // New arguments:      []\n\n    // Previous arguments: []\n    const f2 = f1(1);\n    // New arguments:      [1]\n\n    // Previous arguments: [1]\n    const f3 = f2(2, 3);\n    // New arguments:      [1, 2, 3]\n\n    // Previous arguments: [1, 2, 3]\n    f3(4);\n    // ==> [1, 2, 3, 4]\n    \nThe curried function keeps track of these arguments in an internal array.\nThis array is not modified when you apply a curried function. Instead, you\nget a new function with a separate \"internal arguments array\":\n\n    // Previous arguments: [1]\n    const f2_a = f2(4);  // => [1, 4]\n    const f2_b = f2(5);  // => [1, 5]\n\n    f2_a(5, 6); // ==> [1, 4, 5, 6]\n    f2_b(5, 6); // ==> [1, 5, 5, 6]\n\nOnce the curried function has collected all of the arguments it needs to,\nit \"unrolls\" the application. That is, it provides the arguments collected\nto the original function:\n\n    const plus  = (a, b, c) => a + b + c;\n    const plus2 = curry(3, plus);\n\n        plus2(1)(2)(3)\n    === plus2(1, 2)(3)\n    === plus2(1, 2, 3)\n    === plus(1, 2, 3)\n    === 1 + 2 + 3;\n    \nWhat happens if a curried function receives more arguments than it expects,\nthough? If the wrapped function is a regular JavaScript function, it's the\nsame. `curry` passes all of the arguments to it, and because JavaScript\nfunctions are variadic, those additional arguments get (usually) ignored:\n\n        plus2(1)(2)(3, 4, 5)\n    === plus2(1, 2)(3, 4, 5)\n    === plus2(1, 2, 3, 4, 5)\n    === plus(1, 2, 3, 4, 5)\n    === 1 + 2 + 3;\n\nIf the wrapped function is itself a curried function, things get more\ninteresting though, because the curried functio will, itself, unroll\nthe rest of the application!\n\n\n    const subtract = curry(2, (x, y) => x - y);\n    const flip     = curry(3, (f, x, y) => f(y, x));\n\n        subtract(1)(2)\n    === subtract(1, 2)\n    === 1 - 2;\n\n        flip(subtract)(1)(2)\n    === flip(subtract, 1)(2)\n    === flip(subtract, 1, 2)\n    === subtract(2, 1)\n    === 2 - 1;\n\nUnrolling makes it possible to compose curried functions naturally, without\ngetting in the way of regular JavaScript functions.\n\n> **NOTE**  \n> Using `curry` for real variadic functions is strongly discouraged, given\n> that it's hard to predict which arguments will end up being provided to\n> the variadic function.\n\n\n## Drawbacks of Using `curry`\n\nWhile `curry` certainly helps composing functions, it's important to note\nthat, because a lot of functions in JavaScript are variadic, and because\npeople take advantage of this (by relying on the number of arguments\nprovided for optional parameters or overloading the signature),\ncomposition of such functions is not well-defined, and `curry` makes\nthings even less predictable for these cases.\n\nBecause of this, the use of `curry` for variadic functions is strongly\ndiscouraged.\n\nOne also must consider the overhead of introducing `curry` in a codebase.\nFor most code, this overhead is negligible, but `curry` should be avoided\nin code paths that require more performance.\n\n",
  "examples": [{
    "name": "",
    "call": __metamagical_withMeta(function () {}, {
      "source": ""
    }),
    "inferred": true
  }, {
    "name": "Example::",
    "call": __metamagical_withMeta(function () {
      var property = curry(2, function (key, object) {
        return object[key];
      });var people = [{ name: 'Alissa', age: 26 }, { name: 'Max', age: 19 }, { name: 'Talib', age: 28 }];__metamagical_assert_equals(require("assert"), people.map(property('name')), ['Alissa', 'Max', 'Talib'], "people.map(property('name')) ==> ['Alissa', 'Max', 'Talib']");; // ==> ['Alissa', 'Max', 'Talib']
    }, {
      "source": "const property = curry(2, (key, object) => object[key]);\nconst people = [\n  { name: 'Alissa', age: 26 },\n  { name: 'Max',    age: 19 },\n  { name: 'Talib',  age: 28 }\n];\n\npeople.map(property('name'));\n// ==> ['Alissa', 'Max', 'Talib']"
    }),
    "inferred": true
  }, {
    "name": "What is \"Currying\"?",
    "call": __metamagical_withMeta(function () {
      var property = function property(object, key) {
        return object[key];
      };__metamagical_assert_equals(require("assert"), property({ greeting: 'Hi' }, 'greeting'), 'Hi', "property({\n  greeting: 'Hi'\n}, 'greeting') ==> 'Hi'");; // ==> 'Hi'
      var greeting = function greeting(object) {
        return property(object, 'greeting');
      };__metamagical_assert_equals(require("assert"), greeting({ greeting: 'Hi' }), 'Hi', "greeting({\n  greeting: 'Hi'\n}) ==> 'Hi'");; // ==> 'Hi'
      var property2 = function property2(key) {
        return function (object) {
          return object[key];
        };
      };var greeting2 = property2('greeting');greeting({ greeting: 'Hi' });var score = [{ type: 'win' }, { type: 'draw' }];__metamagical_assert_equals(require("assert"), score.map(property2('type')), ['win', 'draw'], "score.map(property2('type')) ==> ['win', 'draw']");; // ==> ['win', 'draw']
    }, {
      "source": "const property = (object, key) => object[key];\n\nproperty({ greeting: 'Hi' }, 'greeting');\n// ==> 'Hi'\n\nconst greeting = (object) => property(object, 'greeting');\n\ngreeting({ greeting: 'Hi' });\n// ==> 'Hi'\n\nconst property2 = (key) => (object) => object[key];\nconst greeting2 = property2('greeting');\n\ngreeting({ greeting: 'Hi' });\n\nconst score = [{ type: 'win' }, { type: 'draw' }];\nscore.map(property2('type'));\n// ==> ['win', 'draw']"
    }),
    "inferred": true
  }, {
    "name": "Why Use Currying?",
    "call": __metamagical_withMeta(function () {
      var people = [{ name: 'Alissa', age: 26, pronoun: 'she' }, { name: 'Max', age: 19, pronoun: 'they' }, { name: 'Talib', age: 28, pronoun: 'he' }];__metamagical_assert_equals(require("assert"), people.map(function (element, index, array) {
        return element.name;
      }), ['Alissa', 'Max', 'Talib'], "people.map((element, index, array) => element.name) ==> ['Alissa', 'Max', 'Talib']");; // ==> ['Alissa', 'Max', 'Talib']
      __metamagical_assert_equals(require("assert"), people.map(function (person) {
        return person.name;
      }), ['Alissa', 'Max', 'Talib'], "people.map(person => person.name) ==> ['Alissa', 'Max', 'Talib']");; // ==> ['Alissa', 'Max', 'Talib']
      __metamagical_assert_equals(require("assert"), people.map(function (person) {
        return person.age;
      }), [26, 19, 28], "people.map(person => person.age) ==> [26, 19, 28]");; // ==> [26, 19, 28]
      __metamagical_assert_equals(require("assert"), people.map(function (person) {
        return person.pronoun;
      }), ['she', 'they', 'he'], "people.map(person => person.pronoun) ==> ['she', 'they', 'he']");; // ==> ['she', 'they', 'he']
      var property = function property(key) {
        return function (object) {
          return object[key];
        };
      };__metamagical_assert_equals(require("assert"), people.map(property('name')), ['Alissa', 'Max', 'Talib'], "people.map(property('name')) ==> ['Alissa', 'Max', 'Talib']");; // ==> ['Alissa', 'Max', 'Talib']
      __metamagical_assert_equals(require("assert"), people.map(property('age')), [26, 19, 28], "people.map(property('age')) ==> [26, 19, 28]");; // ==> [26, 19, 28]
      __metamagical_assert_equals(require("assert"), people.map(property('pronoun')), ['she', 'they', 'he'], "people.map(property('pronoun')) ==> ['she', 'they', 'he']");; // ==> ['she', 'they', 'he'] 
    }, {
      "source": "const people = [\n  { name: 'Alissa', age: 26, pronoun: 'she'  },\n  { name: 'Max',    age: 19, pronoun: 'they' },\n  { name: 'Talib',  age: 28, pronoun: 'he'   }\n];\n\npeople.map((element, index, array) => element.name);\n// ==> ['Alissa', 'Max', 'Talib']\n\npeople.map(person => person.name);\n// ==> ['Alissa', 'Max', 'Talib']\n\npeople.map(person => person.age);\n// ==> [26, 19, 28]\n\npeople.map(person => person.pronoun);\n// ==> ['she', 'they', 'he']\n\n const property = (key) => (object) => object[key];\n\n people.map(property('name'));\n // ==> ['Alissa', 'Max', 'Talib']\n\n people.map(property('age'));\n // ==> [26, 19, 28]\n\n people.map(property('pronoun'));\n // ==> ['she', 'they', 'he'] "
    }),
    "inferred": true
  }, {
    "name": "How Folktale's `curry` Works?",
    "call": __metamagical_withMeta(function () {
      var joinedBy = function joinedBy(separator) {
        return function (list) {
          return function (item) {
            return list.concat([separator, item]);
          };
        };
      };__metamagical_assert_equals(require("assert"), joinedBy(',')(['a'])('b'), ['a', ',', 'b'], "joinedBy(',')(['a'])('b') ==> ['a', ',', 'b']");; // ==> ['a', ',', 'b']
      var joinedBy2 = curry(3, function (separator, list, item) {
        return list.concat([separator, item]);
      });__metamagical_assert_equals(require("assert"), joinedBy2(',', ['a'], 'b'), ['a', ',', 'b'], "joinedBy2(',', ['a'], 'b') ==> ['a', ',', 'b']");; // ==> ['a', ',', 'b']
      __metamagical_assert_equals(require("assert"), ['b'].reduce(joinedBy2(','), ['a']), ['a', ',', 'b'], "['b'].reduce(joinedBy2(','), ['a']) ==> ['a', ',', 'b']");; // ==> ['a', ',', 'b']
    }, {
      "source": "const joinedBy = (separator) => (list) => (item) =>\n  list.concat([separator, item]);\n\njoinedBy(',')(['a'])('b');\n// ==> ['a', ',', 'b']\n\nconst joinedBy2 = curry(3, (separator, list, item) =>\n  list.concat([separator, item]) \n);\n\njoinedBy2(',', ['a'], 'b');\n// ==> ['a', ',', 'b']\n\n['b'].reduce(joinedBy2(','), ['a']);\n// ==> ['a', ',', 'b']"
    }),
    "inferred": true
  }, {
    "name": "`curry`, Under The Hood",
    "call": __metamagical_withMeta(function () {
      var f = curry(4, function (a, b, c, d) {
        return [a, b, c, d];
      }); // Previous arguments: []
      var f1 = f(); // New arguments:      []
      // Previous arguments: []
      var f2 = f1(1); // New arguments:      [1]
      // Previous arguments: [1]
      var f3 = f2(2, 3); // Previous arguments: [1, 2, 3]
      __metamagical_assert_equals(require("assert"), f3(4), [1, 2, 3, 4], "f3(4) ==> [1, 2, 3, 4]");; // Previous arguments: [1]
      var f2_a = f2(4); // => [1, 4]
      var f2_b = f2(5); // => [1, 5]
      __metamagical_assert_equals(require("assert"), f2_a(5, 6), [1, 4, 5, 6], "f2_a(5, 6) ==> [1, 4, 5, 6]");; // ==> [1, 4, 5, 6]
      __metamagical_assert_equals(require("assert"), f2_b(5, 6), [1, 5, 5, 6], "f2_b(5, 6) ==> [1, 5, 5, 6]");; // ==> [1, 5, 5, 6]
      var plus = function plus(a, b, c) {
        return a + b + c;
      };var plus2 = curry(3, plus);plus2(1)(2)(3) === plus2(1, 2)(3) === plus2(1, 2, 3) === plus(1, 2, 3) === 1 + 2 + 3;plus2(1)(2)(3, 4, 5) === plus2(1, 2)(3, 4, 5) === plus2(1, 2, 3, 4, 5) === plus(1, 2, 3, 4, 5) === 1 + 2 + 3;var subtract = curry(2, function (x, y) {
        return x - y;
      });var flip = curry(3, function (f, x, y) {
        return f(y, x);
      });subtract(1)(2) === subtract(1, 2) === 1 - 2;flip(subtract)(1)(2) === flip(subtract, 1)(2) === flip(subtract, 1, 2) === subtract(2, 1) === 2 - 1;
    }, {
      "source": "const f = curry(4, (a, b, c, d) => [a, b, c, d]);\n\n// Previous arguments: []\nconst f1 = f();\n// New arguments:      []\n\n// Previous arguments: []\nconst f2 = f1(1);\n// New arguments:      [1]\n\n// Previous arguments: [1]\nconst f3 = f2(2, 3);\n// New arguments:      [1, 2, 3]\n\n// Previous arguments: [1, 2, 3]\nf3(4);\n// ==> [1, 2, 3, 4]\n\n// Previous arguments: [1]\nconst f2_a = f2(4);  // => [1, 4]\nconst f2_b = f2(5);  // => [1, 5]\n\nf2_a(5, 6); // ==> [1, 4, 5, 6]\nf2_b(5, 6); // ==> [1, 5, 5, 6]\n\nconst plus  = (a, b, c) => a + b + c;\nconst plus2 = curry(3, plus);\n\n    plus2(1)(2)(3)\n=== plus2(1, 2)(3)\n=== plus2(1, 2, 3)\n=== plus(1, 2, 3)\n=== 1 + 2 + 3;\n\n    plus2(1)(2)(3, 4, 5)\n=== plus2(1, 2)(3, 4, 5)\n=== plus2(1, 2, 3, 4, 5)\n=== plus(1, 2, 3, 4, 5)\n=== 1 + 2 + 3;\n\nconst subtract = curry(2, (x, y) => x - y);\nconst flip     = curry(3, (f, x, y) => f(y, x));\n\n    subtract(1)(2)\n=== subtract(1, 2)\n=== 1 - 2;\n\n    flip(subtract)(1)(2)\n=== flip(subtract, 1)(2)\n=== flip(subtract, 1, 2)\n=== subtract(2, 1)\n=== 2 - 1;"
    }),
    "inferred": true
  }]
});

// --[ Exports ]-------------------------------------------------------
module.exports = curry;
},{"assert":54}],21:[function(require,module,exports){
"use strict";

var __metamagical_withMeta = function metamagical_withMeta(object, meta) {
  var parent = Object.getPrototypeOf(object);var oldMeta = object[Symbol.for('@@meta:magical')] || {};if (parent && parent[Symbol.for('@@meta:magical')] === oldMeta) {
    oldMeta = {};
  }Object.keys(meta).forEach(function (key) {
    if (/^~/.test(key)) {
      oldMeta[key.slice(1)] = meta[key];
    } else {
      oldMeta[key] = meta[key];
    }
  });object[Symbol.for('@@meta:magical')] = oldMeta;return object;
},
    __metamagical_assert_equals = function metamagical_assert_equals(assert, actual, expected, message) {
  var assertionType = Symbol.for('@@meta:magical:assertion-type');var rest = Symbol.for('@@meta:magical:assertion-rest');var keys = Object.keys;function isSetoid(value) {
    return value && typeof value.equals === 'function';
  }function isRecord(value) {
    return value && value[assertionType] === 'record';
  }function check(predicate) {
    for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }return values.every(predicate);
  }function getSpecialArrayLength(array) {
    var rests = array.map(function (x, i) {
      return [x, i];
    }).filter(function (pair) {
      return pair[0] === rest;
    });if (rests.length > 1 || rests[0] && rests[0][1] !== array.length - 1) {
      assert.ok(false, message + '. Assertions only support a single trailing rest indication for arrays currently.');
    }return (rests[0] || [null, array.length])[1];
  }function compareArrays(left, right) {
    var expectedLength = getSpecialArrayLength(right);assert.ok(Array.isArray(left), message + '. The LHS is not an array.');if (left.length < expectedLength) {
      assert.ok(false, message + '. The LHS does not have the minimum expected length (' + left.length + ' < ' + expectedLength + ')');
    }for (var i = 0; i < expectedLength; ++i) {
      compare(left[i], right[i]);
    }
  }function compareRecord(left, right) {
    var isPartial = right[rest];assert.ok(Object(left) === left, message);if (!isPartial) {
      assert.deepStrictEqual(keys(left).sort(), keys(right).sort(), message + '. The objects have different keys ([' + keys(left).sort().join(', ') + '] vs. [' + keys(right).sort().join(', ') + '])');
    }Object.keys(right).forEach(function (key) {
      if (!(key in left)) {
        assert.ok(false, message + '. The expected key ' + key + ' is not present in the actual object.');
      }compare(left[key], right[key]);
    });
  }function compare(l, r) {
    return check(isSetoid, l, r) ? assert.ok(l.equals(r), message + '. The LHS (' + l + ') setoid instance says the LHS and RHS (' + r + ') are not equal.') : Array.isArray(r) ? compareArrays(l, r) : isRecord(r) ? compareRecord(l, r) : /* otherwise */assert.deepStrictEqual(l, r, message + '. The LHS (' + l + ') and the RHS (' + r + ') are not structually equal.');
  }compare(actual, expected);
};

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

/*~
 * The identity combinator; always returns the argument given.
 *
 *
 * ## Example::
 *
 *     identity(1);
 *     // ==> 1
 *
 *     [1, 2, 3].map(identity);
 *     // ==> [1, 2, 3]
 *
 *
 * ## Why?
 *
 * There aren't many reasons to use the `identity` combinator in real
 * JavaScript code. Readability is the only compelling one. Figuring
 * out the concept of `identity` from reading the word `identity` is
 * easier than working your way through its implementation.
 *
 * Compare:
 *
 *     either.bimap(identity, (counter) => counter + 1);
 *
 * With:
 *
 *     either.bimap(
 *       (failure) => failure,
 *       (counter) => counter + 1
 *     )
 *
 *
 * ---
 * category  : Combinators
 * stability : stable
 *
 * authors:
 *   - Quildreen Motta
 *
 * type: |
 *   ('a) => 'a
 */
var identity = __metamagical_withMeta(function (value) {
  return value;
}, {
  "name": "identity",
  "source": "(value) => value",
  "signature": "identity(value)",
  "location": {
    "filename": "src/core/lambda/identity.js",
    "start": {
      "line": 52,
      "column": 0
    },
    "end": {
      "line": 52,
      "column": 34
    }
  },
  "module": "folktale/src/core/lambda/identity",
  "licence": "MIT",
  "authors": ["Quildreen Motta"],
  "repository": "https://github.com/origamitower/folktale",
  "npmPackage": "folktale",
  "category": "Combinators",
  "stability": "stable",
  "type": "('a) => 'a\n",
  "documentation": "\nThe identity combinator; always returns the argument given.\n\n\n## Example:\n\n    identity(1);\n    // ==> 1\n\n    [1, 2, 3].map(identity);\n    // ==> [1, 2, 3]\n\n\n## Why?\n\nThere aren't many reasons to use the `identity` combinator in real\nJavaScript code. Readability is the only compelling one. Figuring\nout the concept of `identity` from reading the word `identity` is\neasier than working your way through its implementation.\n\nCompare:\n\n    either.bimap(identity, (counter) => counter + 1);\n\nWith:\n\n    either.bimap(\n      (failure) => failure,\n      (counter) => counter + 1\n    )\n\n",
  "examples": [{
    "name": "",
    "call": __metamagical_withMeta(function () {}, {
      "source": ""
    }),
    "inferred": true
  }, {
    "name": "Example::",
    "call": __metamagical_withMeta(function () {
      __metamagical_assert_equals(require("assert"), identity(1), 1, "identity(1) ==> 1");; // ==> 1
      __metamagical_assert_equals(require("assert"), [1, 2, 3].map(identity), [1, 2, 3], "[1, 2, 3].map(identity) ==> [1, 2, 3]");; // ==> [1, 2, 3]
    }, {
      "source": "identity(1);\n// ==> 1\n\n[1, 2, 3].map(identity);\n// ==> [1, 2, 3]"
    }),
    "inferred": true
  }]
});

// --[ Exports ]-------------------------------------------------------
module.exports = identity;
},{"assert":54}],22:[function(require,module,exports){
'use strict';

var __metamagical_withMeta = function metamagical_withMeta(object, meta) {
  var parent = Object.getPrototypeOf(object);var oldMeta = object[Symbol.for('@@meta:magical')] || {};if (parent && parent[Symbol.for('@@meta:magical')] === oldMeta) {
    oldMeta = {};
  }Object.keys(meta).forEach(function (key) {
    if (/^~/.test(key)) {
      oldMeta[key.slice(1)] = meta[key];
    } else {
      oldMeta[key] = meta[key];
    }
  });object[Symbol.for('@@meta:magical')] = oldMeta;return object;
},
    __metamagical_assert_equals = function metamagical_assert_equals(assert, actual, expected, message) {
  var assertionType = Symbol.for('@@meta:magical:assertion-type');var rest = Symbol.for('@@meta:magical:assertion-rest');var keys = Object.keys;function isSetoid(value) {
    return value && typeof value.equals === 'function';
  }function isRecord(value) {
    return value && value[assertionType] === 'record';
  }function check(predicate) {
    for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }return values.every(predicate);
  }function getSpecialArrayLength(array) {
    var rests = array.map(function (x, i) {
      return [x, i];
    }).filter(function (pair) {
      return pair[0] === rest;
    });if (rests.length > 1 || rests[0] && rests[0][1] !== array.length - 1) {
      assert.ok(false, message + '. Assertions only support a single trailing rest indication for arrays currently.');
    }return (rests[0] || [null, array.length])[1];
  }function compareArrays(left, right) {
    var expectedLength = getSpecialArrayLength(right);assert.ok(Array.isArray(left), message + '. The LHS is not an array.');if (left.length < expectedLength) {
      assert.ok(false, message + '. The LHS does not have the minimum expected length (' + left.length + ' < ' + expectedLength + ')');
    }for (var i = 0; i < expectedLength; ++i) {
      compare(left[i], right[i]);
    }
  }function compareRecord(left, right) {
    var isPartial = right[rest];assert.ok(Object(left) === left, message);if (!isPartial) {
      assert.deepStrictEqual(keys(left).sort(), keys(right).sort(), message + '. The objects have different keys ([' + keys(left).sort().join(', ') + '] vs. [' + keys(right).sort().join(', ') + '])');
    }Object.keys(right).forEach(function (key) {
      if (!(key in left)) {
        assert.ok(false, message + '. The expected key ' + key + ' is not present in the actual object.');
      }compare(left[key], right[key]);
    });
  }function compare(l, r) {
    return check(isSetoid, l, r) ? assert.ok(l.equals(r), message + '. The LHS (' + l + ') setoid instance says the LHS and RHS (' + r + ') are not equal.') : Array.isArray(r) ? compareArrays(l, r) : isRecord(r) ? compareRecord(l, r) : /* otherwise */assert.deepStrictEqual(l, r, message + '. The LHS (' + l + ') and the RHS (' + r + ') are not structually equal.');
  }compare(actual, expected);
};

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

/*~
 * Core.Lambda provides you tools for transforming and combining
 * functions.
 *
 * 
 * ## Programming by Combining Functions
 * 
 * Functional programming places a heavy emphasis on writing programs
 * by combining lots of small, focused functions. JavaScript doesn't
 * really have a good support for this out of the box, so you're left
 * with composing these functions manually, by defining a new function.
 * 
 * This is not so bad in ECMAScript 2015, thanks to the new arrow
 * function syntax::
 * 
 *     const people = [
 *       { name: 'Alissa' },
 *       { name: 'Max' },
 *       { name: 'Talib' }
 *     ];
 *     people.map(person => person.name);
 *     // ==> ['Alissa', 'Max', 'Talib']
 * 
 * But there are times in which arrow functions don't quite cut it.
 * For example, if one wants to evaluate something eagerly, a constant
 * combinator makes more sense::
 * 
 *     const counter = {
 *       value: 0,
 *       next()  { return ++this.value },
 *       reset() { this.value = 0 }
 *     };
 *     const constant = require('folktale/core/lambda/constant');
 * 
 *     counter.reset();
 *     [0, 0, 0].map(constant(counter.next()));
 *     // ==> [1, 1, 1]
 * 
 *     // Arrows are evaluated lazily, so they don't work for this
 *     counter.reset();
 *     [0, 0, 0].map(_ => counter.next());
 *     // ==> [1, 2, 3]
 * 
 *     // One must store the value somewhere instead
 *     counter.reset();
 *     [0, 0, 0].map((x => _ => x)(counter.next()))
 *
 * 
 * ## What's in Core.Lambda?
 * 
 * Core.Lambda provides combinators and operations that transform the
 * signature of a function. The operations in the module are divided
 * as thus:
 * 
 *   - **Combining**: contains functions that combines functionality
 *   present in different functions into a single function. Composing
 *   functions is an example.
 * 
 *   - **Combinators**: functions that just re-arrange the arguments
 *   they're given. They're convenient ways of writing a particular
 *   operation, but don't have any special behaviour of their own,
 *   nor use anything besides the arguments they're given. Constant
 *   and Identity are common combinators.
 * 
 *   - **Currying and Partialisation**: functions that transform
 *   how parameters are provided to a function. Currying allows a
 *   function to take parameters one at a time, whereas partialisation
 *   allows one to provide some of the positional parameters without
 *   executing the function before the rest is provided.
 * 
 * ---
 * name     : module folktale/core/lambda
 * category : Lambda Calculus
 */
module.exports = __metamagical_withMeta({
  identity: require('./identity'),
  constant: require('./constant'),
  curry: require('./curry'),
  compose: require('./compose'),
  partialise: require('./partialise')
}, {
  'name': 'module folktale/core/lambda',
  'source': '{\n  identity: require(\'./identity\'),\n  constant: require(\'./constant\'),\n  curry: require(\'./curry\'),\n  compose: require(\'./compose\'),\n  partialise: require(\'./partialise\')\n}',
  'location': {
    'filename': 'src/core/lambda/index.js',
    'start': {
      'line': 84,
      'column': 0
    },
    'end': {
      'line': 90,
      'column': 2
    }
  },
  'module': 'folktale/src/core/lambda',
  'licence': 'MIT',
  'authors': ['Quildreen Motta'],
  'repository': 'https://github.com/origamitower/folktale',
  'npmPackage': 'folktale',
  'isModule': true,
  'category': 'Lambda Calculus',
  'documentation': '\nCore.Lambda provides you tools for transforming and combining\nfunctions.\n\n\n## Programming by Combining Functions\n\nFunctional programming places a heavy emphasis on writing programs\nby combining lots of small, focused functions. JavaScript doesn\'t\nreally have a good support for this out of the box, so you\'re left\nwith composing these functions manually, by defining a new function.\n\nThis is not so bad in ECMAScript 2015, thanks to the new arrow\nfunction syntax:\n\n    const people = [\n      { name: \'Alissa\' },\n      { name: \'Max\' },\n      { name: \'Talib\' }\n    ];\n    people.map(person => person.name);\n    // ==> [\'Alissa\', \'Max\', \'Talib\']\n\nBut there are times in which arrow functions don\'t quite cut it.\nFor example, if one wants to evaluate something eagerly, a constant\ncombinator makes more sense:\n\n    const counter = {\n      value: 0,\n      next()  { return ++this.value },\n      reset() { this.value = 0 }\n    };\n    const constant = require(\'folktale/core/lambda/constant\');\n\n    counter.reset();\n    [0, 0, 0].map(constant(counter.next()));\n    // ==> [1, 1, 1]\n\n    // Arrows are evaluated lazily, so they don\'t work for this\n    counter.reset();\n    [0, 0, 0].map(_ => counter.next());\n    // ==> [1, 2, 3]\n\n    // One must store the value somewhere instead\n    counter.reset();\n    [0, 0, 0].map((x => _ => x)(counter.next()))\n\n\n## What\'s in Core.Lambda?\n\nCore.Lambda provides combinators and operations that transform the\nsignature of a function. The operations in the module are divided\nas thus:\n\n  - **Combining**: contains functions that combines functionality\n  present in different functions into a single function. Composing\n  functions is an example.\n\n  - **Combinators**: functions that just re-arrange the arguments\n  they\'re given. They\'re convenient ways of writing a particular\n  operation, but don\'t have any special behaviour of their own,\n  nor use anything besides the arguments they\'re given. Constant\n  and Identity are common combinators.\n\n  - **Currying and Partialisation**: functions that transform\n  how parameters are provided to a function. Currying allows a\n  function to take parameters one at a time, whereas partialisation\n  allows one to provide some of the positional parameters without\n  executing the function before the rest is provided.\n',
  'examples': [{
    'name': '',
    'call': __metamagical_withMeta(function () {}, {
      'source': ''
    }),
    'inferred': true
  }, {
    'name': 'Programming by Combining Functions',
    'call': __metamagical_withMeta(function () {
      var people = [{ name: 'Alissa' }, { name: 'Max' }, { name: 'Talib' }];__metamagical_assert_equals(require('assert'), people.map(function (person) {
        return person.name;
      }), ['Alissa', 'Max', 'Talib'], 'people.map(person => person.name) ==> [\'Alissa\', \'Max\', \'Talib\']');; // ==> ['Alissa', 'Max', 'Talib']
      var counter = { value: 0, next: function next() {
          return ++this.value;
        },
        reset: function reset() {
          this.value = 0;
        }
      };var constant = require('./constant');counter.reset();__metamagical_assert_equals(require('assert'), [0, 0, 0].map(constant(counter.next())), [1, 1, 1], '[0, 0, 0].map(constant(counter.next())) ==> [1, 1, 1]');; // ==> [1, 1, 1]
      // Arrows are evaluated lazily, so they don't work for this
      counter.reset();__metamagical_assert_equals(require('assert'), [0, 0, 0].map(function (_) {
        return counter.next();
      }), [1, 2, 3], '[0, 0, 0].map(_ => counter.next()) ==> [1, 2, 3]');; // ==> [1, 2, 3]
      // One must store the value somewhere instead
      counter.reset();[0, 0, 0].map(function (x) {
        return function (_) {
          return x;
        };
      }(counter.next()));
    }, {
      'source': 'const people = [\n  { name: \'Alissa\' },\n  { name: \'Max\' },\n  { name: \'Talib\' }\n];\npeople.map(person => person.name);\n// ==> [\'Alissa\', \'Max\', \'Talib\']\n\nconst counter = {\n  value: 0,\n  next()  { return ++this.value },\n  reset() { this.value = 0 }\n};\nconst constant = require(\'folktale/core/lambda/constant\');\n\ncounter.reset();\n[0, 0, 0].map(constant(counter.next()));\n// ==> [1, 1, 1]\n\n// Arrows are evaluated lazily, so they don\'t work for this\ncounter.reset();\n[0, 0, 0].map(_ => counter.next());\n// ==> [1, 2, 3]\n\n// One must store the value somewhere instead\ncounter.reset();\n[0, 0, 0].map((x => _ => x)(counter.next()))'
    }),
    'inferred': true
  }]
});
},{"./compose":18,"./constant":19,"./curry":20,"./identity":21,"./partialise":23,"assert":54}],23:[function(require,module,exports){
"use strict";

var __metamagical_withMeta = function metamagical_withMeta(object, meta) {
  var parent = Object.getPrototypeOf(object);var oldMeta = object[Symbol.for('@@meta:magical')] || {};if (parent && parent[Symbol.for('@@meta:magical')] === oldMeta) {
    oldMeta = {};
  }Object.keys(meta).forEach(function (key) {
    if (/^~/.test(key)) {
      oldMeta[key.slice(1)] = meta[key];
    } else {
      oldMeta[key] = meta[key];
    }
  });object[Symbol.for('@@meta:magical')] = oldMeta;return object;
},
    __metamagical_assert_equals = function metamagical_assert_equals(assert, actual, expected, message) {
  var assertionType = Symbol.for('@@meta:magical:assertion-type');var rest = Symbol.for('@@meta:magical:assertion-rest');var keys = Object.keys;function isSetoid(value) {
    return value && typeof value.equals === 'function';
  }function isRecord(value) {
    return value && value[assertionType] === 'record';
  }function check(predicate) {
    for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }return values.every(predicate);
  }function getSpecialArrayLength(array) {
    var rests = array.map(function (x, i) {
      return [x, i];
    }).filter(function (pair) {
      return pair[0] === rest;
    });if (rests.length > 1 || rests[0] && rests[0][1] !== array.length - 1) {
      assert.ok(false, message + '. Assertions only support a single trailing rest indication for arrays currently.');
    }return (rests[0] || [null, array.length])[1];
  }function compareArrays(left, right) {
    var expectedLength = getSpecialArrayLength(right);assert.ok(Array.isArray(left), message + '. The LHS is not an array.');if (left.length < expectedLength) {
      assert.ok(false, message + '. The LHS does not have the minimum expected length (' + left.length + ' < ' + expectedLength + ')');
    }for (var i = 0; i < expectedLength; ++i) {
      compare(left[i], right[i]);
    }
  }function compareRecord(left, right) {
    var isPartial = right[rest];assert.ok(Object(left) === left, message);if (!isPartial) {
      assert.deepStrictEqual(keys(left).sort(), keys(right).sort(), message + '. The objects have different keys ([' + keys(left).sort().join(', ') + '] vs. [' + keys(right).sort().join(', ') + '])');
    }Object.keys(right).forEach(function (key) {
      if (!(key in left)) {
        assert.ok(false, message + '. The expected key ' + key + ' is not present in the actual object.');
      }compare(left[key], right[key]);
    });
  }function compare(l, r) {
    return check(isSetoid, l, r) ? assert.ok(l.equals(r), message + '. The LHS (' + l + ') setoid instance says the LHS and RHS (' + r + ') are not equal.') : Array.isArray(r) ? compareArrays(l, r) : isRecord(r) ? compareRecord(l, r) : /* otherwise */assert.deepStrictEqual(l, r, message + '. The LHS (' + l + ') and the RHS (' + r + ') are not structually equal.');
  }compare(actual, expected);
};

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

var hole = {};

/*~
 * Creates a new function where some of the arguments are specified.
 *
 *
 * ## Example::
 *
 *     const clamp = (min, max, number) =>
 *       number < min ?  min
 *     : number > max ?  max
 *     :                 number;
 *
 *     const _      = partialise.hole;
 *     const clamp_ = partialise(3, clamp);
 *
 *     const atLeast = clamp_(_, Infinity, _);
 *     const atMost  = clamp_(-Infinity, _, _);
 *
 *     atLeast(3, 2); // ==> 3
 *     atLeast(3, 5); // ==> 5
 *
 *     atMost(5, 3);  // ==> 3
 *     atMost(5, 10); // ==> 5
 *
 *
 * ## Why Partialisation
 *
 * With higher-order programming, one often wants to specialise some of
 * the arguments of a function before passing it to another function.
 * This kind of configuration is often done by creating a new function
 * manually::
 *
 *     const plus = (a, b) => a + b;
 *     const add5 = (x) => plus(5, x);
 *
 *     [1, 2, 3].map(add5);
 *     // ==> [6, 7, 8]
 *
 * And for most cases this is reasonable. For functions that take more
 * parameters, this can be cumbersome, however. The `partialise` function
 * allows creating a new function by specialising some of the arguments,
 * and filling the remaining ones when the function is called.
 *
 * Places where the caller of the function should fill are specified as
 * `hole`, which is a special constant used by `partialise`::
 *
 *     const _ = partialise.hole;
 *     const partialAdd5 = partialise(2, plus)(5, _);
 *     [1, 2, 3].map(partialAdd5);
 *     // ==> [6, 7, 8]
 *
 *
 * ## Relation to Currying
 *
 * Partial application and currying are related concepts. Currying
 * refers to transforming a function of arity N, into N functions of
 * arity 1. Partial application, on the other hand, refers to
 * fixing some (but not all) arguments of a function.
 *
 * Both concepts are used to improve function composition, where the
 * shape of the function you have does not reflect the shape of the
 * function expected by function you're calling. So, in essence, these
 * techniques transform the shape of your function to make them "fit"
 * some API.
 *
 * `partialise` and `curry` differ on how they achieve this, however.
 * While `curry` creates N functions, and lets you specify arguments
 * one by one, `partialise` requires you to specify all arguments at
 * once, distinguishing which ones are fixed, and which ones have to
 * be provided (using "holes").
 *
 * Because of this, `curry` can be more natural, but it requires that
 * the APIs be designed thinking about currying before hand, and it
 * often interacts poorly with JavaScript, due to the use of variadic
 * functions. `partialise` does not have such problems.
 *
 *
 * ## How `partialise` Works?
 *
 * The `partialise` function transforms regular functions into
 * functions that can accept holes for arguments that are not
 * defined yet. Whenever a partial function receives a hole as
 * an argument, it constructs a new function so the holes can
 * be filled later::
 *
 *     const clamp = (min, max, number) =>
 *       number < min ?  min
 *     : number > max ?  max
 *     :                 number
 *
 *     const partialClamp = partialise(3, clamp);
 *
 * In the example above, `partialClamp` is a function that takes
 * arguments that may or may not be holes. A hole is a special
 * constant defined by `partialise` itself. It's convenient to
 * bind such constant to the `_` binding::
 *
 *     const _ = partialise.hole;
 *
 * A partial function is considered saturated when, among the
 * arguments provided to it, no hole exists. When a partial function
 * is saturated, its original behaviour is executed::
 *
 *     partialClamp(3, 5, 6);  // ==> 5
 *
 * If a partial function is not saturated, then it its execution
 * results in a new partial function::
 *
 *     const atLeast = partialClamp(_, Infinity, _);
 *     atLeast(5, 3); // ==> 5
 *
 *     const atLeast5 = atLeast(5, _);
 *     atLeast5(3); // ==> 5
 *
 * Note that to prevent confusing behaviour, Folktale's `partialise`
 * forces you to always pass the exact number of arguments that the
 * partial function expects. Passing more or less arguments to a
 * partial function is a TypeError. This ensures that all new partial
 * functions can properly invoke the original behaviour when saturated,
 * rather than returning previous unsaturated functions.
 *
 *
 * ## Drawbacks of Using `partialise`
 *
 * `partialise` is a convenience function for transforming the shape
 * of functions, and it relies on variadic application, as well as
 * doing a fair bit of processing before each call to determine
 * saturation. Combined, these make `partialise` a poor choice for
 * any code that needs to be performant.
 *
 *
 * ---
 * since     : v2.0.0
 * category  : Currying and Partialisation
 * stability : experimental
 * authors:
 *   - Quildreen Motta
 *
 * throws:
 *   TypeError: when the number of arguments given doesn't match the arity.
 *
 * type: |
 *   (Number, (Any... => Any)) => ((hole | Any)...) => Any :: (throw TypeError)
 */
var partialise = __metamagical_withMeta(function (arity, fn) {
  return function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (args.length < arity) {
      throw new TypeError("The partial function takes at least " + arity + " arguments, but was given " + args.length + ".");
    }

    // Figure out if we have holes
    var holes = 0;
    for (var i = 0; i < args.length; ++i) {
      if (args[i] === hole) {
        holes += 1;
      }
    }

    if (holes > 0) {
      return partialise(holes, function () {
        var realArgs = [];
        var argIndex = 0;

        for (var _i = 0; _i < args.length; ++_i) {
          var arg = args[_i];
          if (arg === hole) {
            realArgs.push(arguments.length <= argIndex + 0 ? undefined : arguments[argIndex + 0]);
            argIndex += 1;
          } else {
            realArgs.push(arg);
          }
        }

        return fn.apply(undefined, realArgs);
      });
    } else {
      return fn.apply(undefined, args);
    }
  };
}, {
  "name": "partialise",
  "source": "(arity, fn) => (...args) => {\n  if (args.length < arity) {\n    throw new TypeError(`The partial function takes at least ${arity} arguments, but was given ${args.length}.`);\n  }\n\n  // Figure out if we have holes\n  let holes = 0;\n  for (let i = 0; i < args.length; ++i) {\n    if (args[i] === hole) {\n      holes += 1;\n    }\n  }\n\n\n  if (holes > 0) {\n    return partialise(holes, (...newArgs) => {\n      let realArgs = [];\n      let argIndex = 0;\n\n      for (let i = 0; i < args.length; ++i) {\n        const arg = args[i];\n        if (arg === hole) {\n          realArgs.push(newArgs[argIndex]);\n          argIndex += 1;\n        } else {\n          realArgs.push(arg);\n        }\n      }\n\n      return fn(...realArgs);\n    });\n  } else {\n    return fn(...args);\n  }\n}",
  "signature": "partialise(arity, fn)",
  "location": {
    "filename": "src/core/lambda/partialise.js",
    "start": {
      "line": 156,
      "column": 0
    },
    "end": {
      "line": 190,
      "column": 2
    }
  },
  "module": "folktale/src/core/lambda/partialise",
  "licence": "MIT",
  "authors": ["Quildreen Motta"],
  "repository": "https://github.com/origamitower/folktale",
  "npmPackage": "folktale",
  "since": "v2.0.0",
  "category": "Currying and Partialisation",
  "stability": "experimental",
  "throws": {
    "TypeError": "when the number of arguments given doesn't match the arity."
  },
  "type": "(Number, (Any... => Any)) => ((hole | Any)...) => Any :: (throw TypeError)\n",
  "documentation": "\nCreates a new function where some of the arguments are specified.\n\n\n## Example:\n\n    const clamp = (min, max, number) =>\n      number < min ?  min\n    : number > max ?  max\n    :                 number;\n\n    const _      = partialise.hole;\n    const clamp_ = partialise(3, clamp);\n\n    const atLeast = clamp_(_, Infinity, _);\n    const atMost  = clamp_(-Infinity, _, _);\n\n    atLeast(3, 2); // ==> 3\n    atLeast(3, 5); // ==> 5\n\n    atMost(5, 3);  // ==> 3\n    atMost(5, 10); // ==> 5\n\n\n## Why Partialisation\n\nWith higher-order programming, one often wants to specialise some of\nthe arguments of a function before passing it to another function.\nThis kind of configuration is often done by creating a new function\nmanually:\n\n    const plus = (a, b) => a + b;\n    const add5 = (x) => plus(5, x);\n\n    [1, 2, 3].map(add5);\n    // ==> [6, 7, 8]\n\nAnd for most cases this is reasonable. For functions that take more\nparameters, this can be cumbersome, however. The `partialise` function\nallows creating a new function by specialising some of the arguments,\nand filling the remaining ones when the function is called.\n\nPlaces where the caller of the function should fill are specified as\n`hole`, which is a special constant used by `partialise`:\n\n    const _ = partialise.hole;\n    const partialAdd5 = partialise(2, plus)(5, _);\n    [1, 2, 3].map(partialAdd5);\n    // ==> [6, 7, 8]\n\n\n## Relation to Currying\n\nPartial application and currying are related concepts. Currying\nrefers to transforming a function of arity N, into N functions of\narity 1. Partial application, on the other hand, refers to\nfixing some (but not all) arguments of a function.\n\nBoth concepts are used to improve function composition, where the\nshape of the function you have does not reflect the shape of the\nfunction expected by function you're calling. So, in essence, these\ntechniques transform the shape of your function to make them \"fit\"\nsome API.\n\n`partialise` and `curry` differ on how they achieve this, however.\nWhile `curry` creates N functions, and lets you specify arguments\none by one, `partialise` requires you to specify all arguments at\nonce, distinguishing which ones are fixed, and which ones have to\nbe provided (using \"holes\").\n\nBecause of this, `curry` can be more natural, but it requires that\nthe APIs be designed thinking about currying before hand, and it\noften interacts poorly with JavaScript, due to the use of variadic\nfunctions. `partialise` does not have such problems.\n\n\n## How `partialise` Works?\n\nThe `partialise` function transforms regular functions into\nfunctions that can accept holes for arguments that are not\ndefined yet. Whenever a partial function receives a hole as\nan argument, it constructs a new function so the holes can\nbe filled later:\n\n    const clamp = (min, max, number) =>\n      number < min ?  min\n    : number > max ?  max\n    :                 number\n\n    const partialClamp = partialise(3, clamp);\n\nIn the example above, `partialClamp` is a function that takes\narguments that may or may not be holes. A hole is a special\nconstant defined by `partialise` itself. It's convenient to\nbind such constant to the `_` binding:\n\n    const _ = partialise.hole;\n\nA partial function is considered saturated when, among the\narguments provided to it, no hole exists. When a partial function\nis saturated, its original behaviour is executed:\n\n    partialClamp(3, 5, 6);  // ==> 5\n\nIf a partial function is not saturated, then it its execution\nresults in a new partial function:\n\n    const atLeast = partialClamp(_, Infinity, _);\n    atLeast(5, 3); // ==> 5\n\n    const atLeast5 = atLeast(5, _);\n    atLeast5(3); // ==> 5\n\nNote that to prevent confusing behaviour, Folktale's `partialise`\nforces you to always pass the exact number of arguments that the\npartial function expects. Passing more or less arguments to a\npartial function is a TypeError. This ensures that all new partial\nfunctions can properly invoke the original behaviour when saturated,\nrather than returning previous unsaturated functions.\n\n\n## Drawbacks of Using `partialise`\n\n`partialise` is a convenience function for transforming the shape\nof functions, and it relies on variadic application, as well as\ndoing a fair bit of processing before each call to determine\nsaturation. Combined, these make `partialise` a poor choice for\nany code that needs to be performant.\n\n",
  "examples": [{
    "name": "",
    "call": __metamagical_withMeta(function () {}, {
      "source": ""
    }),
    "inferred": true
  }, {
    "name": "Example::",
    "call": __metamagical_withMeta(function () {
      var clamp = function clamp(min, max, number) {
        return number < min ? min : number > max ? max : number;
      };var _ = partialise.hole;var clamp_ = partialise(3, clamp);var atLeast = clamp_(_, Infinity, _);var atMost = clamp_(-Infinity, _, _);__metamagical_assert_equals(require("assert"), atLeast(3, 2), 3, "atLeast(3, 2) ==> 3");; // ==> 3
      __metamagical_assert_equals(require("assert"), atLeast(3, 5), 5, "atLeast(3, 5) ==> 5");; // ==> 5
      __metamagical_assert_equals(require("assert"), atMost(5, 3), 3, "atMost(5, 3) ==> 3");; // ==> 3
      __metamagical_assert_equals(require("assert"), atMost(5, 10), 5, "atMost(5, 10) ==> 5");; // ==> 5
    }, {
      "source": "const clamp = (min, max, number) =>\n  number < min ?  min\n: number > max ?  max\n:                 number;\n\nconst _      = partialise.hole;\nconst clamp_ = partialise(3, clamp);\n\nconst atLeast = clamp_(_, Infinity, _);\nconst atMost  = clamp_(-Infinity, _, _);\n\natLeast(3, 2); // ==> 3\natLeast(3, 5); // ==> 5\n\natMost(5, 3);  // ==> 3\natMost(5, 10); // ==> 5"
    }),
    "inferred": true
  }, {
    "name": "Why Partialisation",
    "call": __metamagical_withMeta(function () {
      var plus = function plus(a, b) {
        return a + b;
      };var add5 = function add5(x) {
        return plus(5, x);
      };__metamagical_assert_equals(require("assert"), [1, 2, 3].map(add5), [6, 7, 8], "[1, 2, 3].map(add5) ==> [6, 7, 8]");; // ==> [6, 7, 8]
      var _ = partialise.hole;var partialAdd5 = partialise(2, plus)(5, _);__metamagical_assert_equals(require("assert"), [1, 2, 3].map(partialAdd5), [6, 7, 8], "[1, 2, 3].map(partialAdd5) ==> [6, 7, 8]");; // ==> [6, 7, 8]
    }, {
      "source": "const plus = (a, b) => a + b;\nconst add5 = (x) => plus(5, x);\n\n[1, 2, 3].map(add5);\n// ==> [6, 7, 8]\n\nconst _ = partialise.hole;\nconst partialAdd5 = partialise(2, plus)(5, _);\n[1, 2, 3].map(partialAdd5);\n// ==> [6, 7, 8]"
    }),
    "inferred": true
  }, {
    "name": "Relation to Currying",
    "call": __metamagical_withMeta(function () {}, {
      "source": ""
    }),
    "inferred": true
  }, {
    "name": "How `partialise` Works?",
    "call": __metamagical_withMeta(function () {
      var clamp = function clamp(min, max, number) {
        return number < min ? min : number > max ? max : number;
      };var partialClamp = partialise(3, clamp);var _ = partialise.hole;__metamagical_assert_equals(require("assert"), partialClamp(3, 5, 6), 5, "partialClamp(3, 5, 6) ==> 5");; // ==> 5
      var atLeast = partialClamp(_, Infinity, _);__metamagical_assert_equals(require("assert"), atLeast(5, 3), 5, "atLeast(5, 3) ==> 5");; // ==> 5
      var atLeast5 = atLeast(5, _);__metamagical_assert_equals(require("assert"), atLeast5(3), 5, "atLeast5(3) ==> 5");; // ==> 5
    }, {
      "source": "const clamp = (min, max, number) =>\n  number < min ?  min\n: number > max ?  max\n:                 number\n\nconst partialClamp = partialise(3, clamp);\n\nconst _ = partialise.hole;\n\npartialClamp(3, 5, 6);  // ==> 5\n\nconst atLeast = partialClamp(_, Infinity, _);\natLeast(5, 3); // ==> 5\n\nconst atLeast5 = atLeast(5, _);\natLeast5(3); // ==> 5"
    }),
    "inferred": true
  }]
});

// ---[ Special Values ]-----------------------------------------------
/*~
 * Represents a place in an argument list that needs to be filled.
 * 
 * ---
 * category: Special Values
 */
partialise.hole = __metamagical_withMeta(hole, {
  "name": "hole",
  "source": "hole",
  "belongsTo": function belongsTo() {
    return partialise;
  },
  "category": "Special Values",
  "documentation": "\nRepresents a place in an argument list that needs to be filled.\n"
});

// --[ Exports ]-------------------------------------------------------
module.exports = partialise;
},{"assert":54}],24:[function(require,module,exports){
"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var __metamagical_withMeta = function metamagical_withMeta(object, meta) {
  var parent = Object.getPrototypeOf(object);var oldMeta = object[Symbol.for('@@meta:magical')] || {};if (parent && parent[Symbol.for('@@meta:magical')] === oldMeta) {
    oldMeta = {};
  }Object.keys(meta).forEach(function (key) {
    if (/^~/.test(key)) {
      oldMeta[key.slice(1)] = meta[key];
    } else {
      oldMeta[key] = meta[key];
    }
  });object[Symbol.for('@@meta:magical')] = oldMeta;return object;
},
    __metamagical_assert_equals = function metamagical_assert_equals(assert, actual, expected, message) {
  var assertionType = Symbol.for('@@meta:magical:assertion-type');
  var rest = Symbol.for('@@meta:magical:assertion-rest');var keys = Object.keys;function isSetoid(value) {
    return value && typeof value.equals === 'function';
  }function isRecord(value) {
    return value && value[assertionType] === 'record';
  }function check(predicate) {
    for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }return values.every(predicate);
  }function getSpecialArrayLength(array) {
    var rests = array.map(function (x, i) {
      return [x, i];
    }).filter(function (pair) {
      return pair[0] === rest;
    });if (rests.length > 1 || rests[0] && rests[0][1] !== array.length - 1) {
      assert.ok(false, message + '. Assertions only support a single trailing rest indication for arrays currently.');
    }return (rests[0] || [null, array.length])[1];
  }function compareArrays(left, right) {
    var expectedLength = getSpecialArrayLength(right);assert.ok(Array.isArray(left), message + '. The LHS is not an array.');if (left.length < expectedLength) {
      assert.ok(false, message + '. The LHS does not have the minimum expected length (' + left.length + ' < ' + expectedLength + ')');
    }for (var i = 0; i < expectedLength; ++i) {
      compare(left[i], right[i]);
    }
  }
  function compareRecord(left, right) {
    var isPartial = right[rest];assert.ok(Object(left) === left, message);if (!isPartial) {
      assert.deepStrictEqual(keys(left).sort(), keys(right).sort(), message + '. The objects have different keys ([' + keys(left).sort().join(', ') + '] vs. [' + keys(right).sort().join(', ') + '])');
    }Object.keys(right).forEach(function (key) {
      if (!(key in left)) {
        assert.ok(false, message + '. The expected key ' + key + ' is not present in the actual object.');
      }compare(left[key], right[key]);
    });
  }function compare(l, r) {
    return check(isSetoid, l, r) ? assert.ok(l.equals(r), message + '. The LHS (' + l + ') setoid instance says the LHS and RHS (' + r + ') are not equal.') : Array.isArray(r) ? compareArrays(l, r) : isRecord(r) ? compareRecord(l, r) : /* otherwise */assert.deepStrictEqual(l, r, message + '. The LHS (' + l + ') and the RHS (' + r + ') are not structually equal.');
  }compare(actual, expected);
};

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

//---------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//---------------------------------------------------------------------

var define = Object.defineProperty;

/*~
 * Constructs an object from an array of (key, value) pairs.
 *
 *  The resulting object is a plain JavaScript object, inheriting from
 * `Object.prototype`.
 *
 * The pairs are added to the object with `Object.defineProperty`, so no setters
 * defined in `Object.prototype` will be triggered during the process. All
 * properties are enumerable, writable, and configurable.
 * 
 * 
 * ## Example::
 * 
 *     fromPairs([['x', 10], ['y', 20]]);
 *     // ==> { x: 10, y: 20 }
 *
 * 
 * ## Caveats
 *
 * Properties are inserted in the object in the same order of the array. In an
 * ECMAScript 2015-compliant engine this means that the following equivalence
 * holds:
 *
 *     Object.keys(fromPairs(xs)) === xs.map(([k, v]) => k)
 * 
 * However, in engines that don't conform to ECMAScript 2015, this equivalence
 * is not guaranteed.
 *
 * ---
 * category    : Converting
 * stability   : stable
 * 
 * authors:
 *   - Quildreen Motta
 *
 * complexity : O(n), n is the length of the array
 * type: |
 *   (Array (String or Symbol, 'a)) => Object 'a
 */
var fromPairs = __metamagical_withMeta(function (pairs) {
  return pairs.reduce(function (r, _ref) {
    var _ref2 = _slicedToArray(_ref, 2);

    var k = _ref2[0];
    var v = _ref2[1];
    return define(r, k, { value: v, writable: true,
      enumerable: true,
      configurable: true
    });
  }, {});
}, {
  "name": "fromPairs",
  "source": "(pairs) =>\n        pairs.reduce((r, [k, v]) => define(r, k, { value: v,\n                                                   writable: true,\n                                                   enumerable: true,\n                                                   configurable: true\n                                                  }),\n                     {})",
  "signature": "fromPairs(pairs)",
  "location": {
    "filename": "src/core/object/from-pairs.js",
    "start": {
      "line": 52,
      "column": 0
    },
    "end": {
      "line": 58,
      "column": 25
    }
  },
  "module": "folktale/src/core/object/from-pairs",
  "licence": "MIT",
  "authors": ["Quildreen Motta"],
  "repository": "https://github.com/origamitower/folktale",
  "npmPackage": "folktale",
  "category": "Converting",
  "stability": "stable",
  "complexity": "O(n), n is the length of the array",
  "type": "(Array (String or Symbol, 'a)) => Object 'a\n",
  "documentation": "\nConstructs an object from an array of (key, value) pairs.\n\n The resulting object is a plain JavaScript object, inheriting from\n`Object.prototype`.\n\nThe pairs are added to the object with `Object.defineProperty`, so no setters\ndefined in `Object.prototype` will be triggered during the process. All\nproperties are enumerable, writable, and configurable.\n\n\n## Example:\n\n    fromPairs([['x', 10], ['y', 20]]);\n    // ==> { x: 10, y: 20 }\n\n\n## Caveats\n\nProperties are inserted in the object in the same order of the array. In an\nECMAScript 2015-compliant engine this means that the following equivalence\nholds:\n\n    Object.keys(fromPairs(xs)) === xs.map(([k, v]) => k)\n\nHowever, in engines that don't conform to ECMAScript 2015, this equivalence\nis not guaranteed.\n",
  "examples": [{
    "name": "",
    "call": __metamagical_withMeta(function () {}, {
      "source": ""
    }),
    "inferred": true
  }, {
    "name": "Example::",
    "call": __metamagical_withMeta(function () {
      __metamagical_assert_equals(require("assert"), fromPairs([['x', 10], ['y', 20]]), _defineProperty({ x: 10, y: 20 }, Symbol.for("@@meta:magical:assertion-type"), "record"), "fromPairs([['x', 10], ['y', 20]]) ==> { x: 10, y: 20 }");; // ==> { x: 10, y: 20 }
    }, {
      "source": "fromPairs([['x', 10], ['y', 20]]);\n// ==> { x: 10, y: 20 }"
    }),
    "inferred": true
  }]
});

// --[ Exports ]-------------------------------------------------------
module.exports = fromPairs;
},{"assert":54}],25:[function(require,module,exports){
'use strict';

var __metamagical_withMeta = function metamagical_withMeta(object, meta) {
  var parent = Object.getPrototypeOf(object);var oldMeta = object[Symbol.for('@@meta:magical')] || {};if (parent && parent[Symbol.for('@@meta:magical')] === oldMeta) {
    oldMeta = {};
  }Object.keys(meta).forEach(function (key) {
    if (/^~/.test(key)) {
      oldMeta[key.slice(1)] = meta[key];
    } else {
      oldMeta[key] = meta[key];
    }
  });object[Symbol.for('@@meta:magical')] = oldMeta;return object;
};

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

/*~
 * Core.Object provides utilities for working with objects as
 * dictionaries and records.
 *
 * 
 * ## Why?
 *
 * JS historically lacked data structures designed specifically for
 * representing records and dictionaries, and objects just doubled
 * as those for the common use cases. While JS has added Map and
 * Set structures natively, using objects as records and dictionaries
 * is still common place, and there aren't many tools to use them
 * for those use cases natively.
 * 
 * For example, these objects are used as options for configuring
 * operations, like babylon's `parse` operation, or Node's `readFile`.
 * They're used to represent headers in most HTTP libraries, or to
 * represent environment variables in Node, etc.
 * 
 * Folktale's Core.Object primarily aims to provide common tools for
 * using objects as dictionaries. In doing so, most of the operations
 * in this module are only concerned about own, enumerable properties,
 * and don't respect the original object's shape. That is, a
 * transformation such as:
 * 
 *     toPairs(fromPairs(object))
 * 
 * Doesn't return a value necessarily equivalent to `object`. Because
 * all transformations are pure, objects get a new identity, they also
 * lose all symbols and non-enumerable properties, as well as the
 * `[[Prototype]]` field.
 * 
 * 
 * ## What's in Core.Object?
 * 
 * Currently Core.Object provides operations for converting from and to
 * objects, and transforming objects. These operations are categorised
 * as follows:
 * 
 *   - **Converting**: Operations that convert the data in the object
 *     to other types.
 * 
 *   - **Transforming**: Operations that transform the data in the
 *     object, giving you a new object.
 *
 * ---
 * name     : module folktale/core/object
 * category : Utilities for Native Objects
 */
module.exports = __metamagical_withMeta({
  mapEntries: require('./map-entries'),
  mapValues: require('./map-values'),
  values: require('./values'),
  toPairs: require('./to-pairs'),
  fromPairs: require('./from-pairs')
}, {
  'name': 'module folktale/core/object',
  'source': '{\n  mapEntries: require(\'./map-entries\'),\n  mapValues: require(\'./map-values\'),\n  values: require(\'./values\'),\n  toPairs: require(\'./to-pairs\'),\n  fromPairs: require(\'./from-pairs\')\n}',
  'location': {
    'filename': 'src/core/object/index.js',
    'start': {
      'line': 59,
      'column': 0
    },
    'end': {
      'line': 65,
      'column': 2
    }
  },
  'module': 'folktale/src/core/object',
  'licence': 'MIT',
  'authors': ['Quildreen Motta'],
  'repository': 'https://github.com/origamitower/folktale',
  'npmPackage': 'folktale',
  'isModule': true,
  'category': 'Utilities for Native Objects',
  'documentation': '\nCore.Object provides utilities for working with objects as\ndictionaries and records.\n\n\n## Why?\n\nJS historically lacked data structures designed specifically for\nrepresenting records and dictionaries, and objects just doubled\nas those for the common use cases. While JS has added Map and\nSet structures natively, using objects as records and dictionaries\nis still common place, and there aren\'t many tools to use them\nfor those use cases natively.\n\nFor example, these objects are used as options for configuring\noperations, like babylon\'s `parse` operation, or Node\'s `readFile`.\nThey\'re used to represent headers in most HTTP libraries, or to\nrepresent environment variables in Node, etc.\n\nFolktale\'s Core.Object primarily aims to provide common tools for\nusing objects as dictionaries. In doing so, most of the operations\nin this module are only concerned about own, enumerable properties,\nand don\'t respect the original object\'s shape. That is, a\ntransformation such as:\n\n    toPairs(fromPairs(object))\n\nDoesn\'t return a value necessarily equivalent to `object`. Because\nall transformations are pure, objects get a new identity, they also\nlose all symbols and non-enumerable properties, as well as the\n`[[Prototype]]` field.\n\n\n## What\'s in Core.Object?\n\nCurrently Core.Object provides operations for converting from and to\nobjects, and transforming objects. These operations are categorised\nas follows:\n\n  - **Converting**: Operations that convert the data in the object\n    to other types.\n\n  - **Transforming**: Operations that transform the data in the\n    object, giving you a new object.\n',
  'examples': [{
    'name': '',
    'call': __metamagical_withMeta(function () {}, {
      'source': ''
    }),
    'inferred': true
  }, {
    'name': 'Why?',
    'call': __metamagical_withMeta(function () {}, {
      'source': ''
    }),
    'inferred': true
  }]
});
},{"./from-pairs":24,"./map-entries":26,"./map-values":27,"./to-pairs":28,"./values":29}],26:[function(require,module,exports){
"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var __metamagical_withMeta = function metamagical_withMeta(object, meta) {
  var parent = Object.getPrototypeOf(object);var oldMeta = object[Symbol.for('@@meta:magical')] || {};if (parent && parent[Symbol.for('@@meta:magical')] === oldMeta) {
    oldMeta = {};
  }Object.keys(meta).forEach(function (key) {
    if (/^~/.test(key)) {
      oldMeta[key.slice(1)] = meta[key];
    } else {
      oldMeta[key] = meta[key];
    }
  });object[Symbol.for('@@meta:magical')] = oldMeta;return object;
},
    __metamagical_assert_equals = function metamagical_assert_equals(assert, actual, expected, message) {
  var assertionType = Symbol.for('@@meta:magical:assertion-type');var rest = Symbol.for('@@meta:magical:assertion-rest');var keys = Object.keys;function isSetoid(value) {
    return value && typeof value.equals === 'function';
  }function isRecord(value) {
    return value && value[assertionType] === 'record';
  }function check(predicate) {
    for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }return values.every(predicate);
  }function getSpecialArrayLength(array) {
    var rests = array.map(function (x, i) {
      return [x, i];
    }).filter(function (pair) {
      return pair[0] === rest;
    });if (rests.length > 1 || rests[0] && rests[0][1] !== array.length - 1) {
      assert.ok(false, message + '. Assertions only support a single trailing rest indication for arrays currently.');
    }return (rests[0] || [null, array.length])[1];
  }function compareArrays(left, right) {
    var expectedLength = getSpecialArrayLength(right);assert.ok(Array.isArray(left), message + '. The LHS is not an array.');if (left.length < expectedLength) {
      assert.ok(false, message + '. The LHS does not have the minimum expected length (' + left.length + ' < ' + expectedLength + ')');
    }for (var i = 0; i < expectedLength; ++i) {
      compare(left[i], right[i]);
    }
  }function compareRecord(left, right) {
    var isPartial = right[rest];assert.ok(Object(left) === left, message);if (!isPartial) {
      assert.deepStrictEqual(keys(left).sort(), keys(right).sort(), message + '. The objects have different keys ([' + keys(left).sort().join(', ') + '] vs. [' + keys(right).sort().join(', ') + '])');
    }Object.keys(right).forEach(function (key) {
      if (!(key in left)) {
        assert.ok(false, message + '. The expected key ' + key + ' is not present in the actual object.');
      }compare(left[key], right[key]);
    });
  }function compare(l, r) {
    return check(isSetoid, l, r) ? assert.ok(l.equals(r), message + '. The LHS (' + l + ') setoid instance says the LHS and RHS (' + r + ') are not equal.') : Array.isArray(r) ? compareArrays(l, r) : isRecord(r) ? compareRecord(l, r) : /* otherwise */assert.deepStrictEqual(l, r, message + '. The LHS (' + l + ') and the RHS (' + r + ') are not structually equal.');
  }compare(actual, expected);
};

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

var hasOwnProperty = Object.prototype.hasOwnProperty;

/*~
 * Transforms own properties of an object using a mapping function.
 *
 * The transformation takes a `[key, value]` pair, and is expected to return
 * a new `[key, value]` pair. The resulting object has not only its values
 * transformed, but also its keys.
 * 
 * 
 * ## Example::
 *
 *     const pair = { x: 10, y: 20 };
 *     mapEntries(
 *       pair,
 *       ([key, value]) => [key.toUpperCase(), value * 2],
 *       (result, key, value) => {
 *         result[key] = value;
 *         return result;
 *       }
 *     );
 *     // ==> { X: 20, Y: 40 }
 *
 * 
 * ## Handling collisions
 * 
 * Since the mapping function returns a `[key, value]` pair, it's possible
 * that some of the returned keys collide with another. Since there's no
 * single answer that is correct for all cases when handling these collisions,
 * mapEntries expects an additional function that's used to define the 
 * properties in the resulting object, and this function is expected to
 * deal with the collisions.
 * 
 * A definition function takes the result object, a property name, and
 * a value, and is expected to return a new object containing the provided
 * key/value pair, if it can be attached to the result object. This function
 * may mutate the object, but pure functions are also supported.
 * 
 * Specialised forms of this function exist to cover common cases.
 * `mapEntries.overwrite` will have later key/value pairs overwrite earlier
 * ones with the same key, while `mapEntries.unique` will throw whenever
 * a collision happens.
 * 
 * 
 * ## Caveats
 *  
 * `mapEntries` will not preserve the shape of the original object.
 * It treats objects as plain maps from String to some value. It ignores
 * things like prototypical delegation, symbols, and non-enumerable
 * properties.
 *
 * ---
 * category    : Transforming
 * stability   : stable
 * authors:
 *   - Quildreen Motta
 *
 * complexity : O(n), n is the number of own enumerable properties
 * type: |
 *   (
 *     object    : Object 'a,
 *     transform : ((String, 'a)) => (String, 'b),
 *     define    : (('x : Object 'b), String, 'b) => Object 'b :: mutates 'x
 *   ) => Object 'b
 */
var mapEntries = __metamagical_withMeta(function (object, transform, define) {
  return Object.keys(object).reduce(function (result, key) {
    var _transform = transform([key, object[key]]);

    var _transform2 = _slicedToArray(_transform, 2);

    var newKey = _transform2[0];
    var newValue = _transform2[1];

    return define(result, newKey, newValue);
  }, {});
}, {
  "name": "mapEntries",
  "source": "(object, transform, define) =>\n        Object.keys(object).reduce((result, key) => {\n          const [newKey, newValue] = transform([key, object[key]]);\n          return define(result, newKey, newValue);\n        }, {})",
  "signature": "mapEntries(object, transform, define)",
  "location": {
    "filename": "src/core/object/map-entries.js",
    "start": {
      "line": 75,
      "column": 0
    },
    "end": {
      "line": 79,
      "column": 15
    }
  },
  "module": "folktale/src/core/object/map-entries",
  "licence": "MIT",
  "authors": ["Quildreen Motta"],
  "repository": "https://github.com/origamitower/folktale",
  "npmPackage": "folktale",
  "category": "Transforming",
  "stability": "stable",
  "complexity": "O(n), n is the number of own enumerable properties",
  "type": "(\n  object    : Object 'a,\n  transform : ((String, 'a)) => (String, 'b),\n  define    : (('x : Object 'b), String, 'b) => Object 'b :: mutates 'x\n) => Object 'b\n",
  "documentation": "\nTransforms own properties of an object using a mapping function.\n\nThe transformation takes a `[key, value]` pair, and is expected to return\na new `[key, value]` pair. The resulting object has not only its values\ntransformed, but also its keys.\n\n\n## Example:\n\n    const pair = { x: 10, y: 20 };\n    mapEntries(\n      pair,\n      ([key, value]) => [key.toUpperCase(), value * 2],\n      (result, key, value) => {\n        result[key] = value;\n        return result;\n      }\n    );\n    // ==> { X: 20, Y: 40 }\n\n\n## Handling collisions\n\nSince the mapping function returns a `[key, value]` pair, it's possible\nthat some of the returned keys collide with another. Since there's no\nsingle answer that is correct for all cases when handling these collisions,\nmapEntries expects an additional function that's used to define the \nproperties in the resulting object, and this function is expected to\ndeal with the collisions.\n\nA definition function takes the result object, a property name, and\na value, and is expected to return a new object containing the provided\nkey/value pair, if it can be attached to the result object. This function\nmay mutate the object, but pure functions are also supported.\n\nSpecialised forms of this function exist to cover common cases.\n`mapEntries.overwrite` will have later key/value pairs overwrite earlier\nones with the same key, while `mapEntries.unique` will throw whenever\na collision happens.\n\n\n## Caveats\n \n`mapEntries` will not preserve the shape of the original object.\nIt treats objects as plain maps from String to some value. It ignores\nthings like prototypical delegation, symbols, and non-enumerable\nproperties.\n",
  "examples": [{
    "name": "",
    "call": __metamagical_withMeta(function () {}, {
      "source": ""
    }),
    "inferred": true
  }, {
    "name": "Example::",
    "call": __metamagical_withMeta(function () {
      var pair = { x: 10, y: 20 };__metamagical_assert_equals(require("assert"), mapEntries(pair, function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2);

        var key = _ref2[0];
        var value = _ref2[1];
        return [key.toUpperCase(), value * 2];
      }, function (result, key, value) {
        result[key] = value;return result;
      }), _defineProperty({ X: 20, Y: 40 }, Symbol.for("@@meta:magical:assertion-type"), "record"), "mapEntries(pair, ([key, value]) => [key.toUpperCase(), value * 2], (result, key, value) => {\n  result[key] = value;\n  return result;\n}) ==> { X: 20, Y: 40 }");; // ==> { X: 20, Y: 40 }
    }, {
      "source": "const pair = { x: 10, y: 20 };\nmapEntries(\n  pair,\n  ([key, value]) => [key.toUpperCase(), value * 2],\n  (result, key, value) => {\n    result[key] = value;\n    return result;\n  }\n);\n// ==> { X: 20, Y: 40 }"
    }),
    "inferred": true
  }, {
    "name": "Handling collisions",
    "call": __metamagical_withMeta(function () {}, {
      "source": ""
    }),
    "inferred": true
  }]
});

// --[ Convenience ]---------------------------------------------------
/*~
 * Transforms own properties of an object using a mapping function.
 *
 * This function is a specialised form of `mapEntries` that overwrites
 * duplicated keys when a collision happens. 
 * 
 * 
 * ## Caveats
 * 
 * Because this function takes an object and maps over it, the result of a
 * transformation where keys collide is not defined in ECMAScript 5 and older,
 * as those engines don't define an ordering for key/value pairs in objects.
 * In ECMAScript 2015 properties that were inserted later will win over
 * properties that were inserted earlier.
 *
 * ---
 * category  : Transforming
 * stability : stable
 * authors:
 *   - Quildreen Motta
 *
 * complexity : O(n), n is the number of own enumerable properties
 * type: |
 *   (Object 'a, ((String, 'a)) => (String, 'b)) => Object 'b
 */
mapEntries.overwrite = __metamagical_withMeta(function (object, transform) {
  return mapEntries(object, transform, function (result, key, value) {
    result[key] = value;
    return result;
  });
}, {
  "name": "overwrite",
  "source": "(object, transform) =>\n  mapEntries(object, transform, (result, key, value) => {\n    result[key] = value;\n    return result;\n  })",
  "signature": "overwrite(object, transform)",
  "belongsTo": function belongsTo() {
    return mapEntries;
  },
  "category": "Transforming",
  "stability": "stable",
  "authors": ["Quildreen Motta"],
  "complexity": "O(n), n is the number of own enumerable properties",
  "type": "(Object 'a, ((String, 'a)) => (String, 'b)) => Object 'b\n",
  "documentation": "\nTransforms own properties of an object using a mapping function.\n\nThis function is a specialised form of `mapEntries` that overwrites\nduplicated keys when a collision happens. \n\n\n## Caveats\n\nBecause this function takes an object and maps over it, the result of a\ntransformation where keys collide is not defined in ECMAScript 5 and older,\nas those engines don't define an ordering for key/value pairs in objects.\nIn ECMAScript 2015 properties that were inserted later will win over\nproperties that were inserted earlier.\n",
  "examples": [{
    "name": "",
    "call": __metamagical_withMeta(function () {}, {
      "source": ""
    }),
    "inferred": true
  }]
});

/*~
 * Transforms own properties of an object using a mapping function.
 *
 * This function is a specialised form of `mapEntries` that throws
 * when a key collision happens. Throwing makes this function potentially
 * unsafe to use, however it guarantees a consistent behaviour across
 * different ECMAScript versions and VMs.
 *
 * ---
 * category  : Transforming
 * stability : stable
 * authors:
 *   - Quildreen Motta
 *
 * throws:
 *   Error: when the transform returns duplicate property names.
 *
 * complexity : O(n), n is the number of own enumerable properties
 * type: |
 *   (Object 'a, ((String, 'a)) => (String, 'b)) => Object 'b :: throws Error
 */
mapEntries.unique = __metamagical_withMeta(function (object, transform) {
  return mapEntries(object, transform, function (result, key, value) {
    if (hasOwnProperty.call(result, key)) {
      throw new Error("The property " + key + " already exists in the resulting object.");
    }
    result[key] = value;
    return result;
  });
}, {
  "name": "unique",
  "source": "(object, transform) =>\n  mapEntries(object, transform, (result, key, value) => {\n    if (result::hasOwnProperty(key)) {\n      throw new Error(`The property ${key} already exists in the resulting object.`);\n    }\n    result[key] = value;\n    return result;\n  })",
  "signature": "unique(object, transform)",
  "belongsTo": function belongsTo() {
    return mapEntries;
  },
  "category": "Transforming",
  "stability": "stable",
  "authors": ["Quildreen Motta"],
  "throws": {
    "Error": "when the transform returns duplicate property names."
  },
  "complexity": "O(n), n is the number of own enumerable properties",
  "type": "(Object 'a, ((String, 'a)) => (String, 'b)) => Object 'b :: throws Error\n",
  "documentation": "\nTransforms own properties of an object using a mapping function.\n\nThis function is a specialised form of `mapEntries` that throws\nwhen a key collision happens. Throwing makes this function potentially\nunsafe to use, however it guarantees a consistent behaviour across\ndifferent ECMAScript versions and VMs.\n"
});

// --[ Exports ]-------------------------------------------------------
module.exports = mapEntries;
},{"assert":54}],27:[function(require,module,exports){
"use strict";

var __metamagical_withMeta = function metamagical_withMeta(object, meta) {
  var parent = Object.getPrototypeOf(object);var oldMeta = object[Symbol.for('@@meta:magical')] || {};if (parent && parent[Symbol.for('@@meta:magical')] === oldMeta) {
    oldMeta = {};
  }Object.keys(meta).forEach(function (key) {
    if (/^~/.test(key)) {
      oldMeta[key.slice(1)] = meta[key];
    } else {
      oldMeta[key] = meta[key];
    }
  });object[Symbol.for('@@meta:magical')] = oldMeta;return object;
},
    __metamagical_assert_equals = function metamagical_assert_equals(assert, actual, expected, message) {
  var assertionType = Symbol.for('@@meta:magical:assertion-type');
  var rest = Symbol.for('@@meta:magical:assertion-rest');var keys = Object.keys;function isSetoid(value) {
    return value && typeof value.equals === 'function';
  }function isRecord(value) {
    return value && value[assertionType] === 'record';
  }function check(predicate) {
    for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }return values.every(predicate);
  }function getSpecialArrayLength(array) {
    var rests = array.map(function (x, i) {
      return [x, i];
    }).filter(function (pair) {
      return pair[0] === rest;
    });if (rests.length > 1 || rests[0] && rests[0][1] !== array.length - 1) {
      assert.ok(false, message + '. Assertions only support a single trailing rest indication for arrays currently.');
    }return (rests[0] || [null, array.length])[1];
  }function compareArrays(left, right) {
    var expectedLength = getSpecialArrayLength(right);assert.ok(Array.isArray(left), message + '. The LHS is not an array.');if (left.length < expectedLength) {
      assert.ok(false, message + '. The LHS does not have the minimum expected length (' + left.length + ' < ' + expectedLength + ')');
    }for (var i = 0; i < expectedLength; ++i) {
      compare(left[i], right[i]);
    }
  }function compareRecord(left, right) {
    var isPartial = right[rest];assert.ok(Object(left) === left, message);if (!isPartial) {
      assert.deepStrictEqual(keys(left).sort(), keys(right).sort(), message + '. The objects have different keys ([' + keys(left).sort().join(', ') + '] vs. [' + keys(right).sort().join(', ') + '])');
    }Object.keys(right).forEach(function (key) {
      if (!(key in left)) {
        assert.ok(false, message + '. The expected key ' + key + ' is not present in the actual object.');
      }compare(left[key], right[key]);
    });
  }function compare(l, r) {
    return check(isSetoid, l, r) ? assert.ok(l.equals(r), message + '. The LHS (' + l + ') setoid instance says the LHS and RHS (' + r + ') are not equal.') : Array.isArray(r) ? compareArrays(l, r) : isRecord(r) ? compareRecord(l, r) : /* otherwise */assert.deepStrictEqual(l, r, message + '. The LHS (' + l + ') and the RHS (' + r + ') are not structually equal.');
  }compare(actual, expected);
};

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

//---------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//---------------------------------------------------------------------

/*~
 * Transforms values of an object with an unary function.
 *
 * The transformation works on the values of each own, enumerable
 * property of the given object. Inherited and non-enumerable
 * properties are ignored by this function.
 * 
 * 
 * ## Example::
 *
 *     const pair = { x: 10, y: 20 };
 *     mapValues(pair, x => x * 2);
 *     // ==> { x: 20, y: 40 }
 *
 * 
 * ## Caveats
 * 
 * `mapValues` will not preserve the shape of the original object.
 * It treats objects as plain maps from String to some value, and
 * ignores things like prototypical delegation, symbols, and non-enumerable
 * properties.
 *
 * ---
 * category  : Transforming
 * stability : stable
 * authors:
 *   - Quildreen Motta
 *
 * complexity: O(n), n is the number of own enumerable properties.
 * type: |
 *   (Object 'a, ('a) => 'b) => Object 'b
 */
var mapValues = __metamagical_withMeta(function (object, transformation) {
  var keys = Object.keys(object);
  var result = {};

  for (var i = 0; i < keys.length; ++i) {
    var key = keys[i];
    result[key] = transformation(object[key]);
  }

  return result;
}, {
  "name": "mapValues",
  "source": "(object, transformation) => {\n  const keys = Object.keys(object);\n  const result = {};\n\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    result[key] = transformation(object[key]);\n  }\n\n  return result;\n}",
  "signature": "mapValues(object, transformation)",
  "location": {
    "filename": "src/core/object/map-values.js",
    "start": {
      "line": 42,
      "column": 0
    },
    "end": {
      "line": 52,
      "column": 2
    }
  },
  "module": "folktale/src/core/object/map-values",
  "licence": "MIT",
  "authors": ["Quildreen Motta"],
  "repository": "https://github.com/origamitower/folktale",
  "npmPackage": "folktale",
  "category": "Transforming",
  "stability": "stable",
  "complexity": "O(n), n is the number of own enumerable properties.",
  "type": "(Object 'a, ('a) => 'b) => Object 'b\n",
  "documentation": "\nTransforms values of an object with an unary function.\n\nThe transformation works on the values of each own, enumerable\nproperty of the given object. Inherited and non-enumerable\nproperties are ignored by this function.\n\n\n## Example:\n\n    const pair = { x: 10, y: 20 };\n    mapValues(pair, x => x * 2);\n    // ==> { x: 20, y: 40 }\n\n\n## Caveats\n\n`mapValues` will not preserve the shape of the original object.\nIt treats objects as plain maps from String to some value, and\nignores things like prototypical delegation, symbols, and non-enumerable\nproperties.\n",
  "examples": [{
    "name": "",
    "call": __metamagical_withMeta(function () {}, {
      "source": ""
    }),
    "inferred": true
  }, {
    "name": "Example::",
    "call": __metamagical_withMeta(function () {
      var pair = { x: 10, y: 20 };__metamagical_assert_equals(require("assert"), mapValues(pair, function (x) {
        return x * 2;
      }), _defineProperty({ x: 20, y: 40 }, Symbol.for("@@meta:magical:assertion-type"), "record"), "mapValues(pair, x => x * 2) ==> { x: 20, y: 40 }");; // ==> { x: 20, y: 40 }
    }, {
      "source": "const pair = { x: 10, y: 20 };\nmapValues(pair, x => x * 2);\n// ==> { x: 20, y: 40 }"
    }),
    "inferred": true
  }]
});

// --[ Convenience ]---------------------------------------------------

/*~
 * Conveniently transforms values in an object using the This-Binding syntax.
 * 
 * This is a free-method version of `mapValues` that applies the `this`
 * argument first, then the function it takes as argument. It's meant to
 * be used with the [This-Binding Syntax][es-bind] proposal::
 * 
 *     const map = mapValues.infix;
 *     const pair = { x: 10, y: 20 };
 *     pair::map(x => x * 2);
 *     // ==> { x: 20, y: 40 }
 * 
 * [es-bind]: https://github.com/zenparsing/es-function-bind
 * 
 * ---
 * category  : Convenience
 * stability : experimental
 * authors:
 *   - Quildreen Motta
 * 
 * complexity: O(n), n is the number of own enumerable properties.
 * type: |
 *   (Object 'a) . (('a) => 'b) => Object 'b
 */
mapValues.infix = __metamagical_withMeta(function (transformation) {
  return mapValues(this, transformation);
}, {
  "name": "infix",
  "source": "function(transformation) {\n  return mapValues(this, transformation);\n}",
  "signature": "infix(transformation)",
  "belongsTo": function belongsTo() {
    return mapValues;
  },
  "category": "Convenience",
  "stability": "experimental",
  "authors": ["Quildreen Motta"],
  "complexity": "O(n), n is the number of own enumerable properties.",
  "type": "(Object 'a) . (('a) => 'b) => Object 'b\n",
  "documentation": "\nConveniently transforms values in an object using the This-Binding syntax.\n\nThis is a free-method version of `mapValues` that applies the `this`\nargument first, then the function it takes as argument. It's meant to\nbe used with the [This-Binding Syntax][es-bind] proposal:\n\n    const map = mapValues.infix;\n    const pair = { x: 10, y: 20 };\n    pair::map(x => x * 2);\n    // ==> { x: 20, y: 40 }\n\n[es-bind]: https://github.com/zenparsing/es-function-bind\n",
  "examples": [{
    "name": "",
    "call": __metamagical_withMeta(function () {
      var map = mapValues.infix;var pair = { x: 10, y: 20 };__metamagical_assert_equals(require("assert"), map.call(pair, function (x) {
        return x * 2;
      }), _defineProperty({ x: 20, y: 40 }, Symbol.for("@@meta:magical:assertion-type"), "record"), "pair::map(x => x * 2) ==> { x: 20, y: 40 }");; // ==> { x: 20, y: 40 }
    }, {
      "source": "const map = mapValues.infix;\nconst pair = { x: 10, y: 20 };\npair::map(x => x * 2);\n// ==> { x: 20, y: 40 }"
    }),
    "inferred": true
  }]
});

// --[ Exports ]-------------------------------------------------------
module.exports = mapValues;
},{"assert":54}],28:[function(require,module,exports){
"use strict";

var __metamagical_withMeta = function metamagical_withMeta(object, meta) {
  var parent = Object.getPrototypeOf(object);var oldMeta = object[Symbol.for('@@meta:magical')] || {};if (parent && parent[Symbol.for('@@meta:magical')] === oldMeta) {
    oldMeta = {};
  }Object.keys(meta).forEach(function (key) {
    if (/^~/.test(key)) {
      oldMeta[key.slice(1)] = meta[key];
    } else {
      oldMeta[key] = meta[key];
    }
  });object[Symbol.for('@@meta:magical')] = oldMeta;return object;
},
    __metamagical_assert_equals = function metamagical_assert_equals(assert, actual, expected, message) {
  var assertionType = Symbol.for('@@meta:magical:assertion-type');var rest = Symbol.for('@@meta:magical:assertion-rest');var keys = Object.keys;function isSetoid(value) {
    return value && typeof value.equals === 'function';
  }function isRecord(value) {
    return value && value[assertionType] === 'record';
  }function check(predicate) {
    for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }return values.every(predicate);
  }function getSpecialArrayLength(array) {
    var rests = array.map(function (x, i) {
      return [x, i];
    }).filter(function (pair) {
      return pair[0] === rest;
    });if (rests.length > 1 || rests[0] && rests[0][1] !== array.length - 1) {
      assert.ok(false, message + '. Assertions only support a single trailing rest indication for arrays currently.');
    }return (rests[0] || [null, array.length])[1];
  }function compareArrays(left, right) {
    var expectedLength = getSpecialArrayLength(right);assert.ok(Array.isArray(left), message + '. The LHS is not an array.');if (left.length < expectedLength) {
      assert.ok(false, message + '. The LHS does not have the minimum expected length (' + left.length + ' < ' + expectedLength + ')');
    }for (var i = 0; i < expectedLength; ++i) {
      compare(left[i], right[i]);
    }
  }function compareRecord(left, right) {
    var isPartial = right[rest];assert.ok(Object(left) === left, message);if (!isPartial) {
      assert.deepStrictEqual(keys(left).sort(), keys(right).sort(), message + '. The objects have different keys ([' + keys(left).sort().join(', ') + '] vs. [' + keys(right).sort().join(', ') + '])');
    }Object.keys(right).forEach(function (key) {
      if (!(key in left)) {
        assert.ok(false, message + '. The expected key ' + key + ' is not present in the actual object.');
      }compare(left[key], right[key]);
    });
  }function compare(l, r) {
    return check(isSetoid, l, r) ? assert.ok(l.equals(r), message + '. The LHS (' + l + ') setoid instance says the LHS and RHS (' + r + ') are not equal.') : Array.isArray(r) ? compareArrays(l, r) : isRecord(r) ? compareRecord(l, r) : /* otherwise */assert.deepStrictEqual(l, r, message + '. The LHS (' + l + ') and the RHS (' + r + ') are not structually equal.');
  }compare(actual, expected);
};

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------


/*~
 * Returns pairs of `(key, value)` for all own enumerable properties in an object.
 *
 * 
 * ## Example::
 * 
 *     const pair = { x: 10, y: 20 };
 *     toPairs(pair);
 *     // ==> [['x', 10], ['y', 20]]
 *     // (in ES5- VMs this may be [['y', 20], ['x', 10]])
 * 
 * 
 * ## Why?
 * 
 * Objects in JavaScript are commonly used as dictionaries, but natively
 * there are no operations to work with them in that way. This function
 * allows one to extract the `(key, value)` pairs from an object::
 *
 *     const pair = { x: 10, y: 20 };
 *     toPairs(pair);
 *     // ==> [['x', 10], ['y', 20]]
 *     // or  [['y', 20], ['x', 10]]
 *
 * Inherited properties, and those that are not marked as enumerable, are
 * not returned in the resulting array::
 *
 *     const p1 = { z: 2 };
 *     const pair2 = Object.create(p1);
 *     pair2.x = 10; pair2.y = 20;
 *
 *     toPairs(pair2);
 *     // ==> [['x', 10], ['y', 20]]
 *     // or  [['y', 20], ['x', 10]]
 *
 *     // non-enumerable property x
 *     Object.defineProperty(p1, 'x', { value: 1 });
 *
 *     toPairs(p1);
 *     // ==> [['z', 2]]
 *
 *
 * ## Caveats
 * 
 * While ECMAScript 2015 specifies that objects are ordered using
 * insertion order, you're not guaranteed to get that behaviour in
 * any non-ES2015 engine, so for all effects it's better to treat
 * the result of this operation as an unordered collection.
 *
 * ---
 * category  : Combining
 * stability : stable
 * authors:
 *   - Quildreen Motta
 *
 * complexity : O(n), n is the number of own enumerable properties
 * type: |
 *   (Object 'a) => Array (String or Symbol, 'a)
 */
var toPairs = __metamagical_withMeta(function (object) {
  return Object.keys(object).map(function (k) {
    return [k, object[k]];
  });
}, {
  "name": "toPairs",
  "source": "(object) => Object.keys(object).map(k => [k, object[k]])",
  "signature": "toPairs(object)",
  "location": {
    "filename": "src/core/object/to-pairs.js",
    "start": {
      "line": 69,
      "column": 0
    },
    "end": {
      "line": 69,
      "column": 73
    }
  },
  "module": "folktale/src/core/object/to-pairs",
  "licence": "MIT",
  "authors": ["Quildreen Motta"],
  "repository": "https://github.com/origamitower/folktale",
  "npmPackage": "folktale",
  "category": "Combining",
  "stability": "stable",
  "complexity": "O(n), n is the number of own enumerable properties",
  "type": "(Object 'a) => Array (String or Symbol, 'a)\n",
  "documentation": "\nReturns pairs of `(key, value)` for all own enumerable properties in an object.\n\n\n## Example:\n\n    const pair = { x: 10, y: 20 };\n    toPairs(pair);\n    // ==> [['x', 10], ['y', 20]]\n    // (in ES5- VMs this may be [['y', 20], ['x', 10]])\n\n\n## Why?\n\nObjects in JavaScript are commonly used as dictionaries, but natively\nthere are no operations to work with them in that way. This function\nallows one to extract the `(key, value)` pairs from an object:\n\n    const pair = { x: 10, y: 20 };\n    toPairs(pair);\n    // ==> [['x', 10], ['y', 20]]\n    // or  [['y', 20], ['x', 10]]\n\nInherited properties, and those that are not marked as enumerable, are\nnot returned in the resulting array:\n\n    const p1 = { z: 2 };\n    const pair2 = Object.create(p1);\n    pair2.x = 10; pair2.y = 20;\n\n    toPairs(pair2);\n    // ==> [['x', 10], ['y', 20]]\n    // or  [['y', 20], ['x', 10]]\n\n    // non-enumerable property x\n    Object.defineProperty(p1, 'x', { value: 1 });\n\n    toPairs(p1);\n    // ==> [['z', 2]]\n\n\n## Caveats\n\nWhile ECMAScript 2015 specifies that objects are ordered using\ninsertion order, you're not guaranteed to get that behaviour in\nany non-ES2015 engine, so for all effects it's better to treat\nthe result of this operation as an unordered collection.\n",
  "examples": [{
    "name": "",
    "call": __metamagical_withMeta(function () {}, {
      "source": ""
    }),
    "inferred": true
  }, {
    "name": "Example::",
    "call": __metamagical_withMeta(function () {
      var pair = { x: 10, y: 20 };__metamagical_assert_equals(require("assert"), toPairs(pair), [['x', 10], ['y', 20]], "toPairs(pair) ==> [['x', 10], ['y', 20]]");; // ==> [['x', 10], ['y', 20]]
    }, {
      "source": "const pair = { x: 10, y: 20 };\ntoPairs(pair);\n// ==> [['x', 10], ['y', 20]]\n// (in ES5- VMs this may be [['y', 20], ['x', 10]])"
    }),
    "inferred": true
  }, {
    "name": "Why?",
    "call": __metamagical_withMeta(function () {
      var pair = { x: 10, y: 20 };__metamagical_assert_equals(require("assert"), toPairs(pair), [['x', 10], ['y', 20]], "toPairs(pair) ==> [['x', 10], ['y', 20]]");;var p1 = { z: 2 };var pair2 = Object.create(p1);pair2.x = 10;pair2.y = 20;__metamagical_assert_equals(require("assert"), toPairs(pair2), [['x', 10], ['y', 20]], "toPairs(pair2) ==> [['x', 10], ['y', 20]]");; // ==> [['x', 10], ['y', 20]]
      // or  [['y', 20], ['x', 10]]
      // non-enumerable property x
      Object.defineProperty(p1, 'x', { value: 1 });__metamagical_assert_equals(require("assert"), toPairs(p1), [['z', 2]], "toPairs(p1) ==> [['z', 2]]");; // ==> [['z', 2]]
    }, {
      "source": "const pair = { x: 10, y: 20 };\ntoPairs(pair);\n// ==> [['x', 10], ['y', 20]]\n// or  [['y', 20], ['x', 10]]\n\nconst p1 = { z: 2 };\nconst pair2 = Object.create(p1);\npair2.x = 10; pair2.y = 20;\n\ntoPairs(pair2);\n// ==> [['x', 10], ['y', 20]]\n// or  [['y', 20], ['x', 10]]\n\n// non-enumerable property x\nObject.defineProperty(p1, 'x', { value: 1 });\n\ntoPairs(p1);\n// ==> [['z', 2]]"
    }),
    "inferred": true
  }]
});

// --[ Exports ]-------------------------------------------------------
module.exports = toPairs;
},{"assert":54}],29:[function(require,module,exports){
"use strict";

var __metamagical_withMeta = function metamagical_withMeta(object, meta) {
  var parent = Object.getPrototypeOf(object);var oldMeta = object[Symbol.for('@@meta:magical')] || {};if (parent && parent[Symbol.for('@@meta:magical')] === oldMeta) {
    oldMeta = {};
  }Object.keys(meta).forEach(function (key) {
    if (/^~/.test(key)) {
      oldMeta[key.slice(1)] = meta[key];
    } else {
      oldMeta[key] = meta[key];
    }
  });object[Symbol.for('@@meta:magical')] = oldMeta;return object;
},
    __metamagical_assert_equals = function metamagical_assert_equals(assert, actual, expected, message) {
  var assertionType = Symbol.for('@@meta:magical:assertion-type');var rest = Symbol.for('@@meta:magical:assertion-rest');var keys = Object.keys;function isSetoid(value) {
    return value && typeof value.equals === 'function';
  }function isRecord(value) {
    return value && value[assertionType] === 'record';
  }function check(predicate) {
    for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }return values.every(predicate);
  }function getSpecialArrayLength(array) {
    var rests = array.map(function (x, i) {
      return [x, i];
    }).filter(function (pair) {
      return pair[0] === rest;
    });if (rests.length > 1 || rests[0] && rests[0][1] !== array.length - 1) {
      assert.ok(false, message + '. Assertions only support a single trailing rest indication for arrays currently.');
    }return (rests[0] || [null, array.length])[1];
  }function compareArrays(left, right) {
    var expectedLength = getSpecialArrayLength(right);assert.ok(Array.isArray(left), message + '. The LHS is not an array.');if (left.length < expectedLength) {
      assert.ok(false, message + '. The LHS does not have the minimum expected length (' + left.length + ' < ' + expectedLength + ')');
    }for (var i = 0; i < expectedLength; ++i) {
      compare(left[i], right[i]);
    }
  }function compareRecord(left, right) {
    var isPartial = right[rest];assert.ok(Object(left) === left, message);if (!isPartial) {
      assert.deepStrictEqual(keys(left).sort(), keys(right).sort(), message + '. The objects have different keys ([' + keys(left).sort().join(', ') + '] vs. [' + keys(right).sort().join(', ') + '])');
    }Object.keys(right).forEach(function (key) {
      if (!(key in left)) {
        assert.ok(false, message + '. The expected key ' + key + ' is not present in the actual object.');
      }compare(left[key], right[key]);
    });
  }function compare(l, r) {
    return check(isSetoid, l, r) ? assert.ok(l.equals(r), message + '. The LHS (' + l + ') setoid instance says the LHS and RHS (' + r + ') are not equal.') : Array.isArray(r) ? compareArrays(l, r) : isRecord(r) ? compareRecord(l, r) : /* otherwise */assert.deepStrictEqual(l, r, message + '. The LHS (' + l + ') and the RHS (' + r + ') are not structually equal.');
  }compare(actual, expected);
};

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

/*~
 * Returns the values for all own enumerable properties in an object.
 *
 * 
 * ## Example::
 * 
 *     const pair = { x: 10, y: 20 };
 *     values(pair);
 *     // ==> [10, 20] 
 *     // (In ES5- VMs this may be [20, 10])
 * 
 * 
 * ## Why?
 * 
 * Objects in JavaScript are commonly used as dictionaries, but natively
 * there are no operations to work with them in that way. This function
 * allows one to extract the values from an object::
 *
 *     const pair = { x: 10, y: 20 };
 *     values(pair);
 *     // ==> [10, 20]  
 *     // or  [20, 10]
 *
 * Inherited properties, and those that are not marked as enumerable, are
 * not returned in the resulting array::
 *
 *     const p1 = { z: 2 };
 *     const pair2 = Object.create(p1);
 *     pair2.x = 10; pair2.y = 20;
 *
 *     values(pair2);
 *     // ==> [10, 20] 
 *     // or  [20, 10]
 *
 *     // non-enumerable property x
 *     Object.defineProperty(p1, 'x', { value: 1 });
 *
 *     values(p1);
 *     // ==> [2]
 *
 *
 * ## Caveats
 * 
 * While ECMAScript 2015 specifies that objects are ordered using
 * insertion order, you're not guaranteed to get that behaviour in
 * any non-ES2015 engine, so for all effects it's better to treat
 * the result of this operation as an unordered collection.
 *
 * ---
 * category  : Converting
 * stability : stable
 * authors:
 *   - Quildreen Motta
 *
 * complexity : O(n), n is the number of own enumerable properties.
 * type: |
 *   (Object 'a) => Array 'a
 */
var values = __metamagical_withMeta(function (object) {
  return Object.keys(object).map(function (k) {
    return object[k];
  });
}, {
  "name": "values",
  "source": "(object) => Object.keys(object).map(k => object[k])",
  "signature": "values(object)",
  "location": {
    "filename": "src/core/object/values.js",
    "start": {
      "line": 68,
      "column": 0
    },
    "end": {
      "line": 68,
      "column": 67
    }
  },
  "module": "folktale/src/core/object/values",
  "licence": "MIT",
  "authors": ["Quildreen Motta"],
  "repository": "https://github.com/origamitower/folktale",
  "npmPackage": "folktale",
  "category": "Converting",
  "stability": "stable",
  "complexity": "O(n), n is the number of own enumerable properties.",
  "type": "(Object 'a) => Array 'a\n",
  "documentation": "\nReturns the values for all own enumerable properties in an object.\n\n\n## Example:\n\n    const pair = { x: 10, y: 20 };\n    values(pair);\n    // ==> [10, 20] \n    // (In ES5- VMs this may be [20, 10])\n\n\n## Why?\n\nObjects in JavaScript are commonly used as dictionaries, but natively\nthere are no operations to work with them in that way. This function\nallows one to extract the values from an object:\n\n    const pair = { x: 10, y: 20 };\n    values(pair);\n    // ==> [10, 20]  \n    // or  [20, 10]\n\nInherited properties, and those that are not marked as enumerable, are\nnot returned in the resulting array:\n\n    const p1 = { z: 2 };\n    const pair2 = Object.create(p1);\n    pair2.x = 10; pair2.y = 20;\n\n    values(pair2);\n    // ==> [10, 20] \n    // or  [20, 10]\n\n    // non-enumerable property x\n    Object.defineProperty(p1, 'x', { value: 1 });\n\n    values(p1);\n    // ==> [2]\n\n\n## Caveats\n\nWhile ECMAScript 2015 specifies that objects are ordered using\ninsertion order, you're not guaranteed to get that behaviour in\nany non-ES2015 engine, so for all effects it's better to treat\nthe result of this operation as an unordered collection.\n",
  "examples": [{
    "name": "",
    "call": __metamagical_withMeta(function () {}, {
      "source": ""
    }),
    "inferred": true
  }, {
    "name": "Example::",
    "call": __metamagical_withMeta(function () {
      var pair = { x: 10, y: 20 };__metamagical_assert_equals(require("assert"), values(pair), [10, 20], "values(pair) ==> [10, 20]");; // ==> [10, 20] 
      // (In ES5- VMs this may be [20, 10])
    }, {
      "source": "const pair = { x: 10, y: 20 };\nvalues(pair);\n// ==> [10, 20] \n// (In ES5- VMs this may be [20, 10])"
    }),
    "inferred": true
  }, {
    "name": "Why?",
    "call": __metamagical_withMeta(function () {
      var pair = { x: 10, y: 20 };__metamagical_assert_equals(require("assert"), values(pair), [10, 20], "values(pair) ==> [10, 20]");; // or  [20, 10]
      var p1 = { z: 2 };var pair2 = Object.create(p1);pair2.x = 10;pair2.y = 20;__metamagical_assert_equals(require("assert"), values(pair2), [10, 20], "values(pair2) ==> [10, 20]");; // ==> [10, 20] 
      // or  [20, 10]
      // non-enumerable property x
      Object.defineProperty(p1, 'x', { value: 1 });__metamagical_assert_equals(require("assert"), values(p1), [2], "values(p1) ==> [2]");; // ==> [2]
    }, {
      "source": "const pair = { x: 10, y: 20 };\nvalues(pair);\n// ==> [10, 20]  \n// or  [20, 10]\n\nconst p1 = { z: 2 };\nconst pair2 = Object.create(p1);\npair2.x = 10; pair2.y = 20;\n\nvalues(pair2);\n// ==> [10, 20] \n// or  [20, 10]\n\n// non-enumerable property x\nObject.defineProperty(p1, 'x', { value: 1 });\n\nvalues(p1);\n// ==> [2]"
    }),
    "inferred": true
  }]
});

// --[ Exports ]-------------------------------------------------------
module.exports = values;
},{"assert":54}],30:[function(require,module,exports){
'use strict';

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Copyright (C) 2015-2016 Quildreen Motta.
// Licensed under the MIT licence.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

module.exports = function (anEither) {
  return anEither.matchWith({
    Left: function Left() {
      return Nothing();
    },
    Right: function Right(_ref) {
      var value = _ref.value;
      return Just(value);
    }
  });
};

var _require = require('../maybe/core');

var Just = _require.Just;
var Nothing = _require.Nothing;
},{"../maybe/core":42}],31:[function(require,module,exports){
'use strict';

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Copyright (C) 2015-2016 Quildreen Motta.
// Licensed under the MIT licence.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------


module.exports = function (anEither) {
  return anEither.matchWith({
    Left: function Left(_ref) {
      var value = _ref.value;
      return Failure(value);
    },
    Right: function Right(_ref2) {
      var value = _ref2.value;
      return Success(value);
    }
  });
};

var _require = require('../validation/core');

var Success = _require.Success;
var Failure = _require.Failure;
},{"../validation/core":44}],32:[function(require,module,exports){
'use strict';

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Copyright (C) 2015-2016 Quildreen Motta.
// Licensed under the MIT licence.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

var _require = require('../either/core');

var Left = _require.Left;
var Right = _require.Right;


module.exports = function (aMaybe, failureValue) {
  return aMaybe.matchWith({
    Nothing: function Nothing() {
      return Left(failureValue);
    },
    Just: function Just(_ref) {
      var value = _ref.value;
      return Right(value);
    }
  });
};
},{"../either/core":38}],33:[function(require,module,exports){
'use strict';

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Copyright (C) 2015-2016 Quildreen Motta.
// Licensed under the MIT licence.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------
var _require = require('../validation/core');

var Success = _require.Success;
var Failure = _require.Failure;


module.exports = function (aMaybe, failureValue) {
  return aMaybe.matchWith({
    Nothing: function Nothing() {
      return Failure(failureValue);
    },
    Just: function Just(_ref) {
      var value = _ref.value;
      return Success(value);
    }
  });
};
},{"../validation/core":44}],34:[function(require,module,exports){
'use strict';

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Copyright (C) 2015-2016 Quildreen Motta.
// Licensed under the MIT licence.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

var _require = require('../either/core');

var Left = _require.Left;
var Right = _require.Right;


module.exports = function (a) {
  return a != null ? Right(a) : /*else*/Left(a);
};
},{"../either/core":38}],35:[function(require,module,exports){
'use strict';

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Copyright (C) 2015-2016 Quildreen Motta.
// Licensed under the MIT licence.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------
var _require = require('../validation/core');

var Success = _require.Success;
var Failure = _require.Failure;


module.exports = function (a) {
  return a != null ? Success(a) : /*else*/Failure(a);
};
},{"../validation/core":44}],36:[function(require,module,exports){
'use strict';

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Copyright (C) 2015-2016 Quildreen Motta.
// Licensed under the MIT licence.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

var _require = require('../either/core');

var Left = _require.Left;
var Right = _require.Right;


module.exports = function (aValidation) {
  return aValidation.matchWith({
    Failure: function Failure(_ref) {
      var value = _ref.value;
      return Left(value);
    },
    Success: function Success(_ref2) {
      var value = _ref2.value;
      return Right(value);
    }
  });
};
},{"../either/core":38}],37:[function(require,module,exports){
'use strict';

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Copyright (C) 2015-2016 Quildreen Motta.
// Licensed under the MIT licence.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------


module.exports = function (anEither) {
  return anEither.matchWith({
    Failure: function Failure() {
      return Nothing();
    },
    Success: function Success(_ref) {
      var value = _ref.value;
      return Just(value);
    }
  });
};

var _require = require('../maybe/core');

var Just = _require.Just;
var Nothing = _require.Nothing;
},{"../maybe/core":42}],38:[function(require,module,exports){
'use strict';

var assertType = require('../../helpers/assertType');
var assertFunction = require('../../helpers/assertFunction');

var _require = require('../../core/adt');

var data = _require.data;
var setoid = _require.setoid;
var show = _require.show;

var provideAliases = require('../../helpers/provide-fantasy-land-aliases');

var Either = data('folktale:Data.Either', {
  Left: function Left(value) {
    return { value: value };
  },
  Right: function Right(value) {
    return { value: value };
  }
}).derive(setoid, show);

var _Left = Either.Left;
var _Right = Either.Right;


var assertEither = assertType(Either);

// -- Functor ----------------------------------------------------------
_Left.prototype.map = function (transformation) {
  assertFunction('Either.Left#map', transformation);
  return this;
};

_Right.prototype.map = function (transformation) {
  assertFunction('Either.Right#map', transformation);
  return _Right(transformation(this.value));
};

// -- Apply ------------------------------------------------------------
_Left.prototype.apply = function (anEither) {
  assertEither('Left#apply', anEither);
  return this;
};

_Right.prototype.apply = function (anEither) {
  assertEither('Right#apply', anEither);
  return anEither.map(this.value);
};

// -- Applicative ------------------------------------------------------
Either.of = _Right;

// -- Chain ------------------------------------------------------------
_Left.prototype.chain = function (transformation) {
  assertFunction('Either.Left#chain', transformation);
  return this;
};

_Right.prototype.chain = function (transformation) {
  assertFunction('Either.Right#chain', transformation);
  return transformation(this.value);
};

// -- Extracting values and recovering ---------------------------------

// NOTE:
// `get` is similar to Comonad's `extract`. The reason we don't implement
// Comonad here is that `get` is partial, and not defined for Left
// values.

_Left.prototype.get = function () {
  throw new TypeError('Can\'t extract the value of a Left.\n\nLeft does not contain a normal value - it contains an error.\nYou might consider switching from Either#get to Either#getOrElse, or some other method\nthat is not partial.\n  ');
};

_Right.prototype.get = function () {
  return this.value;
};

_Left.prototype.getOrElse = function (default_) {
  return default_;
};

_Right.prototype.getOrElse = function (_default_) {
  return this.value;
};

_Left.prototype.orElse = function (handler) {
  return handler(this.value);
};

_Right.prototype.orElse = function (_) {
  return this;
};

// -- Folds and extended transformations--------------------------------

Either.fold = function (f, g) {
  return this.matchWith({
    Left: function Left(_ref) {
      var value = _ref.value;
      return f(value);
    },
    Right: function Right(_ref2) {
      var value = _ref2.value;
      return g(value);
    }
  });
};

Either.merge = function () {
  return this.value;
};

Either.swap = function () {
  return this.fold(_Right, _Left);
};

Either.bimap = function (f, g) {
  return this.matchWith({
    Left: function Left(_ref3) {
      var value = _ref3.value;
      return _Left(f(value));
    },
    Right: function Right(_ref4) {
      var value = _ref4.value;
      return _Right(g(value));
    }
  });
};

_Left.prototype.leftMap = function (transformation) {
  assertFunction('Either.Left#leftMap', transformation);
  return _Left(transformation(this.value));
};

_Right.prototype.leftMap = function (transformation) {
  assertFunction('Either.Right#leftMap', transformation);
  return this;
};

// -- Conversions -------------------------------------------------
_Left.prototype.toJSON = function () {
  return {
    '#type': 'folktale:Either.Left',
    value: this.value
  };
};

_Right.prototype.toJSON = function () {
  return {
    '#type': 'folktale:Either.Right',
    value: this.value
  };
};

Either.toValidation = function () {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return require('../conversions/either-to-validation').apply(undefined, [this].concat(args));
};

Either.toMaybe = function () {
  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  return require('../conversions/either-to-maybe').apply(undefined, [this].concat(args));
};

provideAliases(_Left.prototype);
provideAliases(_Right.prototype);
provideAliases(Either);

module.exports = Either;
},{"../../core/adt":2,"../../helpers/assertFunction":46,"../../helpers/assertType":47,"../../helpers/provide-fantasy-land-aliases":49,"../conversions/either-to-maybe":30,"../conversions/either-to-validation":31}],39:[function(require,module,exports){
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Copyright (C) 2015-2016 Quildreen Motta.
// Licensed under the MIT licence.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

module.exports = _extends({}, require('./core'), {
  try: require('./try'),
  fromNullable: require('../conversions/nullable-to-either'),
  fromValidation: require('../conversions/validation-to-either'),
  fromMaybe: require('../conversions/maybe-to-either')
});
},{"../conversions/maybe-to-either":32,"../conversions/nullable-to-either":34,"../conversions/validation-to-either":36,"./core":38,"./try":40}],40:[function(require,module,exports){
'use strict';

var _require = require('./core');

var Left = _require.Left;
var Right = _require.Right;


module.exports = function (f) {
  return function () {
    try {
      return Right(f.apply(undefined, arguments));
    } catch (e) {
      return Left(e);
    }
  };
};
},{"./core":38}],41:[function(require,module,exports){
'use strict';

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Copyright (C) 2015-2016 Quildreen Motta.
// Licensed under the MIT licence.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

module.exports = {
  maybe: require('./maybe'),
  either: require('./either'),
  validation: require('./validation')
};
},{"./either":39,"./maybe":43,"./validation":45}],42:[function(require,module,exports){
'use strict';

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Copyright (C) 2015-2016 Quildreen Motta.
// Licensed under the MIT licence.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

var assertType = require('../../helpers/assertType');
var assertFunction = require('../../helpers/assertFunction');

var _require = require('../../core/adt');

var data = _require.data;
var show = _require.show;
var setoid = _require.setoid;

var provideAliases = require('../../helpers/provide-fantasy-land-aliases');

var Maybe = data('folktale:Data.Maybe', {
  Nothing: function Nothing() {},
  Just: function Just(value) {
    return { value: value };
  }
}).derive(setoid, show, setoid);

var Nothing = Maybe.Nothing;
var Just = Maybe.Just;


var assertMaybe = assertType(Maybe);

// -- Functor ----------------------------------------------------------
Nothing.prototype.map = function (transformation) {
  assertFunction('Maybe.Nothing#map', transformation);
  return this;
};

Just.prototype.map = function (transformation) {
  assertFunction('Maybe.Nothing#map', transformation);
  return Just(transformation(this.value));
};

// -- Apply ------------------------------------------------------------
Nothing.prototype.apply = function (aMaybe) {
  assertMaybe('Maybe.Nothing#apply', aMaybe);
  return this;
};

Just.prototype.apply = function (aMaybe) {
  assertMaybe('Maybe.Just#apply', aMaybe);
  return aMaybe.map(this.value);
};

// -- Applicative ------------------------------------------------------
Maybe.of = Just;

// -- Chain ------------------------------------------------------------
Nothing.prototype.chain = function (transformation) {
  assertFunction('Maybe.Nothing#chain', transformation);
  return this;
};

Just.prototype.chain = function (transformation) {
  assertFunction('Maybe.Just#chain', transformation);
  return transformation(this.value);
};

// -- Extracting values and recovering ---------------------------------

// NOTE:
// `get` is similar to Comonad's `extract`. The reason we don't implement
// Comonad here is that `get` is partial, and not defined for Nothing
// values.

Nothing.prototype.get = function () {
  throw new TypeError('Can\'t extract the value of a Nothing.\n\nSince Nothing holds no values, it\'s not possible to extract one from them.\nYou might consider switching from Maybe#get to Maybe#getOrElse, or some other method\nthat is not partial.\n  ');
};

Just.prototype.get = function () {
  return this.value;
};

Nothing.prototype.getOrElse = function (default_) {
  return default_;
};

Just.prototype.getOrElse = function (_default_) {
  return this.value;
};

Nothing.prototype.orElse = function (handler) {
  return handler();
};

Just.prototype.orElse = function () {
  return this;
};

// -- Conversions -------------------------------------------------
Nothing.prototype.toJSON = function () {
  return {
    '#type': 'folktale:Maybe.Nothing'
  };
};

Just.prototype.toJSON = function () {
  return {
    '#type': 'folktale:Maybe.Just',
    value: this.value
  };
};

Maybe.toEither = function () {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return require('../conversions/maybe-to-either').apply(undefined, [this].concat(args));
};

Maybe.toValidation = function () {
  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  return require('../conversions/maybe-to-validation').apply(undefined, [this].concat(args));
};

// -- Exports ----------------------------------------------------------
provideAliases(Just.prototype);
provideAliases(Nothing.prototype);
provideAliases(Maybe);

module.exports = Maybe;
},{"../../core/adt":2,"../../helpers/assertFunction":46,"../../helpers/assertType":47,"../../helpers/provide-fantasy-land-aliases":49,"../conversions/maybe-to-either":32,"../conversions/maybe-to-validation":33}],43:[function(require,module,exports){
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Copyright (C) 2015-2016 Quildreen Motta.
// Licensed under the MIT licence.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

module.exports = _extends({}, require('./core'), {
  fromEither: require('../conversions/either-to-maybe'),
  fromValidation: require('../conversions/validation-to-maybe')
});
},{"../conversions/either-to-maybe":30,"../conversions/validation-to-maybe":37,"./core":42}],44:[function(require,module,exports){
'use strict';

var assertType = require('../../helpers/assertType');
var assertFunction = require('../../helpers/assertFunction');

var _require = require('../../core/adt');

var data = _require.data;
var setoid = _require.setoid;
var show = _require.show;

var provideAliases = require('../../helpers/provide-fantasy-land-aliases');
var constant = require('../../core/lambda/constant');

var Validation = data('folktale:Data.Validation', {
  Failure: function Failure(value) {
    return { value: value };
  },
  Success: function Success(value) {
    return { value: value };
  }
}).derive(setoid, show);

var _Success = Validation.Success;
var _Failure = Validation.Failure;


var assertValidation = assertType(Validation);

// -- Functor ----------------------------------------------------------
_Failure.prototype.map = function (transformation) {
  assertFunction('Validation.Failure#map', transformation);
  return this;
};
_Success.prototype.map = function (transformation) {
  assertFunction('Validation.Success#map', transformation);
  return _Success(transformation(this.value));
};

// -- Apply ------------------------------------------------------------
_Failure.prototype.apply = function (aValidation) {
  assertValidation('Failure#apply', aValidation);
  return _Failure.hasInstance(aValidation) ? _Failure(this.value.concat(aValidation.value)) : /* otherwise */this;
};

_Success.prototype.apply = function (aValidation) {
  assertValidation('Success#apply', aValidation);
  return _Failure.hasInstance(aValidation) ? aValidation : /* otherwise */aValidation.map(this.value);
};

// -- Applicative ------------------------------------------------------
Validation.of = _Success;

// -- Extracting values and recovering ---------------------------------

// NOTE:
// `get` is similar to Comonad's `extract`. The reason we don't implement
// Comonad here is that `get` is partial, and not defined for Failure
// values.

_Failure.prototype.get = function () {
  throw new TypeError('Can\'t extract the value of a Failure.\n\nFailure does not contain a normal value - it contains an error.\nYou might consider switching from Validation#get to Validation#getOrElse, or some other method\nthat is not partial.\n  ');
};

_Success.prototype.get = function () {
  return this.value;
};

// -- Semigroup --------------------------------------------------------
Validation.concat = function (aValidation) {
  var /* otherwise */_this = this;

  assertValidation('Validation#concat', aValidation);
  return this.matchWith({
    Failure: function Failure(_ref) {
      var value = _ref.value;
      return _Failure.hasInstance(aValidation) ? _Failure(value.concat(aValidation.value)) : _this;
    },
    Success: function Success(_) {
      return aValidation;
    }
  });
};

// -- Extracting values and recovering ---------------------------------

// NOTE:
// `get` is similar to Comonad's `extract`. The reason we don't implement
// Comonad here is that `get` is partial, and not defined for Left
// values.

_Failure.prototype.getOrElse = function (default_) {
  return default_;
};

_Success.prototype.getOrElse = function (_default_) {
  return this.value;
};

_Failure.prototype.orElse = function (handler) {
  return handler(this.value);
};

_Success.prototype.orElse = function (_) {
  return this;
};

// -- Folds and extended transformations--------------------------------

Validation.fold = function (f, g) {
  return this.matchWith({
    Failure: function Failure(_ref2) {
      var value = _ref2.value;
      return f(value);
    },
    Success: function Success(_ref3) {
      var value = _ref3.value;
      return g(value);
    }
  });
};

Validation.merge = function () {
  return this.value;
};

Validation.swap = function () {
  return this.fold(_Success, _Failure);
};

Validation.bimap = function (f, g) {
  return this.matchWith({
    Failure: function Failure(_ref4) {
      var value = _ref4.value;
      return _Failure(f(value));
    },
    Success: function Success(_ref5) {
      var value = _ref5.value;
      return _Success(g(value));
    }
  });
};

_Success.prototype.failureMap = function (transformation) {
  assertFunction('Validation.Success#failureMap', transformation);
  return this;
};
_Failure.prototype.failureMap = function (transformation) {
  assertFunction('Validation.Failure#failureMap', transformation);
  return _Failure(transformation(this.value));
};

// -- Conversions -------------------------------------------------
_Failure.prototype.toJSON = function () {
  return {
    '#type': 'folktale:Validation.Failure',
    value: this.value
  };
};
_Success.prototype.toJSON = function () {
  return {
    '#type': 'folktale:Validation.Success',
    value: this.value
  };
};

Validation.toEither = function () {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  return require('../conversions/validation-to-either').apply(undefined, [this].concat(args));
};

Validation.toMaybe = function () {
  for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }

  return require('../conversions/validation-to-maybe').apply(undefined, [this].concat(args));
};

provideAliases(_Success.prototype);
provideAliases(_Failure.prototype);
provideAliases(Validation);

module.exports = Validation;
},{"../../core/adt":2,"../../core/lambda/constant":19,"../../helpers/assertFunction":46,"../../helpers/assertType":47,"../../helpers/provide-fantasy-land-aliases":49,"../conversions/validation-to-either":36,"../conversions/validation-to-maybe":37}],45:[function(require,module,exports){
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Copyright (C) 2015-2016 Quildreen Motta.
// Licensed under the MIT licence.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

module.exports = _extends({}, require('./core'), {
  fromNullable: require('../conversions/nullable-to-validation'),
  fromEither: require('../conversions/either-to-validation'),
  fromMaybe: require('../conversions/maybe-to-validation')
});
},{"../conversions/either-to-validation":31,"../conversions/maybe-to-validation":33,"../conversions/nullable-to-validation":35,"./core":44}],46:[function(require,module,exports){
'use strict';

module.exports = function (method, transformation) {
  if (typeof transformation !== 'function') {
    throw new TypeError(method + ' expects a function, but was given ' + transformation + '.');
  }
};
},{}],47:[function(require,module,exports){
(function (process){
'use strict';

var _require = require('../core/adt/core');

var typeSymbol = _require.typeSymbol;


module.exports = function (type) {
  return function (method, value) {
    var typeName = type[typeSymbol];
    if (process.env.FOLKTALE_ASSERTIONS !== 'none' && !type.isPrototypeOf(value)) {
      console.warn(typeName + '.' + method + ' expects a value of the same type, but was given ' + value + '.');

      if (process.env.FOLKTALE_ASSERTIONS !== 'minimal') {
        console.warn('\nThis could mean that you\'ve provided the wrong value to the method, in\nwhich case this is a bug in your program, and you should try to track\ndown why the wrong value is getting here.\n\nBut this could also mean that you have more than one ' + typeName + ' library\ninstantiated in your program. This is not **necessarily** a bug, it\ncould happen for several reasons:\n\n 1) You\'re loading the library in Node, and Node\'s cache didn\'t give\n    you back the same instance you had previously requested.\n\n 2) You have more than one Code Realm in your program, and objects\n    created from the same library, in different realms, are interacting.\n\n 3) You have a version conflict of folktale libraries, and objects\n    created from different versions of the library are interacting.\n\nIf your situation fits the cases (1) or (2), you are okay, as long as\nthe objects originate from the same version of the library. Folktale\ndoes not rely on reference checking, only structural checking. However\nyou\'ll want to watch out if you\'re modifying the ' + typeName + '\'s prototype,\nbecause you\'ll have more than one of them, and you\'ll want to make\nsure you do the same change in all of them â€” ideally you shouldn\'t\nbe modifying the object, though.\n\nIf your situation fits the case (3), you are *probably* okay if the\nversion difference isn\'t a major one. However, at this point the\nbehaviour of your program using ' + typeName + ' is undefined, and you should\ntry looking into why the version conflict is happening.\n\nParametric modules can help ensuring your program only has a single\ninstance of the folktale library. Check out the Folktale Architecture\ndocumentation for more information.\n      ');
      }
    }
  };
};
}).call(this,require('_process'))
},{"../core/adt/core":1,"_process":391}],48:[function(require,module,exports){
'use strict';

module.exports = {
  equals: 'fantasy-land/equals',
  concat: 'fantasy-land/concat',
  empty: 'fantasy-land/empty',
  map: 'fantasy-land/map',
  ap: 'fantasy-land/ap',
  of: 'fantasy-land/of',
  reduce: 'fantasy-land/reduce',
  traverse: 'fantasy-land/traverse',
  chain: 'fantasy-land/chain',
  chainRec: 'fantasy-land/chainRec',
  extend: 'fantasy-land/extend',
  extract: 'fantasy-land/extract',
  bimap: 'fantasy-land/bimap',
  promap: 'fantasy-land/promap'
};
},{}],49:[function(require,module,exports){
'use strict';

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------


var aliases = {
  equals: {
    /*
     * Fantasy Land's Setoid `equals'.
     * ---
     * category: Fantasy Land
     * type: |
     *   ('S 'a).('S 'a) => Boolean
     *   where 'S is Setoid
     */
    'fantasy-land/equals': function fantasyLandEquals(that) {
      return this.equals(that);
    }
  },

  concat: {
    /*
     * Fantasy Land's Semigroup `concat`.
     * ---
     * category: Fantasy Land
     * type: |
     *   ('S 'a).('S 'a) => 'S 'a
     *   where 'S is Semigroup
     */
    'fantasy-land/concat': function fantasyLandConcat(that) {
      return this.concat(that);
    }
  },

  empty: {
    /*
     * Fnatasy Land's Monoid `empty`.
     * ---
     * category: Fantasy Land
     * type: |
     *   ('M).() => 'M a
     *   where 'M is Monoid
     */
    'fantasy-land/empty': function fantasyLandEmpty() {
      return this.empty();
    }
  },

  map: {
    /*
     * Fantasy Land's Functor `map`.
     * ---
     * category: Fantasy Land
     * type: |
     *   ('F 'a).(('a) => 'b) => 'F 'b
     *   where 'F is Functor
     */
    'fantasy-land/map': function fantasyLandMap(transformation) {
      return this.map(transformation);
    }
  },

  apply: {
    /*
     * Fantasy Land's Apply `ap`
     * ---
     * category: Fantasy Land
     * type: |
     *   ('F ('a) => b).('F 'a) => 'F 'b
     *   where 'F is Apply
     */
    ap: function ap(that) {
      return this.apply(that);
    },


    /*
     * Fantasy Land's Apply `ap`
     * ---
     * category: Fantasy Land
     * type: |
     *   ('F 'a).('F ('a) => 'b) => 'F 'b
     *   where 'F is Apply
     */
    'fantasy-land/ap': function fantasyLandAp(that) {
      return that.apply(this);
    }
  },

  of: {
    /*
     * Fantasy Land's Applicative `of`
     * ---
     * category: Fantasy Land
     * type: |
     *   forall F, a:
     *     (F).(a) => F a
     *   where F is Applicative 
     */
    'fantasy-land/of': function fantasyLandOf(value) {
      return this.of(value);
    }
  },

  reduce: {
    /*
     * Fantasy Landâ€™s Foldable `reduce`.
     * ---
     * category: Fantasy Land
     * type: |
     *   forall F, a, b:
     *     (F a).((b, a) => b, b) => b
     *   where F is Foldable  
     */
    'fantasy-land/reduce': function fantasyLandReduce(combinator, initial) {
      return this.reduce(combinator, initial);
    }
  },

  traverse: {
    /*
     * Fantasy Landâ€™s Traversable `traverse`.
     * ---
     * category: Fantasy Land
     * type: |
     *   forall F, T, a, b:
     *     (T a).((a) => F b, (c) => F c) => F (T b)
     *   where F is Apply, T is Traversable
     */
    'fantasy-land/traverse': function fantasyLandTraverse(transformation, lift) {
      return this.traverse(transformation, lift);
    }
  },

  chain: {
    /*
     * Fantasy Landâ€™s Chain `chain`.
     * ---
     * category: Fantasy Land
     * type: |
     *   forall M, a, b:
     *     (M a).((a) => M b) => M b
     *   where M is Chain
     */
    'fantasy-land/chain': function fantasyLandChain(transformation) {
      return this.chain(transformation);
    }
  },

  chainRecursively: {
    /*
     * Fantasy Landâ€™s ChainRec `chainRec`.
     * ---
     * category: Fantasy Land
     * type: |
     *   forall M, a, b, c:
     *     (M).(
     *       Step:    ((a) => c, (b) => c, a) => M c,
     *       Initial: a
     *     ) => M b
     *   where M is ChainRec 
     */
    chainRec: function chainRec(step, initial) {
      return this.chainRecursively(step, initial);
    },


    /*
     * Fantasy Landâ€™s ChainRec `chainRec`.
     * ---
     * category: Fantasy Land
     * type: |
     *   forall M, a, b, c:
     *     (M).(
     *       Step:    ((a) => c, (b) => c, a) => M c,
     *       Initial: a
     *     ) => M b
     *   where M is ChainRec 
     */
    'fantasy-land/chainRec': function fantasyLandChainRec(step, initial) {
      return this.chainRecursively(step, initial);
    }
  },

  extend: {
    /*
     * Fantasy Landâ€™s Extend `extend`
     * ---
     * category: Fantasy Land
     * type: |
     *   forall W, a, b:
     *     (W a).((W a) => b) => W b
     *   where W is Extend
     */
    'fantasy-land/extend': function fantasyLandExtend(transformation) {
      return this.extend(transformation);
    }
  },

  extract: {
    /*
     * Fantasy Landâ€™s Comonad `extract`
     * ---
     * category: Fantasy Land
     * type: |
     *   forall W, a, b:
     *     (W a).() => a
     *   where W is Comonad
     */
    'fantasy-land/extract': function fantasyLandExtract() {
      return this.extract();
    }
  },

  bimap: {
    /*
     * Fantasy Landâ€™s Bifunctor `bimap`
     * ---
     * category: Fantasy Land
     * type: |
     *   forall F, a, b, c, d:
     *     (F a b).((a) => c, (b) => d) => F c d
     *   where F is Bifunctor
     */
    'fantasy-land/bimap': function fantasyLandBimap(f, g) {
      return this.bimap(f, g);
    }
  },

  promap: {
    /*
     * Fantasy Landâ€™s Profunctor `promap`
     * ---
     * category: Fantasy Land
     * type: |
     *   forall P, a, b, c, d:
     *     (P a b).((c) => a, (b) => d) => P c d
     */
    'fantasy-land/promap': function fantasyLandPromap(f, g) {
      return this.promap(f, g);
    }
  }
};

var provideAliases = function provideAliases(structure) {
  Object.keys(aliases).forEach(function (method) {
    if (typeof structure[method] === 'function') {
      Object.keys(aliases[method]).forEach(function (alias) {
        structure[alias] = aliases[method][alias];
      });
    }
  });
};

module.exports = provideAliases;
},{}],50:[function(require,module,exports){
"use strict";

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

module.exports = function (methodName) {
  return function (object) {
    throw new TypeError(object + " does not have a method '" + methodName + "'.");
  };
};
},{}],51:[function(require,module,exports){
"use strict";

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

module.exports = function (methodName) {
  return function (result) {
    console.warn("Type." + methodName + "() is being deprecated in favour of Type['fantasy-land/" + methodName + "'](). \n    Your data structure is using the old-style fantasy-land methods,\n    and these won't be supported in Folktale 3");
    return result;
  };
};
},{}],52:[function(require,module,exports){
'use strict';

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

function warnDeprecation(reason) {
  var stack = new Error('').stack;
  var offender = void 0;
  if (stack) {
    var lines = stack.split('\n');
    offender = lines[3];
  }

  if (offender) {
    console.warn(reason + '\n    Blame: ' + offender.trim());
  } else {
    console.warn(reason);
  }
}

module.exports = warnDeprecation;
},{}],53:[function(require,module,exports){
'use strict';

var __metamagical_withMeta = function metamagical_withMeta(object, meta) {
  var parent = Object.getPrototypeOf(object);var oldMeta = object[Symbol.for('@@meta:magical')] || {};if (parent && parent[Symbol.for('@@meta:magical')] === oldMeta) {
    oldMeta = {};
  }Object.keys(meta).forEach(function (key) {
    if (/^~/.test(key)) {
      oldMeta[key.slice(1)] = meta[key];
    } else {
      oldMeta[key] = meta[key];
    }
  });object[Symbol.for('@@meta:magical')] = oldMeta;return object;
};

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

/*~
 * Folktale is a library for functional programming in JavaScript. It provides
 * combinators and data structures that make it easier to write programs by
 * composing existing features to build bigger things, which can be further
 * composed.
 *
 * > **TODO**  
 * > This documentation is a stub and needs to be improved. It should give
 * > pointers on where to start on functional programming and Folktale.
 *
 * --------------------------------------------------------------------
 * name        : module folktale
 * module      : folktale
 * copyright   : (c) 2015-2016 Quildreen Motta, and CONTRIBUTORS
 * licence     : MIT
 * repository  : https://github.com/origamitower/folktale
 *
 * category    : Functional Programming
 *
 * maintainers:
 *   - Quildreen Motta <queen@robotlolita.me>
 */
module.exports = __metamagical_withMeta({
  core: require('./core'),
  data: require('./data')
}, {
  'name': 'module folktale',
  'source': '{\n  core: require(\'./core\'),\n  data: require(\'./data\')\n}',
  'location': {
    'filename': 'src/index.js',
    'start': {
      'line': 32,
      'column': 0
    },
    'end': {
      'line': 35,
      'column': 2
    }
  },
  'module': 'folktale',
  'licence': 'MIT',
  'authors': ['Quildreen Motta'],
  'repository': 'https://github.com/origamitower/folktale',
  'npmPackage': 'folktale',
  'isModule': true,
  'copyright': '(c) 2015-2016 Quildreen Motta, and CONTRIBUTORS',
  'category': 'Functional Programming',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me>'],
  'documentation': '\nFolktale is a library for functional programming in JavaScript. It provides\ncombinators and data structures that make it easier to write programs by\ncomposing existing features to build bigger things, which can be further\ncomposed.\n\n> **TODO**  \n> This documentation is a stub and needs to be improved. It should give\n> pointers on where to start on functional programming and Folktale.\n'
});
},{"./core":17,"./data":41}],54:[function(require,module,exports){
(function (global){
'use strict';

// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }
  return !!(b != null && b._isBuffer);
}

// based on node assert, original notice:

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var util = require('util/');
var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;
var functionsHaveNames = (function () {
  return function foo() {}.name === 'foo';
}());
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

var assert = module.exports = ok;

// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }
  if (functionsHaveNames) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
};

// assert.AssertionError instanceof Error
util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}
assert.ok = ok;

// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
};

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);

assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
};

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);

assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (util.isPrimitive(a) || util.isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);

assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);

assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
};

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);

assert.throws = function(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
};

// EXTENSION! This is annoying to write outside this module.
assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
};

assert.ifError = function(err) { if (err) throw err; };

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"util/":399}],55:[function(require,module,exports){
(function (global){
"use strict";

require("core-js/shim");

require("regenerator-runtime/runtime");

require("core-js/fn/regexp/escape");

/* eslint max-len: 0 */

if (global._babelPolyfill) {
  throw new Error("only one instance of babel-polyfill is allowed");
}
global._babelPolyfill = true;

// Should be removed in the next major release:

var DEFINE_PROPERTY = "defineProperty";
function define(O, key, value) {
  O[key] || Object[DEFINE_PROPERTY](O, key, {
    writable: true,
    configurable: true,
    value: value
  });
}

define(String.prototype, "padLeft", "".padStart);
define(String.prototype, "padRight", "".padEnd);

"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
  [][key] && define(Array, key, Function.call.bind([][key]));
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"core-js/fn/regexp/escape":56,"core-js/shim":349,"regenerator-runtime/runtime":394}],56:[function(require,module,exports){
require('../../modules/core.regexp.escape');
module.exports = require('../../modules/_core').RegExp.escape;
},{"../../modules/_core":77,"../../modules/core.regexp.escape":173}],57:[function(require,module,exports){
module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};
},{}],58:[function(require,module,exports){
var cof = require('./_cof');
module.exports = function(it, msg){
  if(typeof it != 'number' && cof(it) != 'Number')throw TypeError(msg);
  return +it;
};
},{"./_cof":72}],59:[function(require,module,exports){
// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = require('./_wks')('unscopables')
  , ArrayProto  = Array.prototype;
if(ArrayProto[UNSCOPABLES] == undefined)require('./_hide')(ArrayProto, UNSCOPABLES, {});
module.exports = function(key){
  ArrayProto[UNSCOPABLES][key] = true;
};
},{"./_hide":94,"./_wks":171}],60:[function(require,module,exports){
module.exports = function(it, Constructor, name, forbiddenField){
  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};
},{}],61:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};
},{"./_is-object":103}],62:[function(require,module,exports){
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
'use strict';
var toObject = require('./_to-object')
  , toIndex  = require('./_to-index')
  , toLength = require('./_to-length');

module.exports = [].copyWithin || function copyWithin(target/*= 0*/, start/*= 0, end = @length*/){
  var O     = toObject(this)
    , len   = toLength(O.length)
    , to    = toIndex(target, len)
    , from  = toIndex(start, len)
    , end   = arguments.length > 2 ? arguments[2] : undefined
    , count = Math.min((end === undefined ? len : toIndex(end, len)) - from, len - to)
    , inc   = 1;
  if(from < to && to < from + count){
    inc  = -1;
    from += count - 1;
    to   += count - 1;
  }
  while(count-- > 0){
    if(from in O)O[to] = O[from];
    else delete O[to];
    to   += inc;
    from += inc;
  } return O;
};
},{"./_to-index":159,"./_to-length":162,"./_to-object":163}],63:[function(require,module,exports){
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
'use strict';
var toObject = require('./_to-object')
  , toIndex  = require('./_to-index')
  , toLength = require('./_to-length');
module.exports = function fill(value /*, start = 0, end = @length */){
  var O      = toObject(this)
    , length = toLength(O.length)
    , aLen   = arguments.length
    , index  = toIndex(aLen > 1 ? arguments[1] : undefined, length)
    , end    = aLen > 2 ? arguments[2] : undefined
    , endPos = end === undefined ? length : toIndex(end, length);
  while(endPos > index)O[index++] = value;
  return O;
};
},{"./_to-index":159,"./_to-length":162,"./_to-object":163}],64:[function(require,module,exports){
var forOf = require('./_for-of');

module.exports = function(iter, ITERATOR){
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};

},{"./_for-of":91}],65:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject')
  , toLength  = require('./_to-length')
  , toIndex   = require('./_to-index');
module.exports = function(IS_INCLUDES){
  return function($this, el, fromIndex){
    var O      = toIObject($this)
      , length = toLength(O.length)
      , index  = toIndex(fromIndex, length)
      , value;
    // Array#includes uses SameValueZero equality algorithm
    if(IS_INCLUDES && el != el)while(length > index){
      value = O[index++];
      if(value != value)return true;
    // Array#toIndex ignores holes, Array#includes - not
    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
      if(O[index] === el)return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};
},{"./_to-index":159,"./_to-iobject":161,"./_to-length":162}],66:[function(require,module,exports){
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx      = require('./_ctx')
  , IObject  = require('./_iobject')
  , toObject = require('./_to-object')
  , toLength = require('./_to-length')
  , asc      = require('./_array-species-create');
module.exports = function(TYPE, $create){
  var IS_MAP        = TYPE == 1
    , IS_FILTER     = TYPE == 2
    , IS_SOME       = TYPE == 3
    , IS_EVERY      = TYPE == 4
    , IS_FIND_INDEX = TYPE == 6
    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
    , create        = $create || asc;
  return function($this, callbackfn, that){
    var O      = toObject($this)
      , self   = IObject(O)
      , f      = ctx(callbackfn, that, 3)
      , length = toLength(self.length)
      , index  = 0
      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
      , val, res;
    for(;length > index; index++)if(NO_HOLES || index in self){
      val = self[index];
      res = f(val, index, O);
      if(TYPE){
        if(IS_MAP)result[index] = res;            // map
        else if(res)switch(TYPE){
          case 3: return true;                    // some
          case 5: return val;                     // find
          case 6: return index;                   // findIndex
          case 2: result.push(val);               // filter
        } else if(IS_EVERY)return false;          // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};
},{"./_array-species-create":69,"./_ctx":79,"./_iobject":99,"./_to-length":162,"./_to-object":163}],67:[function(require,module,exports){
var aFunction = require('./_a-function')
  , toObject  = require('./_to-object')
  , IObject   = require('./_iobject')
  , toLength  = require('./_to-length');

module.exports = function(that, callbackfn, aLen, memo, isRight){
  aFunction(callbackfn);
  var O      = toObject(that)
    , self   = IObject(O)
    , length = toLength(O.length)
    , index  = isRight ? length - 1 : 0
    , i      = isRight ? -1 : 1;
  if(aLen < 2)for(;;){
    if(index in self){
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if(isRight ? index < 0 : length <= index){
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for(;isRight ? index >= 0 : length > index; index += i)if(index in self){
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};
},{"./_a-function":57,"./_iobject":99,"./_to-length":162,"./_to-object":163}],68:[function(require,module,exports){
var isObject = require('./_is-object')
  , isArray  = require('./_is-array')
  , SPECIES  = require('./_wks')('species');

module.exports = function(original){
  var C;
  if(isArray(original)){
    C = original.constructor;
    // cross-realm fallback
    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
    if(isObject(C)){
      C = C[SPECIES];
      if(C === null)C = undefined;
    }
  } return C === undefined ? Array : C;
};
},{"./_is-array":101,"./_is-object":103,"./_wks":171}],69:[function(require,module,exports){
// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = require('./_array-species-constructor');

module.exports = function(original, length){
  return new (speciesConstructor(original))(length);
};
},{"./_array-species-constructor":68}],70:[function(require,module,exports){
'use strict';
var aFunction  = require('./_a-function')
  , isObject   = require('./_is-object')
  , invoke     = require('./_invoke')
  , arraySlice = [].slice
  , factories  = {};

var construct = function(F, len, args){
  if(!(len in factories)){
    for(var n = [], i = 0; i < len; i++)n[i] = 'a[' + i + ']';
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /*, args... */){
  var fn       = aFunction(this)
    , partArgs = arraySlice.call(arguments, 1);
  var bound = function(/* args... */){
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if(isObject(fn.prototype))bound.prototype = fn.prototype;
  return bound;
};
},{"./_a-function":57,"./_invoke":98,"./_is-object":103}],71:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof')
  , TAG = require('./_wks')('toStringTag')
  // ES3 wrong here
  , ARG = cof(function(){ return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function(it, key){
  try {
    return it[key];
  } catch(e){ /* empty */ }
};

module.exports = function(it){
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};
},{"./_cof":72,"./_wks":171}],72:[function(require,module,exports){
var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};
},{}],73:[function(require,module,exports){
'use strict';
var dP          = require('./_object-dp').f
  , create      = require('./_object-create')
  , redefineAll = require('./_redefine-all')
  , ctx         = require('./_ctx')
  , anInstance  = require('./_an-instance')
  , defined     = require('./_defined')
  , forOf       = require('./_for-of')
  , $iterDefine = require('./_iter-define')
  , step        = require('./_iter-step')
  , setSpecies  = require('./_set-species')
  , DESCRIPTORS = require('./_descriptors')
  , fastKey     = require('./_meta').fastKey
  , SIZE        = DESCRIPTORS ? '_s' : 'size';

var getEntry = function(that, key){
  // fast case
  var index = fastKey(key), entry;
  if(index !== 'F')return that._i[index];
  // frozen object case
  for(entry = that._f; entry; entry = entry.n){
    if(entry.k == key)return entry;
  }
};

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      anInstance(that, C, NAME, '_i');
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear(){
        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
          entry.r = true;
          if(entry.p)entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function(key){
        var that  = this
          , entry = getEntry(that, key);
        if(entry){
          var next = entry.n
            , prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if(prev)prev.n = next;
          if(next)next.p = prev;
          if(that._f == entry)that._f = next;
          if(that._l == entry)that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /*, that = undefined */){
        anInstance(this, C, 'forEach');
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
          , entry;
        while(entry = entry ? entry.n : this._f){
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while(entry && entry.r)entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key){
        return !!getEntry(this, key);
      }
    });
    if(DESCRIPTORS)dP(C.prototype, 'size', {
      get: function(){
        return defined(this[SIZE]);
      }
    });
    return C;
  },
  def: function(that, key, value){
    var entry = getEntry(that, key)
      , prev, index;
    // change existing entry
    if(entry){
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if(!that._f)that._f = entry;
      if(prev)prev.n = entry;
      that[SIZE]++;
      // add to index
      if(index !== 'F')that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function(C, NAME, IS_MAP){
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function(iterated, kind){
      this._t = iterated;  // target
      this._k = kind;      // kind
      this._l = undefined; // previous
    }, function(){
      var that  = this
        , kind  = that._k
        , entry = that._l;
      // revert to the last existing entry
      while(entry && entry.r)entry = entry.p;
      // get next entry
      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if(kind == 'keys'  )return step(0, entry.k);
      if(kind == 'values')return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};
},{"./_an-instance":60,"./_ctx":79,"./_defined":81,"./_descriptors":82,"./_for-of":91,"./_iter-define":107,"./_iter-step":109,"./_meta":116,"./_object-create":120,"./_object-dp":121,"./_redefine-all":140,"./_set-species":145}],74:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = require('./_classof')
  , from    = require('./_array-from-iterable');
module.exports = function(NAME){
  return function toJSON(){
    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};
},{"./_array-from-iterable":64,"./_classof":71}],75:[function(require,module,exports){
'use strict';
var redefineAll       = require('./_redefine-all')
  , getWeak           = require('./_meta').getWeak
  , anObject          = require('./_an-object')
  , isObject          = require('./_is-object')
  , anInstance        = require('./_an-instance')
  , forOf             = require('./_for-of')
  , createArrayMethod = require('./_array-methods')
  , $has              = require('./_has')
  , arrayFind         = createArrayMethod(5)
  , arrayFindIndex    = createArrayMethod(6)
  , id                = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function(that){
  return that._l || (that._l = new UncaughtFrozenStore);
};
var UncaughtFrozenStore = function(){
  this.a = [];
};
var findUncaughtFrozen = function(store, key){
  return arrayFind(store.a, function(it){
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function(key){
    var entry = findUncaughtFrozen(this, key);
    if(entry)return entry[1];
  },
  has: function(key){
    return !!findUncaughtFrozen(this, key);
  },
  set: function(key, value){
    var entry = findUncaughtFrozen(this, key);
    if(entry)entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function(key){
    var index = arrayFindIndex(this.a, function(it){
      return it[0] === key;
    });
    if(~index)this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
    var C = wrapper(function(that, iterable){
      anInstance(that, C, NAME, '_i');
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function(key){
        if(!isObject(key))return false;
        var data = getWeak(key);
        if(data === true)return uncaughtFrozenStore(this)['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key){
        if(!isObject(key))return false;
        var data = getWeak(key);
        if(data === true)return uncaughtFrozenStore(this).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function(that, key, value){
    var data = getWeak(anObject(key), true);
    if(data === true)uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};
},{"./_an-instance":60,"./_an-object":61,"./_array-methods":66,"./_for-of":91,"./_has":93,"./_is-object":103,"./_meta":116,"./_redefine-all":140}],76:[function(require,module,exports){
'use strict';
var global            = require('./_global')
  , $export           = require('./_export')
  , redefine          = require('./_redefine')
  , redefineAll       = require('./_redefine-all')
  , meta              = require('./_meta')
  , forOf             = require('./_for-of')
  , anInstance        = require('./_an-instance')
  , isObject          = require('./_is-object')
  , fails             = require('./_fails')
  , $iterDetect       = require('./_iter-detect')
  , setToStringTag    = require('./_set-to-string-tag')
  , inheritIfRequired = require('./_inherit-if-required');

module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
  var Base  = global[NAME]
    , C     = Base
    , ADDER = IS_MAP ? 'set' : 'add'
    , proto = C && C.prototype
    , O     = {};
  var fixMethod = function(KEY){
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function(a){
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a){
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a){
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a){ fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b){ fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if(typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
    new C().entries().next();
  }))){
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance             = new C
      // early implementations not supports chaining
      , HASNT_CHAINING       = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance
      // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
      , THROWS_ON_PRIMITIVES = fails(function(){ instance.has(1); })
      // most early implementations doesn't supports iterables, most modern - not close it correctly
      , ACCEPT_ITERABLES     = $iterDetect(function(iter){ new C(iter); }) // eslint-disable-line no-new
      // for early implementations -0 and +0 not the same
      , BUGGY_ZERO = !IS_WEAK && fails(function(){
        // V8 ~ Chromium 42- fails only with 5+ elements
        var $instance = new C()
          , index     = 5;
        while(index--)$instance[ADDER](index, index);
        return !$instance.has(-0);
      });
    if(!ACCEPT_ITERABLES){ 
      C = wrapper(function(target, iterable){
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base, target, C);
        if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if(THROWS_ON_PRIMITIVES || BUGGY_ZERO){
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if(BUGGY_ZERO || HASNT_CHAINING)fixMethod(ADDER);
    // weak collections should not contains .clear method
    if(IS_WEAK && proto.clear)delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);

  return C;
};
},{"./_an-instance":60,"./_export":86,"./_fails":88,"./_for-of":91,"./_global":92,"./_inherit-if-required":97,"./_is-object":103,"./_iter-detect":108,"./_meta":116,"./_redefine":141,"./_redefine-all":140,"./_set-to-string-tag":146}],77:[function(require,module,exports){
var core = module.exports = {version: '2.4.0'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef
},{}],78:[function(require,module,exports){
'use strict';
var $defineProperty = require('./_object-dp')
  , createDesc      = require('./_property-desc');

module.exports = function(object, index, value){
  if(index in object)$defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};
},{"./_object-dp":121,"./_property-desc":139}],79:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};
},{"./_a-function":57}],80:[function(require,module,exports){
'use strict';
var anObject    = require('./_an-object')
  , toPrimitive = require('./_to-primitive')
  , NUMBER      = 'number';

module.exports = function(hint){
  if(hint !== 'string' && hint !== NUMBER && hint !== 'default')throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};
},{"./_an-object":61,"./_to-primitive":164}],81:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};
},{}],82:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./_fails":88}],83:[function(require,module,exports){
var isObject = require('./_is-object')
  , document = require('./_global').document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};
},{"./_global":92,"./_is-object":103}],84:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');
},{}],85:[function(require,module,exports){
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys')
  , gOPS    = require('./_object-gops')
  , pIE     = require('./_object-pie');
module.exports = function(it){
  var result     = getKeys(it)
    , getSymbols = gOPS.f;
  if(getSymbols){
    var symbols = getSymbols(it)
      , isEnum  = pIE.f
      , i       = 0
      , key;
    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
  } return result;
};
},{"./_object-gops":127,"./_object-keys":130,"./_object-pie":131}],86:[function(require,module,exports){
var global    = require('./_global')
  , core      = require('./_core')
  , hide      = require('./_hide')
  , redefine  = require('./_redefine')
  , ctx       = require('./_ctx')
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , expProto  = exports[PROTOTYPE] || (exports[PROTOTYPE] = {})
    , key, own, out, exp;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if(target)redefine(target, key, out, type & $export.U);
    // export
    if(exports[key] != out)hide(exports, key, exp);
    if(IS_PROTO && expProto[key] != out)expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library` 
module.exports = $export;
},{"./_core":77,"./_ctx":79,"./_global":92,"./_hide":94,"./_redefine":141}],87:[function(require,module,exports){
var MATCH = require('./_wks')('match');
module.exports = function(KEY){
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch(e){
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch(f){ /* empty */ }
  } return true;
};
},{"./_wks":171}],88:[function(require,module,exports){
module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};
},{}],89:[function(require,module,exports){
'use strict';
var hide     = require('./_hide')
  , redefine = require('./_redefine')
  , fails    = require('./_fails')
  , defined  = require('./_defined')
  , wks      = require('./_wks');

module.exports = function(KEY, length, exec){
  var SYMBOL   = wks(KEY)
    , fns      = exec(defined, SYMBOL, ''[KEY])
    , strfn    = fns[0]
    , rxfn     = fns[1];
  if(fails(function(){
    var O = {};
    O[SYMBOL] = function(){ return 7; };
    return ''[KEY](O) != 7;
  })){
    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function(string, arg){ return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function(string){ return rxfn.call(string, this); }
    );
  }
};
},{"./_defined":81,"./_fails":88,"./_hide":94,"./_redefine":141,"./_wks":171}],90:[function(require,module,exports){
'use strict';
// 21.2.5.3 get RegExp.prototype.flags
var anObject = require('./_an-object');
module.exports = function(){
  var that   = anObject(this)
    , result = '';
  if(that.global)     result += 'g';
  if(that.ignoreCase) result += 'i';
  if(that.multiline)  result += 'm';
  if(that.unicode)    result += 'u';
  if(that.sticky)     result += 'y';
  return result;
};
},{"./_an-object":61}],91:[function(require,module,exports){
var ctx         = require('./_ctx')
  , call        = require('./_iter-call')
  , isArrayIter = require('./_is-array-iter')
  , anObject    = require('./_an-object')
  , toLength    = require('./_to-length')
  , getIterFn   = require('./core.get-iterator-method')
  , BREAK       = {}
  , RETURN      = {};
var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
    , f      = ctx(fn, that, entries ? 2 : 1)
    , index  = 0
    , length, step, iterator, result;
  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if(result === BREAK || result === RETURN)return result;
  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
    result = call(iterator, f, step.value, entries);
    if(result === BREAK || result === RETURN)return result;
  }
};
exports.BREAK  = BREAK;
exports.RETURN = RETURN;
},{"./_an-object":61,"./_ctx":79,"./_is-array-iter":100,"./_iter-call":105,"./_to-length":162,"./core.get-iterator-method":172}],92:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef
},{}],93:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};
},{}],94:[function(require,module,exports){
var dP         = require('./_object-dp')
  , createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function(object, key, value){
  return dP.f(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};
},{"./_descriptors":82,"./_object-dp":121,"./_property-desc":139}],95:[function(require,module,exports){
module.exports = require('./_global').document && document.documentElement;
},{"./_global":92}],96:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function(){
  return Object.defineProperty(require('./_dom-create')('div'), 'a', {get: function(){ return 7; }}).a != 7;
});
},{"./_descriptors":82,"./_dom-create":83,"./_fails":88}],97:[function(require,module,exports){
var isObject       = require('./_is-object')
  , setPrototypeOf = require('./_set-proto').set;
module.exports = function(that, target, C){
  var P, S = target.constructor;
  if(S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf){
    setPrototypeOf(that, P);
  } return that;
};
},{"./_is-object":103,"./_set-proto":144}],98:[function(require,module,exports){
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function(fn, args, that){
  var un = that === undefined;
  switch(args.length){
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return              fn.apply(that, args);
};
},{}],99:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};
},{"./_cof":72}],100:[function(require,module,exports){
// check on default Array iterator
var Iterators  = require('./_iterators')
  , ITERATOR   = require('./_wks')('iterator')
  , ArrayProto = Array.prototype;

module.exports = function(it){
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};
},{"./_iterators":110,"./_wks":171}],101:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg){
  return cof(arg) == 'Array';
};
},{"./_cof":72}],102:[function(require,module,exports){
// 20.1.2.3 Number.isInteger(number)
var isObject = require('./_is-object')
  , floor    = Math.floor;
module.exports = function isInteger(it){
  return !isObject(it) && isFinite(it) && floor(it) === it;
};
},{"./_is-object":103}],103:[function(require,module,exports){
module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};
},{}],104:[function(require,module,exports){
// 7.2.8 IsRegExp(argument)
var isObject = require('./_is-object')
  , cof      = require('./_cof')
  , MATCH    = require('./_wks')('match');
module.exports = function(it){
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};
},{"./_cof":72,"./_is-object":103,"./_wks":171}],105:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function(iterator, fn, value, entries){
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch(e){
    var ret = iterator['return'];
    if(ret !== undefined)anObject(ret.call(iterator));
    throw e;
  }
};
},{"./_an-object":61}],106:[function(require,module,exports){
'use strict';
var create         = require('./_object-create')
  , descriptor     = require('./_property-desc')
  , setToStringTag = require('./_set-to-string-tag')
  , IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function(){ return this; });

module.exports = function(Constructor, NAME, next){
  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
  setToStringTag(Constructor, NAME + ' Iterator');
};
},{"./_hide":94,"./_object-create":120,"./_property-desc":139,"./_set-to-string-tag":146,"./_wks":171}],107:[function(require,module,exports){
'use strict';
var LIBRARY        = require('./_library')
  , $export        = require('./_export')
  , redefine       = require('./_redefine')
  , hide           = require('./_hide')
  , has            = require('./_has')
  , Iterators      = require('./_iterators')
  , $iterCreate    = require('./_iter-create')
  , setToStringTag = require('./_set-to-string-tag')
  , getPrototypeOf = require('./_object-gpo')
  , ITERATOR       = require('./_wks')('iterator')
  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
  , FF_ITERATOR    = '@@iterator'
  , KEYS           = 'keys'
  , VALUES         = 'values';

var returnThis = function(){ return this; };

module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
  $iterCreate(Constructor, NAME, next);
  var getMethod = function(kind){
    if(!BUGGY && kind in proto)return proto[kind];
    switch(kind){
      case KEYS: return function keys(){ return new Constructor(this, kind); };
      case VALUES: return function values(){ return new Constructor(this, kind); };
    } return function entries(){ return new Constructor(this, kind); };
  };
  var TAG        = NAME + ' Iterator'
    , DEF_VALUES = DEFAULT == VALUES
    , VALUES_BUG = false
    , proto      = Base.prototype
    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
    , $default   = $native || getMethod(DEFAULT)
    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
    , methods, key, IteratorPrototype;
  // Fix native
  if($anyNative){
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
    if(IteratorPrototype !== Object.prototype){
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if(DEF_VALUES && $native && $native.name !== VALUES){
    VALUES_BUG = true;
    $default = function values(){ return $native.call(this); };
  }
  // Define iterator
  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG]  = returnThis;
  if(DEFAULT){
    methods = {
      values:  DEF_VALUES ? $default : getMethod(VALUES),
      keys:    IS_SET     ? $default : getMethod(KEYS),
      entries: $entries
    };
    if(FORCED)for(key in methods){
      if(!(key in proto))redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};
},{"./_export":86,"./_has":93,"./_hide":94,"./_iter-create":106,"./_iterators":110,"./_library":112,"./_object-gpo":128,"./_redefine":141,"./_set-to-string-tag":146,"./_wks":171}],108:[function(require,module,exports){
var ITERATOR     = require('./_wks')('iterator')
  , SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function(){ SAFE_CLOSING = true; };
  Array.from(riter, function(){ throw 2; });
} catch(e){ /* empty */ }

module.exports = function(exec, skipClosing){
  if(!skipClosing && !SAFE_CLOSING)return false;
  var safe = false;
  try {
    var arr  = [7]
      , iter = arr[ITERATOR]();
    iter.next = function(){ return {done: safe = true}; };
    arr[ITERATOR] = function(){ return iter; };
    exec(arr);
  } catch(e){ /* empty */ }
  return safe;
};
},{"./_wks":171}],109:[function(require,module,exports){
module.exports = function(done, value){
  return {value: value, done: !!done};
};
},{}],110:[function(require,module,exports){
module.exports = {};
},{}],111:[function(require,module,exports){
var getKeys   = require('./_object-keys')
  , toIObject = require('./_to-iobject');
module.exports = function(object, el){
  var O      = toIObject(object)
    , keys   = getKeys(O)
    , length = keys.length
    , index  = 0
    , key;
  while(length > index)if(O[key = keys[index++]] === el)return key;
};
},{"./_object-keys":130,"./_to-iobject":161}],112:[function(require,module,exports){
module.exports = false;
},{}],113:[function(require,module,exports){
// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = (!$expm1
  // Old FF bug
  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
  // Tor Browser bug
  || $expm1(-2e-17) != -2e-17
) ? function expm1(x){
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;
},{}],114:[function(require,module,exports){
// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x){
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};
},{}],115:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x){
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};
},{}],116:[function(require,module,exports){
var META     = require('./_uid')('meta')
  , isObject = require('./_is-object')
  , has      = require('./_has')
  , setDesc  = require('./_object-dp').f
  , id       = 0;
var isExtensible = Object.isExtensible || function(){
  return true;
};
var FREEZE = !require('./_fails')(function(){
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function(it){
  setDesc(it, META, {value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  }});
};
var fastKey = function(it, create){
  // return primitive with prefix
  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return 'F';
    // not necessary to add metadata
    if(!create)return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function(it, create){
  if(!has(it, META)){
    // can't set metadata to uncaught frozen object
    if(!isExtensible(it))return true;
    // not necessary to add metadata
    if(!create)return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function(it){
  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY:      META,
  NEED:     false,
  fastKey:  fastKey,
  getWeak:  getWeak,
  onFreeze: onFreeze
};
},{"./_fails":88,"./_has":93,"./_is-object":103,"./_object-dp":121,"./_uid":168}],117:[function(require,module,exports){
var Map     = require('./es6.map')
  , $export = require('./_export')
  , shared  = require('./_shared')('metadata')
  , store   = shared.store || (shared.store = new (require('./es6.weak-map')));

var getOrCreateMetadataMap = function(target, targetKey, create){
  var targetMetadata = store.get(target);
  if(!targetMetadata){
    if(!create)return undefined;
    store.set(target, targetMetadata = new Map);
  }
  var keyMetadata = targetMetadata.get(targetKey);
  if(!keyMetadata){
    if(!create)return undefined;
    targetMetadata.set(targetKey, keyMetadata = new Map);
  } return keyMetadata;
};
var ordinaryHasOwnMetadata = function(MetadataKey, O, P){
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
};
var ordinaryGetOwnMetadata = function(MetadataKey, O, P){
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
};
var ordinaryDefineOwnMetadata = function(MetadataKey, MetadataValue, O, P){
  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
};
var ordinaryOwnMetadataKeys = function(target, targetKey){
  var metadataMap = getOrCreateMetadataMap(target, targetKey, false)
    , keys        = [];
  if(metadataMap)metadataMap.forEach(function(_, key){ keys.push(key); });
  return keys;
};
var toMetaKey = function(it){
  return it === undefined || typeof it == 'symbol' ? it : String(it);
};
var exp = function(O){
  $export($export.S, 'Reflect', O);
};

module.exports = {
  store: store,
  map: getOrCreateMetadataMap,
  has: ordinaryHasOwnMetadata,
  get: ordinaryGetOwnMetadata,
  set: ordinaryDefineOwnMetadata,
  keys: ordinaryOwnMetadataKeys,
  key: toMetaKey,
  exp: exp
};
},{"./_export":86,"./_shared":148,"./es6.map":203,"./es6.weak-map":309}],118:[function(require,module,exports){
var global    = require('./_global')
  , macrotask = require('./_task').set
  , Observer  = global.MutationObserver || global.WebKitMutationObserver
  , process   = global.process
  , Promise   = global.Promise
  , isNode    = require('./_cof')(process) == 'process';

module.exports = function(){
  var head, last, notify;

  var flush = function(){
    var parent, fn;
    if(isNode && (parent = process.domain))parent.exit();
    while(head){
      fn   = head.fn;
      head = head.next;
      try {
        fn();
      } catch(e){
        if(head)notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if(parent)parent.enter();
  };

  // Node.js
  if(isNode){
    notify = function(){
      process.nextTick(flush);
    };
  // browsers with MutationObserver
  } else if(Observer){
    var toggle = true
      , node   = document.createTextNode('');
    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
    notify = function(){
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if(Promise && Promise.resolve){
    var promise = Promise.resolve();
    notify = function(){
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function(){
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function(fn){
    var task = {fn: fn, next: undefined};
    if(last)last.next = task;
    if(!head){
      head = task;
      notify();
    } last = task;
  };
};
},{"./_cof":72,"./_global":92,"./_task":158}],119:[function(require,module,exports){
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var getKeys  = require('./_object-keys')
  , gOPS     = require('./_object-gops')
  , pIE      = require('./_object-pie')
  , toObject = require('./_to-object')
  , IObject  = require('./_iobject')
  , $assign  = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function(){
  var A = {}
    , B = {}
    , S = Symbol()
    , K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function(k){ B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source){ // eslint-disable-line no-unused-vars
  var T     = toObject(target)
    , aLen  = arguments.length
    , index = 1
    , getSymbols = gOPS.f
    , isEnum     = pIE.f;
  while(aLen > index){
    var S      = IObject(arguments[index++])
      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)
      , length = keys.length
      , j      = 0
      , key;
    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];
  } return T;
} : $assign;
},{"./_fails":88,"./_iobject":99,"./_object-gops":127,"./_object-keys":130,"./_object-pie":131,"./_to-object":163}],120:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject    = require('./_an-object')
  , dPs         = require('./_object-dps')
  , enumBugKeys = require('./_enum-bug-keys')
  , IE_PROTO    = require('./_shared-key')('IE_PROTO')
  , Empty       = function(){ /* empty */ }
  , PROTOTYPE   = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function(){
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe')
    , i      = enumBugKeys.length
    , lt     = '<'
    , gt     = '>'
    , iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties){
  var result;
  if(O !== null){
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty;
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":61,"./_dom-create":83,"./_enum-bug-keys":84,"./_html":95,"./_object-dps":122,"./_shared-key":147}],121:[function(require,module,exports){
var anObject       = require('./_an-object')
  , IE8_DOM_DEFINE = require('./_ie8-dom-define')
  , toPrimitive    = require('./_to-primitive')
  , dP             = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes){
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if(IE8_DOM_DEFINE)try {
    return dP(O, P, Attributes);
  } catch(e){ /* empty */ }
  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
  if('value' in Attributes)O[P] = Attributes.value;
  return O;
};
},{"./_an-object":61,"./_descriptors":82,"./_ie8-dom-define":96,"./_to-primitive":164}],122:[function(require,module,exports){
var dP       = require('./_object-dp')
  , anObject = require('./_an-object')
  , getKeys  = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties){
  anObject(O);
  var keys   = getKeys(Properties)
    , length = keys.length
    , i = 0
    , P;
  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
  return O;
};
},{"./_an-object":61,"./_descriptors":82,"./_object-dp":121,"./_object-keys":130}],123:[function(require,module,exports){
// Forced replacement prototype accessors methods
module.exports = require('./_library')|| !require('./_fails')(function(){
  var K = Math.random();
  // In FF throws only define methods
  __defineSetter__.call(null, K, function(){ /* empty */});
  delete require('./_global')[K];
});
},{"./_fails":88,"./_global":92,"./_library":112}],124:[function(require,module,exports){
var pIE            = require('./_object-pie')
  , createDesc     = require('./_property-desc')
  , toIObject      = require('./_to-iobject')
  , toPrimitive    = require('./_to-primitive')
  , has            = require('./_has')
  , IE8_DOM_DEFINE = require('./_ie8-dom-define')
  , gOPD           = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P){
  O = toIObject(O);
  P = toPrimitive(P, true);
  if(IE8_DOM_DEFINE)try {
    return gOPD(O, P);
  } catch(e){ /* empty */ }
  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
};
},{"./_descriptors":82,"./_has":93,"./_ie8-dom-define":96,"./_object-pie":131,"./_property-desc":139,"./_to-iobject":161,"./_to-primitive":164}],125:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject')
  , gOPN      = require('./_object-gopn').f
  , toString  = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function(it){
  try {
    return gOPN(it);
  } catch(e){
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it){
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_object-gopn":126,"./_to-iobject":161}],126:[function(require,module,exports){
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys      = require('./_object-keys-internal')
  , hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
  return $keys(O, hiddenKeys);
};
},{"./_enum-bug-keys":84,"./_object-keys-internal":129}],127:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;
},{}],128:[function(require,module,exports){
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has         = require('./_has')
  , toObject    = require('./_to-object')
  , IE_PROTO    = require('./_shared-key')('IE_PROTO')
  , ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function(O){
  O = toObject(O);
  if(has(O, IE_PROTO))return O[IE_PROTO];
  if(typeof O.constructor == 'function' && O instanceof O.constructor){
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};
},{"./_has":93,"./_shared-key":147,"./_to-object":163}],129:[function(require,module,exports){
var has          = require('./_has')
  , toIObject    = require('./_to-iobject')
  , arrayIndexOf = require('./_array-includes')(false)
  , IE_PROTO     = require('./_shared-key')('IE_PROTO');

module.exports = function(object, names){
  var O      = toIObject(object)
    , i      = 0
    , result = []
    , key;
  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while(names.length > i)if(has(O, key = names[i++])){
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};
},{"./_array-includes":65,"./_has":93,"./_shared-key":147,"./_to-iobject":161}],130:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys       = require('./_object-keys-internal')
  , enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O){
  return $keys(O, enumBugKeys);
};
},{"./_enum-bug-keys":84,"./_object-keys-internal":129}],131:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;
},{}],132:[function(require,module,exports){
// most Object methods by ES6 should accept primitives
var $export = require('./_export')
  , core    = require('./_core')
  , fails   = require('./_fails');
module.exports = function(KEY, exec){
  var fn  = (core.Object || {})[KEY] || Object[KEY]
    , exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
};
},{"./_core":77,"./_export":86,"./_fails":88}],133:[function(require,module,exports){
var getKeys   = require('./_object-keys')
  , toIObject = require('./_to-iobject')
  , isEnum    = require('./_object-pie').f;
module.exports = function(isEntries){
  return function(it){
    var O      = toIObject(it)
      , keys   = getKeys(O)
      , length = keys.length
      , i      = 0
      , result = []
      , key;
    while(length > i)if(isEnum.call(O, key = keys[i++])){
      result.push(isEntries ? [key, O[key]] : O[key]);
    } return result;
  };
};
},{"./_object-keys":130,"./_object-pie":131,"./_to-iobject":161}],134:[function(require,module,exports){
// all object keys, includes non-enumerable and symbols
var gOPN     = require('./_object-gopn')
  , gOPS     = require('./_object-gops')
  , anObject = require('./_an-object')
  , Reflect  = require('./_global').Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it){
  var keys       = gOPN.f(anObject(it))
    , getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};
},{"./_an-object":61,"./_global":92,"./_object-gopn":126,"./_object-gops":127}],135:[function(require,module,exports){
var $parseFloat = require('./_global').parseFloat
  , $trim       = require('./_string-trim').trim;

module.exports = 1 / $parseFloat(require('./_string-ws') + '-0') !== -Infinity ? function parseFloat(str){
  var string = $trim(String(str), 3)
    , result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;
},{"./_global":92,"./_string-trim":156,"./_string-ws":157}],136:[function(require,module,exports){
var $parseInt = require('./_global').parseInt
  , $trim     = require('./_string-trim').trim
  , ws        = require('./_string-ws')
  , hex       = /^[\-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix){
  var string = $trim(String(str), 3);
  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt;
},{"./_global":92,"./_string-trim":156,"./_string-ws":157}],137:[function(require,module,exports){
'use strict';
var path      = require('./_path')
  , invoke    = require('./_invoke')
  , aFunction = require('./_a-function');
module.exports = function(/* ...pargs */){
  var fn     = aFunction(this)
    , length = arguments.length
    , pargs  = Array(length)
    , i      = 0
    , _      = path._
    , holder = false;
  while(length > i)if((pargs[i] = arguments[i++]) === _)holder = true;
  return function(/* ...args */){
    var that = this
      , aLen = arguments.length
      , j = 0, k = 0, args;
    if(!holder && !aLen)return invoke(fn, pargs, that);
    args = pargs.slice();
    if(holder)for(;length > j; j++)if(args[j] === _)args[j] = arguments[k++];
    while(aLen > k)args.push(arguments[k++]);
    return invoke(fn, args, that);
  };
};
},{"./_a-function":57,"./_invoke":98,"./_path":138}],138:[function(require,module,exports){
module.exports = require('./_global');
},{"./_global":92}],139:[function(require,module,exports){
module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};
},{}],140:[function(require,module,exports){
var redefine = require('./_redefine');
module.exports = function(target, src, safe){
  for(var key in src)redefine(target, key, src[key], safe);
  return target;
};
},{"./_redefine":141}],141:[function(require,module,exports){
var global    = require('./_global')
  , hide      = require('./_hide')
  , has       = require('./_has')
  , SRC       = require('./_uid')('src')
  , TO_STRING = 'toString'
  , $toString = Function[TO_STRING]
  , TPL       = ('' + $toString).split(TO_STRING);

require('./_core').inspectSource = function(it){
  return $toString.call(it);
};

(module.exports = function(O, key, val, safe){
  var isFunction = typeof val == 'function';
  if(isFunction)has(val, 'name') || hide(val, 'name', key);
  if(O[key] === val)return;
  if(isFunction)has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if(O === global){
    O[key] = val;
  } else {
    if(!safe){
      delete O[key];
      hide(O, key, val);
    } else {
      if(O[key])O[key] = val;
      else hide(O, key, val);
    }
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString(){
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});
},{"./_core":77,"./_global":92,"./_has":93,"./_hide":94,"./_uid":168}],142:[function(require,module,exports){
module.exports = function(regExp, replace){
  var replacer = replace === Object(replace) ? function(part){
    return replace[part];
  } : replace;
  return function(it){
    return String(it).replace(regExp, replacer);
  };
};
},{}],143:[function(require,module,exports){
// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y){
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};
},{}],144:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object')
  , anObject = require('./_an-object');
var check = function(O, proto){
  anObject(O);
  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function(test, buggy, set){
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch(e){ buggy = true; }
      return function setPrototypeOf(O, proto){
        check(O, proto);
        if(buggy)O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};
},{"./_an-object":61,"./_ctx":79,"./_is-object":103,"./_object-gopd":124}],145:[function(require,module,exports){
'use strict';
var global      = require('./_global')
  , dP          = require('./_object-dp')
  , DESCRIPTORS = require('./_descriptors')
  , SPECIES     = require('./_wks')('species');

module.exports = function(KEY){
  var C = global[KEY];
  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
    configurable: true,
    get: function(){ return this; }
  });
};
},{"./_descriptors":82,"./_global":92,"./_object-dp":121,"./_wks":171}],146:[function(require,module,exports){
var def = require('./_object-dp').f
  , has = require('./_has')
  , TAG = require('./_wks')('toStringTag');

module.exports = function(it, tag, stat){
  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
};
},{"./_has":93,"./_object-dp":121,"./_wks":171}],147:[function(require,module,exports){
var shared = require('./_shared')('keys')
  , uid    = require('./_uid');
module.exports = function(key){
  return shared[key] || (shared[key] = uid(key));
};
},{"./_shared":148,"./_uid":168}],148:[function(require,module,exports){
var global = require('./_global')
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};
},{"./_global":92}],149:[function(require,module,exports){
// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject  = require('./_an-object')
  , aFunction = require('./_a-function')
  , SPECIES   = require('./_wks')('species');
module.exports = function(O, D){
  var C = anObject(O).constructor, S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};
},{"./_a-function":57,"./_an-object":61,"./_wks":171}],150:[function(require,module,exports){
var fails = require('./_fails');

module.exports = function(method, arg){
  return !!method && fails(function(){
    arg ? method.call(null, function(){}, 1) : method.call(null);
  });
};
},{"./_fails":88}],151:[function(require,module,exports){
var toInteger = require('./_to-integer')
  , defined   = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function(TO_STRING){
  return function(that, pos){
    var s = String(defined(that))
      , i = toInteger(pos)
      , l = s.length
      , a, b;
    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};
},{"./_defined":81,"./_to-integer":160}],152:[function(require,module,exports){
// helper for String#{startsWith, endsWith, includes}
var isRegExp = require('./_is-regexp')
  , defined  = require('./_defined');

module.exports = function(that, searchString, NAME){
  if(isRegExp(searchString))throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};
},{"./_defined":81,"./_is-regexp":104}],153:[function(require,module,exports){
var $export = require('./_export')
  , fails   = require('./_fails')
  , defined = require('./_defined')
  , quot    = /"/g;
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
var createHTML = function(string, tag, attribute, value) {
  var S  = String(defined(string))
    , p1 = '<' + tag;
  if(attribute !== '')p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function(NAME, exec){
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function(){
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};
},{"./_defined":81,"./_export":86,"./_fails":88}],154:[function(require,module,exports){
// https://github.com/tc39/proposal-string-pad-start-end
var toLength = require('./_to-length')
  , repeat   = require('./_string-repeat')
  , defined  = require('./_defined');

module.exports = function(that, maxLength, fillString, left){
  var S            = String(defined(that))
    , stringLength = S.length
    , fillStr      = fillString === undefined ? ' ' : String(fillString)
    , intMaxLength = toLength(maxLength);
  if(intMaxLength <= stringLength || fillStr == '')return S;
  var fillLen = intMaxLength - stringLength
    , stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if(stringFiller.length > fillLen)stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};

},{"./_defined":81,"./_string-repeat":155,"./_to-length":162}],155:[function(require,module,exports){
'use strict';
var toInteger = require('./_to-integer')
  , defined   = require('./_defined');

module.exports = function repeat(count){
  var str = String(defined(this))
    , res = ''
    , n   = toInteger(count);
  if(n < 0 || n == Infinity)throw RangeError("Count can't be negative");
  for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;
  return res;
};
},{"./_defined":81,"./_to-integer":160}],156:[function(require,module,exports){
var $export = require('./_export')
  , defined = require('./_defined')
  , fails   = require('./_fails')
  , spaces  = require('./_string-ws')
  , space   = '[' + spaces + ']'
  , non     = '\u200b\u0085'
  , ltrim   = RegExp('^' + space + space + '*')
  , rtrim   = RegExp(space + space + '*$');

var exporter = function(KEY, exec, ALIAS){
  var exp   = {};
  var FORCE = fails(function(){
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if(ALIAS)exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function(string, TYPE){
  string = String(defined(string));
  if(TYPE & 1)string = string.replace(ltrim, '');
  if(TYPE & 2)string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;
},{"./_defined":81,"./_export":86,"./_fails":88,"./_string-ws":157}],157:[function(require,module,exports){
module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';
},{}],158:[function(require,module,exports){
var ctx                = require('./_ctx')
  , invoke             = require('./_invoke')
  , html               = require('./_html')
  , cel                = require('./_dom-create')
  , global             = require('./_global')
  , process            = global.process
  , setTask            = global.setImmediate
  , clearTask          = global.clearImmediate
  , MessageChannel     = global.MessageChannel
  , counter            = 0
  , queue              = {}
  , ONREADYSTATECHANGE = 'onreadystatechange'
  , defer, channel, port;
var run = function(){
  var id = +this;
  if(queue.hasOwnProperty(id)){
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function(event){
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if(!setTask || !clearTask){
  setTask = function setImmediate(fn){
    var args = [], i = 1;
    while(arguments.length > i)args.push(arguments[i++]);
    queue[++counter] = function(){
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id){
    delete queue[id];
  };
  // Node.js 0.8-
  if(require('./_cof')(process) == 'process'){
    defer = function(id){
      process.nextTick(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if(MessageChannel){
    channel = new MessageChannel;
    port    = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
    defer = function(id){
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if(ONREADYSTATECHANGE in cel('script')){
    defer = function(id){
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function(id){
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set:   setTask,
  clear: clearTask
};
},{"./_cof":72,"./_ctx":79,"./_dom-create":83,"./_global":92,"./_html":95,"./_invoke":98}],159:[function(require,module,exports){
var toInteger = require('./_to-integer')
  , max       = Math.max
  , min       = Math.min;
module.exports = function(index, length){
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};
},{"./_to-integer":160}],160:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};
},{}],161:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject')
  , defined = require('./_defined');
module.exports = function(it){
  return IObject(defined(it));
};
},{"./_defined":81,"./_iobject":99}],162:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer')
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};
},{"./_to-integer":160}],163:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function(it){
  return Object(defined(it));
};
},{"./_defined":81}],164:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function(it, S){
  if(!isObject(it))return it;
  var fn, val;
  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to primitive value");
};
},{"./_is-object":103}],165:[function(require,module,exports){
'use strict';
if(require('./_descriptors')){
  var LIBRARY             = require('./_library')
    , global              = require('./_global')
    , fails               = require('./_fails')
    , $export             = require('./_export')
    , $typed              = require('./_typed')
    , $buffer             = require('./_typed-buffer')
    , ctx                 = require('./_ctx')
    , anInstance          = require('./_an-instance')
    , propertyDesc        = require('./_property-desc')
    , hide                = require('./_hide')
    , redefineAll         = require('./_redefine-all')
    , toInteger           = require('./_to-integer')
    , toLength            = require('./_to-length')
    , toIndex             = require('./_to-index')
    , toPrimitive         = require('./_to-primitive')
    , has                 = require('./_has')
    , same                = require('./_same-value')
    , classof             = require('./_classof')
    , isObject            = require('./_is-object')
    , toObject            = require('./_to-object')
    , isArrayIter         = require('./_is-array-iter')
    , create              = require('./_object-create')
    , getPrototypeOf      = require('./_object-gpo')
    , gOPN                = require('./_object-gopn').f
    , getIterFn           = require('./core.get-iterator-method')
    , uid                 = require('./_uid')
    , wks                 = require('./_wks')
    , createArrayMethod   = require('./_array-methods')
    , createArrayIncludes = require('./_array-includes')
    , speciesConstructor  = require('./_species-constructor')
    , ArrayIterators      = require('./es6.array.iterator')
    , Iterators           = require('./_iterators')
    , $iterDetect         = require('./_iter-detect')
    , setSpecies          = require('./_set-species')
    , arrayFill           = require('./_array-fill')
    , arrayCopyWithin     = require('./_array-copy-within')
    , $DP                 = require('./_object-dp')
    , $GOPD               = require('./_object-gopd')
    , dP                  = $DP.f
    , gOPD                = $GOPD.f
    , RangeError          = global.RangeError
    , TypeError           = global.TypeError
    , Uint8Array          = global.Uint8Array
    , ARRAY_BUFFER        = 'ArrayBuffer'
    , SHARED_BUFFER       = 'Shared' + ARRAY_BUFFER
    , BYTES_PER_ELEMENT   = 'BYTES_PER_ELEMENT'
    , PROTOTYPE           = 'prototype'
    , ArrayProto          = Array[PROTOTYPE]
    , $ArrayBuffer        = $buffer.ArrayBuffer
    , $DataView           = $buffer.DataView
    , arrayForEach        = createArrayMethod(0)
    , arrayFilter         = createArrayMethod(2)
    , arraySome           = createArrayMethod(3)
    , arrayEvery          = createArrayMethod(4)
    , arrayFind           = createArrayMethod(5)
    , arrayFindIndex      = createArrayMethod(6)
    , arrayIncludes       = createArrayIncludes(true)
    , arrayIndexOf        = createArrayIncludes(false)
    , arrayValues         = ArrayIterators.values
    , arrayKeys           = ArrayIterators.keys
    , arrayEntries        = ArrayIterators.entries
    , arrayLastIndexOf    = ArrayProto.lastIndexOf
    , arrayReduce         = ArrayProto.reduce
    , arrayReduceRight    = ArrayProto.reduceRight
    , arrayJoin           = ArrayProto.join
    , arraySort           = ArrayProto.sort
    , arraySlice          = ArrayProto.slice
    , arrayToString       = ArrayProto.toString
    , arrayToLocaleString = ArrayProto.toLocaleString
    , ITERATOR            = wks('iterator')
    , TAG                 = wks('toStringTag')
    , TYPED_CONSTRUCTOR   = uid('typed_constructor')
    , DEF_CONSTRUCTOR     = uid('def_constructor')
    , ALL_CONSTRUCTORS    = $typed.CONSTR
    , TYPED_ARRAY         = $typed.TYPED
    , VIEW                = $typed.VIEW
    , WRONG_LENGTH        = 'Wrong length!';

  var $map = createArrayMethod(1, function(O, length){
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function(){
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function(){
    new Uint8Array(1).set({});
  });

  var strictToLength = function(it, SAME){
    if(it === undefined)throw TypeError(WRONG_LENGTH);
    var number = +it
      , length = toLength(it);
    if(SAME && !same(number, length))throw RangeError(WRONG_LENGTH);
    return length;
  };

  var toOffset = function(it, BYTES){
    var offset = toInteger(it);
    if(offset < 0 || offset % BYTES)throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function(it){
    if(isObject(it) && TYPED_ARRAY in it)return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function(C, length){
    if(!(isObject(C) && TYPED_CONSTRUCTOR in C)){
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function(O, list){
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function(C, list){
    var index  = 0
      , length = list.length
      , result = allocate(C, length);
    while(length > index)result[index] = list[index++];
    return result;
  };

  var addGetter = function(it, key, internal){
    dP(it, key, {get: function(){ return this._d[internal]; }});
  };

  var $from = function from(source /*, mapfn, thisArg */){
    var O       = toObject(source)
      , aLen    = arguments.length
      , mapfn   = aLen > 1 ? arguments[1] : undefined
      , mapping = mapfn !== undefined
      , iterFn  = getIterFn(O)
      , i, length, values, result, step, iterator;
    if(iterFn != undefined && !isArrayIter(iterFn)){
      for(iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++){
        values.push(step.value);
      } O = values;
    }
    if(mapping && aLen > 2)mapfn = ctx(mapfn, arguments[2], 2);
    for(i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++){
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/*...items*/){
    var index  = 0
      , length = arguments.length
      , result = allocate(this, length);
    while(length > index)result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function(){ arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString(){
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /*, end */){
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /*, thisArg */){
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /*, start, end */){ // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /*, thisArg */){
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /*, thisArg */){
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /*, thisArg */){
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /*, thisArg */){
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /*, fromIndex */){
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /*, fromIndex */){
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator){ // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /*, fromIndex */){ // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /*, thisArg */){
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse(){
      var that   = this
        , length = validate(that).length
        , middle = Math.floor(length / 2)
        , index  = 0
        , value;
      while(index < middle){
        value         = that[index];
        that[index++] = that[--length];
        that[length]  = value;
      } return that;
    },
    some: function some(callbackfn /*, thisArg */){
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn){
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end){
      var O      = validate(this)
        , length = O.length
        , $begin = toIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end){
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /*, offset */){
    validate(this);
    var offset = toOffset(arguments[1], 1)
      , length = this.length
      , src    = toObject(arrayLike)
      , len    = toLength(src.length)
      , index  = 0;
    if(len + offset > length)throw RangeError(WRONG_LENGTH);
    while(index < len)this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries(){
      return arrayEntries.call(validate(this));
    },
    keys: function keys(){
      return arrayKeys.call(validate(this));
    },
    values: function values(){
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function(target, key){
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key){
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc){
    if(isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ){
      target[key] = desc.value;
      return target;
    } else return dP(target, key, desc);
  };

  if(!ALL_CONSTRUCTORS){
    $GOPD.f = $getDesc;
    $DP.f   = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty:           $setDesc
  });

  if(fails(function(){ arrayToString.call({}); })){
    arrayToString = arrayToLocaleString = function toString(){
      return arrayJoin.call(this);
    }
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice:          $slice,
    set:            $set,
    constructor:    function(){ /* noop */ },
    toString:       arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function(){ return this[TYPED_ARRAY]; }
  });

  module.exports = function(KEY, BYTES, wrapper, CLAMPED){
    CLAMPED = !!CLAMPED;
    var NAME       = KEY + (CLAMPED ? 'Clamped' : '') + 'Array'
      , ISNT_UINT8 = NAME != 'Uint8Array'
      , GETTER     = 'get' + KEY
      , SETTER     = 'set' + KEY
      , TypedArray = global[NAME]
      , Base       = TypedArray || {}
      , TAC        = TypedArray && getPrototypeOf(TypedArray)
      , FORCED     = !TypedArray || !$typed.ABV
      , O          = {}
      , TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function(that, index){
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function(that, index, value){
      var data = that._d;
      if(CLAMPED)value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function(that, index){
      dP(that, index, {
        get: function(){
          return getter(this, index);
        },
        set: function(value){
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if(FORCED){
      TypedArray = wrapper(function(that, data, $offset, $length){
        anInstance(that, TypedArray, NAME, '_d');
        var index  = 0
          , offset = 0
          , buffer, byteLength, length, klass;
        if(!isObject(data)){
          length     = strictToLength(data, true)
          byteLength = length * BYTES;
          buffer     = new $ArrayBuffer(byteLength);
        } else if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if($length === undefined){
            if($len % BYTES)throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if(byteLength < 0)throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if(byteLength + offset > $len)throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if(TYPED_ARRAY in data){
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while(index < length)addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if(!$iterDetect(function(iter){
      // V8 works with iterators, but fails in many other cases
      // https://code.google.com/p/v8/issues/detail?id=4552
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)){
      TypedArray = wrapper(function(that, data, $offset, $length){
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if(!isObject(data))return new Base(strictToLength(data, ISNT_UINT8));
        if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if(TYPED_ARRAY in data)return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function(key){
        if(!(key in TypedArray))hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if(!LIBRARY)TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator   = TypedArrayPrototype[ITERATOR]
      , CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined)
      , $iterator         = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if(CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)){
      dP(TypedArrayPrototype, TAG, {
        get: function(){ return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES,
      from: $from,
      of: $of
    });

    if(!(BYTES_PER_ELEMENT in TypedArrayPrototype))hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, {set: $set});

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    $export($export.P + $export.F * (TypedArrayPrototype.toString != arrayToString), NAME, {toString: arrayToString});

    $export($export.P + $export.F * fails(function(){
      new TypedArray(1).slice();
    }), NAME, {slice: $slice});

    $export($export.P + $export.F * (fails(function(){
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString()
    }) || !fails(function(){
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, {toLocaleString: $toLocaleString});

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if(!LIBRARY && !CORRECT_ITER_NAME)hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function(){ /* empty */ };
},{"./_an-instance":60,"./_array-copy-within":62,"./_array-fill":63,"./_array-includes":65,"./_array-methods":66,"./_classof":71,"./_ctx":79,"./_descriptors":82,"./_export":86,"./_fails":88,"./_global":92,"./_has":93,"./_hide":94,"./_is-array-iter":100,"./_is-object":103,"./_iter-detect":108,"./_iterators":110,"./_library":112,"./_object-create":120,"./_object-dp":121,"./_object-gopd":124,"./_object-gopn":126,"./_object-gpo":128,"./_property-desc":139,"./_redefine-all":140,"./_same-value":143,"./_set-species":145,"./_species-constructor":149,"./_to-index":159,"./_to-integer":160,"./_to-length":162,"./_to-object":163,"./_to-primitive":164,"./_typed":167,"./_typed-buffer":166,"./_uid":168,"./_wks":171,"./core.get-iterator-method":172,"./es6.array.iterator":184}],166:[function(require,module,exports){
'use strict';
var global         = require('./_global')
  , DESCRIPTORS    = require('./_descriptors')
  , LIBRARY        = require('./_library')
  , $typed         = require('./_typed')
  , hide           = require('./_hide')
  , redefineAll    = require('./_redefine-all')
  , fails          = require('./_fails')
  , anInstance     = require('./_an-instance')
  , toInteger      = require('./_to-integer')
  , toLength       = require('./_to-length')
  , gOPN           = require('./_object-gopn').f
  , dP             = require('./_object-dp').f
  , arrayFill      = require('./_array-fill')
  , setToStringTag = require('./_set-to-string-tag')
  , ARRAY_BUFFER   = 'ArrayBuffer'
  , DATA_VIEW      = 'DataView'
  , PROTOTYPE      = 'prototype'
  , WRONG_LENGTH   = 'Wrong length!'
  , WRONG_INDEX    = 'Wrong index!'
  , $ArrayBuffer   = global[ARRAY_BUFFER]
  , $DataView      = global[DATA_VIEW]
  , Math           = global.Math
  , RangeError     = global.RangeError
  , Infinity       = global.Infinity
  , BaseBuffer     = $ArrayBuffer
  , abs            = Math.abs
  , pow            = Math.pow
  , floor          = Math.floor
  , log            = Math.log
  , LN2            = Math.LN2
  , BUFFER         = 'buffer'
  , BYTE_LENGTH    = 'byteLength'
  , BYTE_OFFSET    = 'byteOffset'
  , $BUFFER        = DESCRIPTORS ? '_b' : BUFFER
  , $LENGTH        = DESCRIPTORS ? '_l' : BYTE_LENGTH
  , $OFFSET        = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
var packIEEE754 = function(value, mLen, nBytes){
  var buffer = Array(nBytes)
    , eLen   = nBytes * 8 - mLen - 1
    , eMax   = (1 << eLen) - 1
    , eBias  = eMax >> 1
    , rt     = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0
    , i      = 0
    , s      = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0
    , e, m, c;
  value = abs(value)
  if(value != value || value === Infinity){
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if(value * (c = pow(2, -e)) < 1){
      e--;
      c *= 2;
    }
    if(e + eBias >= 1){
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if(value * c >= 2){
      e++;
      c /= 2;
    }
    if(e + eBias >= eMax){
      m = 0;
      e = eMax;
    } else if(e + eBias >= 1){
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for(; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for(; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
};
var unpackIEEE754 = function(buffer, mLen, nBytes){
  var eLen  = nBytes * 8 - mLen - 1
    , eMax  = (1 << eLen) - 1
    , eBias = eMax >> 1
    , nBits = eLen - 7
    , i     = nBytes - 1
    , s     = buffer[i--]
    , e     = s & 127
    , m;
  s >>= 7;
  for(; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for(; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if(e === 0){
    e = 1 - eBias;
  } else if(e === eMax){
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
};

var unpackI32 = function(bytes){
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
};
var packI8 = function(it){
  return [it & 0xff];
};
var packI16 = function(it){
  return [it & 0xff, it >> 8 & 0xff];
};
var packI32 = function(it){
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
};
var packF64 = function(it){
  return packIEEE754(it, 52, 8);
};
var packF32 = function(it){
  return packIEEE754(it, 23, 4);
};

var addGetter = function(C, key, internal){
  dP(C[PROTOTYPE], key, {get: function(){ return this[internal]; }});
};

var get = function(view, bytes, index, isLittleEndian){
  var numIndex = +index
    , intIndex = toInteger(numIndex);
  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b
    , start = intIndex + view[$OFFSET]
    , pack  = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
};
var set = function(view, bytes, index, conversion, value, isLittleEndian){
  var numIndex = +index
    , intIndex = toInteger(numIndex);
  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b
    , start = intIndex + view[$OFFSET]
    , pack  = conversion(+value);
  for(var i = 0; i < bytes; i++)store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
};

var validateArrayBufferArguments = function(that, length){
  anInstance(that, $ArrayBuffer, ARRAY_BUFFER);
  var numberLength = +length
    , byteLength   = toLength(numberLength);
  if(numberLength != byteLength)throw RangeError(WRONG_LENGTH);
  return byteLength;
};

if(!$typed.ABV){
  $ArrayBuffer = function ArrayBuffer(length){
    var byteLength = validateArrayBufferArguments(this, length);
    this._b       = arrayFill.call(Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength){
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH]
      , offset       = toInteger(byteOffset);
    if(offset < 0 || offset > bufferLength)throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if(offset + byteLength > bufferLength)throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if(DESCRIPTORS){
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset){
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset){
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /*, littleEndian */){
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /*, littleEndian */){
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /*, littleEndian */){
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /*, littleEndian */){
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /*, littleEndian */){
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /*, littleEndian */){
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value){
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value){
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /*, littleEndian */){
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /*, littleEndian */){
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /*, littleEndian */){
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /*, littleEndian */){
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /*, littleEndian */){
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /*, littleEndian */){
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if(!fails(function(){
    new $ArrayBuffer;     // eslint-disable-line no-new
  }) || !fails(function(){
    new $ArrayBuffer(.5); // eslint-disable-line no-new
  })){
    $ArrayBuffer = function ArrayBuffer(length){
      return new BaseBuffer(validateArrayBufferArguments(this, length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for(var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j; ){
      if(!((key = keys[j++]) in $ArrayBuffer))hide($ArrayBuffer, key, BaseBuffer[key]);
    };
    if(!LIBRARY)ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2))
    , $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if(view.getInt8(0) || !view.getInt8(1))redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value){
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value){
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;
},{"./_an-instance":60,"./_array-fill":63,"./_descriptors":82,"./_fails":88,"./_global":92,"./_hide":94,"./_library":112,"./_object-dp":121,"./_object-gopn":126,"./_redefine-all":140,"./_set-to-string-tag":146,"./_to-integer":160,"./_to-length":162,"./_typed":167}],167:[function(require,module,exports){
var global = require('./_global')
  , hide   = require('./_hide')
  , uid    = require('./_uid')
  , TYPED  = uid('typed_array')
  , VIEW   = uid('view')
  , ABV    = !!(global.ArrayBuffer && global.DataView)
  , CONSTR = ABV
  , i = 0, l = 9, Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while(i < l){
  if(Typed = global[TypedArrayConstructors[i++]]){
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV:    ABV,
  CONSTR: CONSTR,
  TYPED:  TYPED,
  VIEW:   VIEW
};
},{"./_global":92,"./_hide":94,"./_uid":168}],168:[function(require,module,exports){
var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};
},{}],169:[function(require,module,exports){
var global         = require('./_global')
  , core           = require('./_core')
  , LIBRARY        = require('./_library')
  , wksExt         = require('./_wks-ext')
  , defineProperty = require('./_object-dp').f;
module.exports = function(name){
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
};
},{"./_core":77,"./_global":92,"./_library":112,"./_object-dp":121,"./_wks-ext":170}],170:[function(require,module,exports){
exports.f = require('./_wks');
},{"./_wks":171}],171:[function(require,module,exports){
var store      = require('./_shared')('wks')
  , uid        = require('./_uid')
  , Symbol     = require('./_global').Symbol
  , USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function(name){
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;
},{"./_global":92,"./_shared":148,"./_uid":168}],172:[function(require,module,exports){
var classof   = require('./_classof')
  , ITERATOR  = require('./_wks')('iterator')
  , Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function(it){
  if(it != undefined)return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};
},{"./_classof":71,"./_core":77,"./_iterators":110,"./_wks":171}],173:[function(require,module,exports){
// https://github.com/benjamingr/RexExp.escape
var $export = require('./_export')
  , $re     = require('./_replacer')(/[\\^$*+?.()|[\]{}]/g, '\\$&');

$export($export.S, 'RegExp', {escape: function escape(it){ return $re(it); }});

},{"./_export":86,"./_replacer":142}],174:[function(require,module,exports){
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', {copyWithin: require('./_array-copy-within')});

require('./_add-to-unscopables')('copyWithin');
},{"./_add-to-unscopables":59,"./_array-copy-within":62,"./_export":86}],175:[function(require,module,exports){
'use strict';
var $export = require('./_export')
  , $every  = require('./_array-methods')(4);

$export($export.P + $export.F * !require('./_strict-method')([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn /* , thisArg */){
    return $every(this, callbackfn, arguments[1]);
  }
});
},{"./_array-methods":66,"./_export":86,"./_strict-method":150}],176:[function(require,module,exports){
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', {fill: require('./_array-fill')});

require('./_add-to-unscopables')('fill');
},{"./_add-to-unscopables":59,"./_array-fill":63,"./_export":86}],177:[function(require,module,exports){
'use strict';
var $export = require('./_export')
  , $filter = require('./_array-methods')(2);

$export($export.P + $export.F * !require('./_strict-method')([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn /* , thisArg */){
    return $filter(this, callbackfn, arguments[1]);
  }
});
},{"./_array-methods":66,"./_export":86,"./_strict-method":150}],178:[function(require,module,exports){
'use strict';
// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = require('./_export')
  , $find   = require('./_array-methods')(6)
  , KEY     = 'findIndex'
  , forced  = true;
// Shouldn't skip holes
if(KEY in [])Array(1)[KEY](function(){ forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn/*, that = undefined */){
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);
},{"./_add-to-unscopables":59,"./_array-methods":66,"./_export":86}],179:[function(require,module,exports){
'use strict';
// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = require('./_export')
  , $find   = require('./_array-methods')(5)
  , KEY     = 'find'
  , forced  = true;
// Shouldn't skip holes
if(KEY in [])Array(1)[KEY](function(){ forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn/*, that = undefined */){
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);
},{"./_add-to-unscopables":59,"./_array-methods":66,"./_export":86}],180:[function(require,module,exports){
'use strict';
var $export  = require('./_export')
  , $forEach = require('./_array-methods')(0)
  , STRICT   = require('./_strict-method')([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */){
    return $forEach(this, callbackfn, arguments[1]);
  }
});
},{"./_array-methods":66,"./_export":86,"./_strict-method":150}],181:[function(require,module,exports){
'use strict';
var ctx            = require('./_ctx')
  , $export        = require('./_export')
  , toObject       = require('./_to-object')
  , call           = require('./_iter-call')
  , isArrayIter    = require('./_is-array-iter')
  , toLength       = require('./_to-length')
  , createProperty = require('./_create-property')
  , getIterFn      = require('./core.get-iterator-method');

$export($export.S + $export.F * !require('./_iter-detect')(function(iter){ Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
    var O       = toObject(arrayLike)
      , C       = typeof this == 'function' ? this : Array
      , aLen    = arguments.length
      , mapfn   = aLen > 1 ? arguments[1] : undefined
      , mapping = mapfn !== undefined
      , index   = 0
      , iterFn  = getIterFn(O)
      , length, result, step, iterator;
    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for(result = new C(length); length > index; index++){
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

},{"./_create-property":78,"./_ctx":79,"./_export":86,"./_is-array-iter":100,"./_iter-call":105,"./_iter-detect":108,"./_to-length":162,"./_to-object":163,"./core.get-iterator-method":172}],182:[function(require,module,exports){
'use strict';
var $export       = require('./_export')
  , $indexOf      = require('./_array-includes')(false)
  , $native       = [].indexOf
  , NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement /*, fromIndex = 0 */){
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? $native.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments[1]);
  }
});
},{"./_array-includes":65,"./_export":86,"./_strict-method":150}],183:[function(require,module,exports){
// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = require('./_export');

$export($export.S, 'Array', {isArray: require('./_is-array')});
},{"./_export":86,"./_is-array":101}],184:[function(require,module,exports){
'use strict';
var addToUnscopables = require('./_add-to-unscopables')
  , step             = require('./_iter-step')
  , Iterators        = require('./_iterators')
  , toIObject        = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function(iterated, kind){
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , kind  = this._k
    , index = this._i++;
  if(!O || index >= O.length){
    this._t = undefined;
    return step(1);
  }
  if(kind == 'keys'  )return step(0, index);
  if(kind == 'values')return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');
},{"./_add-to-unscopables":59,"./_iter-define":107,"./_iter-step":109,"./_iterators":110,"./_to-iobject":161}],185:[function(require,module,exports){
'use strict';
// 22.1.3.13 Array.prototype.join(separator)
var $export   = require('./_export')
  , toIObject = require('./_to-iobject')
  , arrayJoin = [].join;

// fallback for not array-like strings
$export($export.P + $export.F * (require('./_iobject') != Object || !require('./_strict-method')(arrayJoin)), 'Array', {
  join: function join(separator){
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});
},{"./_export":86,"./_iobject":99,"./_strict-method":150,"./_to-iobject":161}],186:[function(require,module,exports){
'use strict';
var $export       = require('./_export')
  , toIObject     = require('./_to-iobject')
  , toInteger     = require('./_to-integer')
  , toLength      = require('./_to-length')
  , $native       = [].lastIndexOf
  , NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement /*, fromIndex = @[*-1] */){
    // convert -0 to +0
    if(NEGATIVE_ZERO)return $native.apply(this, arguments) || 0;
    var O      = toIObject(this)
      , length = toLength(O.length)
      , index  = length - 1;
    if(arguments.length > 1)index = Math.min(index, toInteger(arguments[1]));
    if(index < 0)index = length + index;
    for(;index >= 0; index--)if(index in O)if(O[index] === searchElement)return index || 0;
    return -1;
  }
});
},{"./_export":86,"./_strict-method":150,"./_to-integer":160,"./_to-iobject":161,"./_to-length":162}],187:[function(require,module,exports){
'use strict';
var $export = require('./_export')
  , $map    = require('./_array-methods')(1);

$export($export.P + $export.F * !require('./_strict-method')([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn /* , thisArg */){
    return $map(this, callbackfn, arguments[1]);
  }
});
},{"./_array-methods":66,"./_export":86,"./_strict-method":150}],188:[function(require,module,exports){
'use strict';
var $export        = require('./_export')
  , createProperty = require('./_create-property');

// WebKit Array.of isn't generic
$export($export.S + $export.F * require('./_fails')(function(){
  function F(){}
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */){
    var index  = 0
      , aLen   = arguments.length
      , result = new (typeof this == 'function' ? this : Array)(aLen);
    while(aLen > index)createProperty(result, index, arguments[index++]);
    result.length = aLen;
    return result;
  }
});
},{"./_create-property":78,"./_export":86,"./_fails":88}],189:[function(require,module,exports){
'use strict';
var $export = require('./_export')
  , $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn /* , initialValue */){
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});
},{"./_array-reduce":67,"./_export":86,"./_strict-method":150}],190:[function(require,module,exports){
'use strict';
var $export = require('./_export')
  , $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */){
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});
},{"./_array-reduce":67,"./_export":86,"./_strict-method":150}],191:[function(require,module,exports){
'use strict';
var $export    = require('./_export')
  , html       = require('./_html')
  , cof        = require('./_cof')
  , toIndex    = require('./_to-index')
  , toLength   = require('./_to-length')
  , arraySlice = [].slice;

// fallback for not array-like ES3 strings and DOM objects
$export($export.P + $export.F * require('./_fails')(function(){
  if(html)arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end){
    var len   = toLength(this.length)
      , klass = cof(this);
    end = end === undefined ? len : end;
    if(klass == 'Array')return arraySlice.call(this, begin, end);
    var start  = toIndex(begin, len)
      , upTo   = toIndex(end, len)
      , size   = toLength(upTo - start)
      , cloned = Array(size)
      , i      = 0;
    for(; i < size; i++)cloned[i] = klass == 'String'
      ? this.charAt(start + i)
      : this[start + i];
    return cloned;
  }
});
},{"./_cof":72,"./_export":86,"./_fails":88,"./_html":95,"./_to-index":159,"./_to-length":162}],192:[function(require,module,exports){
'use strict';
var $export = require('./_export')
  , $some   = require('./_array-methods')(3);

$export($export.P + $export.F * !require('./_strict-method')([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn /* , thisArg */){
    return $some(this, callbackfn, arguments[1]);
  }
});
},{"./_array-methods":66,"./_export":86,"./_strict-method":150}],193:[function(require,module,exports){
'use strict';
var $export   = require('./_export')
  , aFunction = require('./_a-function')
  , toObject  = require('./_to-object')
  , fails     = require('./_fails')
  , $sort     = [].sort
  , test      = [1, 2, 3];

$export($export.P + $export.F * (fails(function(){
  // IE8-
  test.sort(undefined);
}) || !fails(function(){
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !require('./_strict-method')($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn){
    return comparefn === undefined
      ? $sort.call(toObject(this))
      : $sort.call(toObject(this), aFunction(comparefn));
  }
});
},{"./_a-function":57,"./_export":86,"./_fails":88,"./_strict-method":150,"./_to-object":163}],194:[function(require,module,exports){
require('./_set-species')('Array');
},{"./_set-species":145}],195:[function(require,module,exports){
// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = require('./_export');

$export($export.S, 'Date', {now: function(){ return new Date().getTime(); }});
},{"./_export":86}],196:[function(require,module,exports){
'use strict';
// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = require('./_export')
  , fails   = require('./_fails')
  , getTime = Date.prototype.getTime;

var lz = function(num){
  return num > 9 ? num : '0' + num;
};

// PhantomJS / old WebKit has a broken implementations
$export($export.P + $export.F * (fails(function(){
  return new Date(-5e13 - 1).toISOString() != '0385-07-25T07:06:39.999Z';
}) || !fails(function(){
  new Date(NaN).toISOString();
})), 'Date', {
  toISOString: function toISOString(){
    if(!isFinite(getTime.call(this)))throw RangeError('Invalid time value');
    var d = this
      , y = d.getUTCFullYear()
      , m = d.getUTCMilliseconds()
      , s = y < 0 ? '-' : y > 9999 ? '+' : '';
    return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
      '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
      'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
      ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
  }
});
},{"./_export":86,"./_fails":88}],197:[function(require,module,exports){
'use strict';
var $export     = require('./_export')
  , toObject    = require('./_to-object')
  , toPrimitive = require('./_to-primitive');

$export($export.P + $export.F * require('./_fails')(function(){
  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({toISOString: function(){ return 1; }}) !== 1;
}), 'Date', {
  toJSON: function toJSON(key){
    var O  = toObject(this)
      , pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});
},{"./_export":86,"./_fails":88,"./_to-object":163,"./_to-primitive":164}],198:[function(require,module,exports){
var TO_PRIMITIVE = require('./_wks')('toPrimitive')
  , proto        = Date.prototype;

if(!(TO_PRIMITIVE in proto))require('./_hide')(proto, TO_PRIMITIVE, require('./_date-to-primitive'));
},{"./_date-to-primitive":80,"./_hide":94,"./_wks":171}],199:[function(require,module,exports){
var DateProto    = Date.prototype
  , INVALID_DATE = 'Invalid Date'
  , TO_STRING    = 'toString'
  , $toString    = DateProto[TO_STRING]
  , getTime      = DateProto.getTime;
if(new Date(NaN) + '' != INVALID_DATE){
  require('./_redefine')(DateProto, TO_STRING, function toString(){
    var value = getTime.call(this);
    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}
},{"./_redefine":141}],200:[function(require,module,exports){
// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = require('./_export');

$export($export.P, 'Function', {bind: require('./_bind')});
},{"./_bind":70,"./_export":86}],201:[function(require,module,exports){
'use strict';
var isObject       = require('./_is-object')
  , getPrototypeOf = require('./_object-gpo')
  , HAS_INSTANCE   = require('./_wks')('hasInstance')
  , FunctionProto  = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if(!(HAS_INSTANCE in FunctionProto))require('./_object-dp').f(FunctionProto, HAS_INSTANCE, {value: function(O){
  if(typeof this != 'function' || !isObject(O))return false;
  if(!isObject(this.prototype))return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while(O = getPrototypeOf(O))if(this.prototype === O)return true;
  return false;
}});
},{"./_is-object":103,"./_object-dp":121,"./_object-gpo":128,"./_wks":171}],202:[function(require,module,exports){
var dP         = require('./_object-dp').f
  , createDesc = require('./_property-desc')
  , has        = require('./_has')
  , FProto     = Function.prototype
  , nameRE     = /^\s*function ([^ (]*)/
  , NAME       = 'name';

var isExtensible = Object.isExtensible || function(){
  return true;
};

// 19.2.4.2 name
NAME in FProto || require('./_descriptors') && dP(FProto, NAME, {
  configurable: true,
  get: function(){
    try {
      var that = this
        , name = ('' + that).match(nameRE)[1];
      has(that, NAME) || !isExtensible(that) || dP(that, NAME, createDesc(5, name));
      return name;
    } catch(e){
      return '';
    }
  }
});
},{"./_descriptors":82,"./_has":93,"./_object-dp":121,"./_property-desc":139}],203:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');

// 23.1 Map Objects
module.exports = require('./_collection')('Map', function(get){
  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key){
    var entry = strong.getEntry(this, key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value){
    return strong.def(this, key === 0 ? 0 : key, value);
  }
}, strong, true);
},{"./_collection":76,"./_collection-strong":73}],204:[function(require,module,exports){
// 20.2.2.3 Math.acosh(x)
var $export = require('./_export')
  , log1p   = require('./_math-log1p')
  , sqrt    = Math.sqrt
  , $acosh  = Math.acosh;

$export($export.S + $export.F * !($acosh
  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  && Math.floor($acosh(Number.MAX_VALUE)) == 710
  // Tor Browser bug: Math.acosh(Infinity) -> NaN 
  && $acosh(Infinity) == Infinity
), 'Math', {
  acosh: function acosh(x){
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? Math.log(x) + Math.LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});
},{"./_export":86,"./_math-log1p":114}],205:[function(require,module,exports){
// 20.2.2.5 Math.asinh(x)
var $export = require('./_export')
  , $asinh  = Math.asinh;

function asinh(x){
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}

// Tor Browser bug: Math.asinh(0) -> -0 
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', {asinh: asinh});
},{"./_export":86}],206:[function(require,module,exports){
// 20.2.2.7 Math.atanh(x)
var $export = require('./_export')
  , $atanh  = Math.atanh;

// Tor Browser bug: Math.atanh(-0) -> 0 
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x){
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});
},{"./_export":86}],207:[function(require,module,exports){
// 20.2.2.9 Math.cbrt(x)
var $export = require('./_export')
  , sign    = require('./_math-sign');

$export($export.S, 'Math', {
  cbrt: function cbrt(x){
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});
},{"./_export":86,"./_math-sign":115}],208:[function(require,module,exports){
// 20.2.2.11 Math.clz32(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  clz32: function clz32(x){
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});
},{"./_export":86}],209:[function(require,module,exports){
// 20.2.2.12 Math.cosh(x)
var $export = require('./_export')
  , exp     = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x){
    return (exp(x = +x) + exp(-x)) / 2;
  }
});
},{"./_export":86}],210:[function(require,module,exports){
// 20.2.2.14 Math.expm1(x)
var $export = require('./_export')
  , $expm1  = require('./_math-expm1');

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', {expm1: $expm1});
},{"./_export":86,"./_math-expm1":113}],211:[function(require,module,exports){
// 20.2.2.16 Math.fround(x)
var $export   = require('./_export')
  , sign      = require('./_math-sign')
  , pow       = Math.pow
  , EPSILON   = pow(2, -52)
  , EPSILON32 = pow(2, -23)
  , MAX32     = pow(2, 127) * (2 - EPSILON32)
  , MIN32     = pow(2, -126);

var roundTiesToEven = function(n){
  return n + 1 / EPSILON - 1 / EPSILON;
};


$export($export.S, 'Math', {
  fround: function fround(x){
    var $abs  = Math.abs(x)
      , $sign = sign(x)
      , a, result;
    if($abs < MIN32)return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
    a = (1 + EPSILON32 / EPSILON) * $abs;
    result = a - (a - $abs);
    if(result > MAX32 || result != result)return $sign * Infinity;
    return $sign * result;
  }
});
},{"./_export":86,"./_math-sign":115}],212:[function(require,module,exports){
// 20.2.2.17 Math.hypot([value1[, value2[, â€¦ ]]])
var $export = require('./_export')
  , abs     = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2){ // eslint-disable-line no-unused-vars
    var sum  = 0
      , i    = 0
      , aLen = arguments.length
      , larg = 0
      , arg, div;
    while(i < aLen){
      arg = abs(arguments[i++]);
      if(larg < arg){
        div  = larg / arg;
        sum  = sum * div * div + 1;
        larg = arg;
      } else if(arg > 0){
        div  = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});
},{"./_export":86}],213:[function(require,module,exports){
// 20.2.2.18 Math.imul(x, y)
var $export = require('./_export')
  , $imul   = Math.imul;

// some WebKit versions fails with big numbers, some has wrong arity
$export($export.S + $export.F * require('./_fails')(function(){
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y){
    var UINT16 = 0xffff
      , xn = +x
      , yn = +y
      , xl = UINT16 & xn
      , yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});
},{"./_export":86,"./_fails":88}],214:[function(require,module,exports){
// 20.2.2.21 Math.log10(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log10: function log10(x){
    return Math.log(x) / Math.LN10;
  }
});
},{"./_export":86}],215:[function(require,module,exports){
// 20.2.2.20 Math.log1p(x)
var $export = require('./_export');

$export($export.S, 'Math', {log1p: require('./_math-log1p')});
},{"./_export":86,"./_math-log1p":114}],216:[function(require,module,exports){
// 20.2.2.22 Math.log2(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log2: function log2(x){
    return Math.log(x) / Math.LN2;
  }
});
},{"./_export":86}],217:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
var $export = require('./_export');

$export($export.S, 'Math', {sign: require('./_math-sign')});
},{"./_export":86,"./_math-sign":115}],218:[function(require,module,exports){
// 20.2.2.30 Math.sinh(x)
var $export = require('./_export')
  , expm1   = require('./_math-expm1')
  , exp     = Math.exp;

// V8 near Chromium 38 has a problem with very small numbers
$export($export.S + $export.F * require('./_fails')(function(){
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x){
    return Math.abs(x = +x) < 1
      ? (expm1(x) - expm1(-x)) / 2
      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});
},{"./_export":86,"./_fails":88,"./_math-expm1":113}],219:[function(require,module,exports){
// 20.2.2.33 Math.tanh(x)
var $export = require('./_export')
  , expm1   = require('./_math-expm1')
  , exp     = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x){
    var a = expm1(x = +x)
      , b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});
},{"./_export":86,"./_math-expm1":113}],220:[function(require,module,exports){
// 20.2.2.34 Math.trunc(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  trunc: function trunc(it){
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});
},{"./_export":86}],221:[function(require,module,exports){
'use strict';
var global            = require('./_global')
  , has               = require('./_has')
  , cof               = require('./_cof')
  , inheritIfRequired = require('./_inherit-if-required')
  , toPrimitive       = require('./_to-primitive')
  , fails             = require('./_fails')
  , gOPN              = require('./_object-gopn').f
  , gOPD              = require('./_object-gopd').f
  , dP                = require('./_object-dp').f
  , $trim             = require('./_string-trim').trim
  , NUMBER            = 'Number'
  , $Number           = global[NUMBER]
  , Base              = $Number
  , proto             = $Number.prototype
  // Opera ~12 has broken Object#toString
  , BROKEN_COF        = cof(require('./_object-create')(proto)) == NUMBER
  , TRIM              = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function(argument){
  var it = toPrimitive(argument, false);
  if(typeof it == 'string' && it.length > 2){
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0)
      , third, radix, maxCode;
    if(first === 43 || first === 45){
      third = it.charCodeAt(2);
      if(third === 88 || third === 120)return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if(first === 48){
      switch(it.charCodeAt(1)){
        case 66 : case 98  : radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79 : case 111 : radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default : return +it;
      }
      for(var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++){
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if(code < 48 || code > maxCode)return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if(!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')){
  $Number = function Number(value){
    var it = arguments.length < 1 ? 0 : value
      , that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function(){ proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for(var keys = require('./_descriptors') ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++){
    if(has(Base, key = keys[j]) && !has($Number, key)){
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  require('./_redefine')(global, NUMBER, $Number);
}
},{"./_cof":72,"./_descriptors":82,"./_fails":88,"./_global":92,"./_has":93,"./_inherit-if-required":97,"./_object-create":120,"./_object-dp":121,"./_object-gopd":124,"./_object-gopn":126,"./_redefine":141,"./_string-trim":156,"./_to-primitive":164}],222:[function(require,module,exports){
// 20.1.2.1 Number.EPSILON
var $export = require('./_export');

$export($export.S, 'Number', {EPSILON: Math.pow(2, -52)});
},{"./_export":86}],223:[function(require,module,exports){
// 20.1.2.2 Number.isFinite(number)
var $export   = require('./_export')
  , _isFinite = require('./_global').isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it){
    return typeof it == 'number' && _isFinite(it);
  }
});
},{"./_export":86,"./_global":92}],224:[function(require,module,exports){
// 20.1.2.3 Number.isInteger(number)
var $export = require('./_export');

$export($export.S, 'Number', {isInteger: require('./_is-integer')});
},{"./_export":86,"./_is-integer":102}],225:[function(require,module,exports){
// 20.1.2.4 Number.isNaN(number)
var $export = require('./_export');

$export($export.S, 'Number', {
  isNaN: function isNaN(number){
    return number != number;
  }
});
},{"./_export":86}],226:[function(require,module,exports){
// 20.1.2.5 Number.isSafeInteger(number)
var $export   = require('./_export')
  , isInteger = require('./_is-integer')
  , abs       = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number){
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});
},{"./_export":86,"./_is-integer":102}],227:[function(require,module,exports){
// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', {MAX_SAFE_INTEGER: 0x1fffffffffffff});
},{"./_export":86}],228:[function(require,module,exports){
// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', {MIN_SAFE_INTEGER: -0x1fffffffffffff});
},{"./_export":86}],229:[function(require,module,exports){
var $export     = require('./_export')
  , $parseFloat = require('./_parse-float');
// 20.1.2.12 Number.parseFloat(string)
$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', {parseFloat: $parseFloat});
},{"./_export":86,"./_parse-float":135}],230:[function(require,module,exports){
var $export   = require('./_export')
  , $parseInt = require('./_parse-int');
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', {parseInt: $parseInt});
},{"./_export":86,"./_parse-int":136}],231:[function(require,module,exports){
'use strict';
var $export      = require('./_export')
  , toInteger    = require('./_to-integer')
  , aNumberValue = require('./_a-number-value')
  , repeat       = require('./_string-repeat')
  , $toFixed     = 1..toFixed
  , floor        = Math.floor
  , data         = [0, 0, 0, 0, 0, 0]
  , ERROR        = 'Number.toFixed: incorrect invocation!'
  , ZERO         = '0';

var multiply = function(n, c){
  var i  = -1
    , c2 = c;
  while(++i < 6){
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};
var divide = function(n){
  var i = 6
    , c = 0;
  while(--i >= 0){
    c += data[i];
    data[i] = floor(c / n);
    c = (c % n) * 1e7;
  }
};
var numToString = function(){
  var i = 6
    , s = '';
  while(--i >= 0){
    if(s !== '' || i === 0 || data[i] !== 0){
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  } return s;
};
var pow = function(x, n, acc){
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function(x){
  var n  = 0
    , x2 = x;
  while(x2 >= 4096){
    n += 12;
    x2 /= 4096;
  }
  while(x2 >= 2){
    n  += 1;
    x2 /= 2;
  } return n;
};

$export($export.P + $export.F * (!!$toFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128..toFixed(0) !== '1000000000000000128'
) || !require('./_fails')(function(){
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits){
    var x = aNumberValue(this, ERROR)
      , f = toInteger(fractionDigits)
      , s = ''
      , m = ZERO
      , e, z, j, k;
    if(f < 0 || f > 20)throw RangeError(ERROR);
    if(x != x)return 'NaN';
    if(x <= -1e21 || x >= 1e21)return String(x);
    if(x < 0){
      s = '-';
      x = -x;
    }
    if(x > 1e-21){
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if(e > 0){
        multiply(0, z);
        j = f;
        while(j >= 7){
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while(j >= 23){
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }
    if(f > 0){
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    } return m;
  }
});
},{"./_a-number-value":58,"./_export":86,"./_fails":88,"./_string-repeat":155,"./_to-integer":160}],232:[function(require,module,exports){
'use strict';
var $export      = require('./_export')
  , $fails       = require('./_fails')
  , aNumberValue = require('./_a-number-value')
  , $toPrecision = 1..toPrecision;

$export($export.P + $export.F * ($fails(function(){
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function(){
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision){
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision); 
  }
});
},{"./_a-number-value":58,"./_export":86,"./_fails":88}],233:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = require('./_export');

$export($export.S + $export.F, 'Object', {assign: require('./_object-assign')});
},{"./_export":86,"./_object-assign":119}],234:[function(require,module,exports){
var $export = require('./_export')
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', {create: require('./_object-create')});
},{"./_export":86,"./_object-create":120}],235:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', {defineProperties: require('./_object-dps')});
},{"./_descriptors":82,"./_export":86,"./_object-dps":122}],236:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', {defineProperty: require('./_object-dp').f});
},{"./_descriptors":82,"./_export":86,"./_object-dp":121}],237:[function(require,module,exports){
// 19.1.2.5 Object.freeze(O)
var isObject = require('./_is-object')
  , meta     = require('./_meta').onFreeze;

require('./_object-sap')('freeze', function($freeze){
  return function freeze(it){
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});
},{"./_is-object":103,"./_meta":116,"./_object-sap":132}],238:[function(require,module,exports){
// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject                 = require('./_to-iobject')
  , $getOwnPropertyDescriptor = require('./_object-gopd').f;

require('./_object-sap')('getOwnPropertyDescriptor', function(){
  return function getOwnPropertyDescriptor(it, key){
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});
},{"./_object-gopd":124,"./_object-sap":132,"./_to-iobject":161}],239:[function(require,module,exports){
// 19.1.2.7 Object.getOwnPropertyNames(O)
require('./_object-sap')('getOwnPropertyNames', function(){
  return require('./_object-gopn-ext').f;
});
},{"./_object-gopn-ext":125,"./_object-sap":132}],240:[function(require,module,exports){
// 19.1.2.9 Object.getPrototypeOf(O)
var toObject        = require('./_to-object')
  , $getPrototypeOf = require('./_object-gpo');

require('./_object-sap')('getPrototypeOf', function(){
  return function getPrototypeOf(it){
    return $getPrototypeOf(toObject(it));
  };
});
},{"./_object-gpo":128,"./_object-sap":132,"./_to-object":163}],241:[function(require,module,exports){
// 19.1.2.11 Object.isExtensible(O)
var isObject = require('./_is-object');

require('./_object-sap')('isExtensible', function($isExtensible){
  return function isExtensible(it){
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});
},{"./_is-object":103,"./_object-sap":132}],242:[function(require,module,exports){
// 19.1.2.12 Object.isFrozen(O)
var isObject = require('./_is-object');

require('./_object-sap')('isFrozen', function($isFrozen){
  return function isFrozen(it){
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});
},{"./_is-object":103,"./_object-sap":132}],243:[function(require,module,exports){
// 19.1.2.13 Object.isSealed(O)
var isObject = require('./_is-object');

require('./_object-sap')('isSealed', function($isSealed){
  return function isSealed(it){
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});
},{"./_is-object":103,"./_object-sap":132}],244:[function(require,module,exports){
// 19.1.3.10 Object.is(value1, value2)
var $export = require('./_export');
$export($export.S, 'Object', {is: require('./_same-value')});
},{"./_export":86,"./_same-value":143}],245:[function(require,module,exports){
// 19.1.2.14 Object.keys(O)
var toObject = require('./_to-object')
  , $keys    = require('./_object-keys');

require('./_object-sap')('keys', function(){
  return function keys(it){
    return $keys(toObject(it));
  };
});
},{"./_object-keys":130,"./_object-sap":132,"./_to-object":163}],246:[function(require,module,exports){
// 19.1.2.15 Object.preventExtensions(O)
var isObject = require('./_is-object')
  , meta     = require('./_meta').onFreeze;

require('./_object-sap')('preventExtensions', function($preventExtensions){
  return function preventExtensions(it){
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});
},{"./_is-object":103,"./_meta":116,"./_object-sap":132}],247:[function(require,module,exports){
// 19.1.2.17 Object.seal(O)
var isObject = require('./_is-object')
  , meta     = require('./_meta').onFreeze;

require('./_object-sap')('seal', function($seal){
  return function seal(it){
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});
},{"./_is-object":103,"./_meta":116,"./_object-sap":132}],248:[function(require,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = require('./_export');
$export($export.S, 'Object', {setPrototypeOf: require('./_set-proto').set});
},{"./_export":86,"./_set-proto":144}],249:[function(require,module,exports){
'use strict';
// 19.1.3.6 Object.prototype.toString()
var classof = require('./_classof')
  , test    = {};
test[require('./_wks')('toStringTag')] = 'z';
if(test + '' != '[object z]'){
  require('./_redefine')(Object.prototype, 'toString', function toString(){
    return '[object ' + classof(this) + ']';
  }, true);
}
},{"./_classof":71,"./_redefine":141,"./_wks":171}],250:[function(require,module,exports){
var $export     = require('./_export')
  , $parseFloat = require('./_parse-float');
// 18.2.4 parseFloat(string)
$export($export.G + $export.F * (parseFloat != $parseFloat), {parseFloat: $parseFloat});
},{"./_export":86,"./_parse-float":135}],251:[function(require,module,exports){
var $export   = require('./_export')
  , $parseInt = require('./_parse-int');
// 18.2.5 parseInt(string, radix)
$export($export.G + $export.F * (parseInt != $parseInt), {parseInt: $parseInt});
},{"./_export":86,"./_parse-int":136}],252:[function(require,module,exports){
'use strict';
var LIBRARY            = require('./_library')
  , global             = require('./_global')
  , ctx                = require('./_ctx')
  , classof            = require('./_classof')
  , $export            = require('./_export')
  , isObject           = require('./_is-object')
  , aFunction          = require('./_a-function')
  , anInstance         = require('./_an-instance')
  , forOf              = require('./_for-of')
  , speciesConstructor = require('./_species-constructor')
  , task               = require('./_task').set
  , microtask          = require('./_microtask')()
  , PROMISE            = 'Promise'
  , TypeError          = global.TypeError
  , process            = global.process
  , $Promise           = global[PROMISE]
  , process            = global.process
  , isNode             = classof(process) == 'process'
  , empty              = function(){ /* empty */ }
  , Internal, GenericPromiseCapability, Wrapper;

var USE_NATIVE = !!function(){
  try {
    // correct subclassing with @@species support
    var promise     = $Promise.resolve(1)
      , FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function(exec){ exec(empty, empty); };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
  } catch(e){ /* empty */ }
}();

// helpers
var sameConstructor = function(a, b){
  // with library wrapper special case
  return a === b || a === $Promise && b === Wrapper;
};
var isThenable = function(it){
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var newPromiseCapability = function(C){
  return sameConstructor($Promise, C)
    ? new PromiseCapability(C)
    : new GenericPromiseCapability(C);
};
var PromiseCapability = GenericPromiseCapability = function(C){
  var resolve, reject;
  this.promise = new C(function($$resolve, $$reject){
    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject  = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject  = aFunction(reject);
};
var perform = function(exec){
  try {
    exec();
  } catch(e){
    return {error: e};
  }
};
var notify = function(promise, isReject){
  if(promise._n)return;
  promise._n = true;
  var chain = promise._c;
  microtask(function(){
    var value = promise._v
      , ok    = promise._s == 1
      , i     = 0;
    var run = function(reaction){
      var handler = ok ? reaction.ok : reaction.fail
        , resolve = reaction.resolve
        , reject  = reaction.reject
        , domain  = reaction.domain
        , result, then;
      try {
        if(handler){
          if(!ok){
            if(promise._h == 2)onHandleUnhandled(promise);
            promise._h = 1;
          }
          if(handler === true)result = value;
          else {
            if(domain)domain.enter();
            result = handler(value);
            if(domain)domain.exit();
          }
          if(result === reaction.promise){
            reject(TypeError('Promise-chain cycle'));
          } else if(then = isThenable(result)){
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch(e){
        reject(e);
      }
    };
    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if(isReject && !promise._h)onUnhandled(promise);
  });
};
var onUnhandled = function(promise){
  task.call(global, function(){
    var value = promise._v
      , abrupt, handler, console;
    if(isUnhandled(promise)){
      abrupt = perform(function(){
        if(isNode){
          process.emit('unhandledRejection', value, promise);
        } else if(handler = global.onunhandledrejection){
          handler({promise: promise, reason: value});
        } else if((console = global.console) && console.error){
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if(abrupt)throw abrupt.error;
  });
};
var isUnhandled = function(promise){
  if(promise._h == 1)return false;
  var chain = promise._a || promise._c
    , i     = 0
    , reaction;
  while(chain.length > i){
    reaction = chain[i++];
    if(reaction.fail || !isUnhandled(reaction.promise))return false;
  } return true;
};
var onHandleUnhandled = function(promise){
  task.call(global, function(){
    var handler;
    if(isNode){
      process.emit('rejectionHandled', promise);
    } else if(handler = global.onrejectionhandled){
      handler({promise: promise, reason: promise._v});
    }
  });
};
var $reject = function(value){
  var promise = this;
  if(promise._d)return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if(!promise._a)promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function(value){
  var promise = this
    , then;
  if(promise._d)return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if(promise === value)throw TypeError("Promise can't be resolved itself");
    if(then = isThenable(value)){
      microtask(function(){
        var wrapper = {_w: promise, _d: false}; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch(e){
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch(e){
    $reject.call({_w: promise, _d: false}, e); // wrap
  }
};

// constructor polyfill
if(!USE_NATIVE){
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor){
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch(err){
      $reject.call(this, err);
    }
  };
  Internal = function Promise(executor){
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = require('./_redefine-all')($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected){
      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail   = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if(this._a)this._a.push(reaction);
      if(this._s)notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function(onRejected){
      return this.then(undefined, onRejected);
    }
  });
  PromiseCapability = function(){
    var promise  = new Internal;
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject  = ctx($reject, promise, 1);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});
require('./_set-to-string-tag')($Promise, PROMISE);
require('./_set-species')(PROMISE);
Wrapper = require('./_core')[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r){
    var capability = newPromiseCapability(this)
      , $$reject   = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x){
    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;
    var capability = newPromiseCapability(this)
      , $$resolve  = capability.resolve;
    $$resolve(x);
    return capability.promise;
  }
});
$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function(iter){
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable){
    var C          = this
      , capability = newPromiseCapability(C)
      , resolve    = capability.resolve
      , reject     = capability.reject;
    var abrupt = perform(function(){
      var values    = []
        , index     = 0
        , remaining = 1;
      forOf(iterable, false, function(promise){
        var $index        = index++
          , alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function(value){
          if(alreadyCalled)return;
          alreadyCalled  = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if(abrupt)reject(abrupt.error);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable){
    var C          = this
      , capability = newPromiseCapability(C)
      , reject     = capability.reject;
    var abrupt = perform(function(){
      forOf(iterable, false, function(promise){
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if(abrupt)reject(abrupt.error);
    return capability.promise;
  }
});
},{"./_a-function":57,"./_an-instance":60,"./_classof":71,"./_core":77,"./_ctx":79,"./_export":86,"./_for-of":91,"./_global":92,"./_is-object":103,"./_iter-detect":108,"./_library":112,"./_microtask":118,"./_redefine-all":140,"./_set-species":145,"./_set-to-string-tag":146,"./_species-constructor":149,"./_task":158,"./_wks":171}],253:[function(require,module,exports){
// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export   = require('./_export')
  , aFunction = require('./_a-function')
  , anObject  = require('./_an-object')
  , rApply    = (require('./_global').Reflect || {}).apply
  , fApply    = Function.apply;
// MS Edge argumentsList argument is optional
$export($export.S + $export.F * !require('./_fails')(function(){
  rApply(function(){});
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList){
    var T = aFunction(target)
      , L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});
},{"./_a-function":57,"./_an-object":61,"./_export":86,"./_fails":88,"./_global":92}],254:[function(require,module,exports){
// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export    = require('./_export')
  , create     = require('./_object-create')
  , aFunction  = require('./_a-function')
  , anObject   = require('./_an-object')
  , isObject   = require('./_is-object')
  , fails      = require('./_fails')
  , bind       = require('./_bind')
  , rConstruct = (require('./_global').Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function(){
  function F(){}
  return !(rConstruct(function(){}, [], F) instanceof F);
});
var ARGS_BUG = !fails(function(){
  rConstruct(function(){});
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /*, newTarget*/){
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if(ARGS_BUG && !NEW_TARGET_BUG)return rConstruct(Target, args, newTarget);
    if(Target == newTarget){
      // w/o altered newTarget, optimization for 0-4 arguments
      switch(args.length){
        case 0: return new Target;
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args));
    }
    // with altered newTarget, not support built-in constructors
    var proto    = newTarget.prototype
      , instance = create(isObject(proto) ? proto : Object.prototype)
      , result   = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});
},{"./_a-function":57,"./_an-object":61,"./_bind":70,"./_export":86,"./_fails":88,"./_global":92,"./_is-object":103,"./_object-create":120}],255:[function(require,module,exports){
// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP          = require('./_object-dp')
  , $export     = require('./_export')
  , anObject    = require('./_an-object')
  , toPrimitive = require('./_to-primitive');

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$export($export.S + $export.F * require('./_fails')(function(){
  Reflect.defineProperty(dP.f({}, 1, {value: 1}), 1, {value: 2});
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes){
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch(e){
      return false;
    }
  }
});
},{"./_an-object":61,"./_export":86,"./_fails":88,"./_object-dp":121,"./_to-primitive":164}],256:[function(require,module,exports){
// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export  = require('./_export')
  , gOPD     = require('./_object-gopd').f
  , anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey){
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});
},{"./_an-object":61,"./_export":86,"./_object-gopd":124}],257:[function(require,module,exports){
'use strict';
// 26.1.5 Reflect.enumerate(target)
var $export  = require('./_export')
  , anObject = require('./_an-object');
var Enumerate = function(iterated){
  this._t = anObject(iterated); // target
  this._i = 0;                  // next index
  var keys = this._k = []       // keys
    , key;
  for(key in iterated)keys.push(key);
};
require('./_iter-create')(Enumerate, 'Object', function(){
  var that = this
    , keys = that._k
    , key;
  do {
    if(that._i >= keys.length)return {value: undefined, done: true};
  } while(!((key = keys[that._i++]) in that._t));
  return {value: key, done: false};
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target){
    return new Enumerate(target);
  }
});
},{"./_an-object":61,"./_export":86,"./_iter-create":106}],258:[function(require,module,exports){
// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD     = require('./_object-gopd')
  , $export  = require('./_export')
  , anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey){
    return gOPD.f(anObject(target), propertyKey);
  }
});
},{"./_an-object":61,"./_export":86,"./_object-gopd":124}],259:[function(require,module,exports){
// 26.1.8 Reflect.getPrototypeOf(target)
var $export  = require('./_export')
  , getProto = require('./_object-gpo')
  , anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target){
    return getProto(anObject(target));
  }
});
},{"./_an-object":61,"./_export":86,"./_object-gpo":128}],260:[function(require,module,exports){
// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD           = require('./_object-gopd')
  , getPrototypeOf = require('./_object-gpo')
  , has            = require('./_has')
  , $export        = require('./_export')
  , isObject       = require('./_is-object')
  , anObject       = require('./_an-object');

function get(target, propertyKey/*, receiver*/){
  var receiver = arguments.length < 3 ? target : arguments[2]
    , desc, proto;
  if(anObject(target) === receiver)return target[propertyKey];
  if(desc = gOPD.f(target, propertyKey))return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined;
  if(isObject(proto = getPrototypeOf(target)))return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', {get: get});
},{"./_an-object":61,"./_export":86,"./_has":93,"./_is-object":103,"./_object-gopd":124,"./_object-gpo":128}],261:[function(require,module,exports){
// 26.1.9 Reflect.has(target, propertyKey)
var $export = require('./_export');

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey){
    return propertyKey in target;
  }
});
},{"./_export":86}],262:[function(require,module,exports){
// 26.1.10 Reflect.isExtensible(target)
var $export       = require('./_export')
  , anObject      = require('./_an-object')
  , $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target){
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});
},{"./_an-object":61,"./_export":86}],263:[function(require,module,exports){
// 26.1.11 Reflect.ownKeys(target)
var $export = require('./_export');

$export($export.S, 'Reflect', {ownKeys: require('./_own-keys')});
},{"./_export":86,"./_own-keys":134}],264:[function(require,module,exports){
// 26.1.12 Reflect.preventExtensions(target)
var $export            = require('./_export')
  , anObject           = require('./_an-object')
  , $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target){
    anObject(target);
    try {
      if($preventExtensions)$preventExtensions(target);
      return true;
    } catch(e){
      return false;
    }
  }
});
},{"./_an-object":61,"./_export":86}],265:[function(require,module,exports){
// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export  = require('./_export')
  , setProto = require('./_set-proto');

if(setProto)$export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto){
    setProto.check(target, proto);
    try {
      setProto.set(target, proto);
      return true;
    } catch(e){
      return false;
    }
  }
});
},{"./_export":86,"./_set-proto":144}],266:[function(require,module,exports){
// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP             = require('./_object-dp')
  , gOPD           = require('./_object-gopd')
  , getPrototypeOf = require('./_object-gpo')
  , has            = require('./_has')
  , $export        = require('./_export')
  , createDesc     = require('./_property-desc')
  , anObject       = require('./_an-object')
  , isObject       = require('./_is-object');

function set(target, propertyKey, V/*, receiver*/){
  var receiver = arguments.length < 4 ? target : arguments[3]
    , ownDesc  = gOPD.f(anObject(target), propertyKey)
    , existingDescriptor, proto;
  if(!ownDesc){
    if(isObject(proto = getPrototypeOf(target))){
      return set(proto, propertyKey, V, receiver);
    }
    ownDesc = createDesc(0);
  }
  if(has(ownDesc, 'value')){
    if(ownDesc.writable === false || !isObject(receiver))return false;
    existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);
    existingDescriptor.value = V;
    dP.f(receiver, propertyKey, existingDescriptor);
    return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', {set: set});
},{"./_an-object":61,"./_export":86,"./_has":93,"./_is-object":103,"./_object-dp":121,"./_object-gopd":124,"./_object-gpo":128,"./_property-desc":139}],267:[function(require,module,exports){
var global            = require('./_global')
  , inheritIfRequired = require('./_inherit-if-required')
  , dP                = require('./_object-dp').f
  , gOPN              = require('./_object-gopn').f
  , isRegExp          = require('./_is-regexp')
  , $flags            = require('./_flags')
  , $RegExp           = global.RegExp
  , Base              = $RegExp
  , proto             = $RegExp.prototype
  , re1               = /a/g
  , re2               = /a/g
  // "new" creates a new object, old webkit buggy here
  , CORRECT_NEW       = new $RegExp(re1) !== re1;

if(require('./_descriptors') && (!CORRECT_NEW || require('./_fails')(function(){
  re2[require('./_wks')('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))){
  $RegExp = function RegExp(p, f){
    var tiRE = this instanceof $RegExp
      , piRE = isRegExp(p)
      , fiU  = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function(key){
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function(){ return Base[key]; },
      set: function(it){ Base[key] = it; }
    });
  };
  for(var keys = gOPN(Base), i = 0; keys.length > i; )proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  require('./_redefine')(global, 'RegExp', $RegExp);
}

require('./_set-species')('RegExp');
},{"./_descriptors":82,"./_fails":88,"./_flags":90,"./_global":92,"./_inherit-if-required":97,"./_is-regexp":104,"./_object-dp":121,"./_object-gopn":126,"./_redefine":141,"./_set-species":145,"./_wks":171}],268:[function(require,module,exports){
// 21.2.5.3 get RegExp.prototype.flags()
if(require('./_descriptors') && /./g.flags != 'g')require('./_object-dp').f(RegExp.prototype, 'flags', {
  configurable: true,
  get: require('./_flags')
});
},{"./_descriptors":82,"./_flags":90,"./_object-dp":121}],269:[function(require,module,exports){
// @@match logic
require('./_fix-re-wks')('match', 1, function(defined, MATCH, $match){
  // 21.1.3.11 String.prototype.match(regexp)
  return [function match(regexp){
    'use strict';
    var O  = defined(this)
      , fn = regexp == undefined ? undefined : regexp[MATCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, $match];
});
},{"./_fix-re-wks":89}],270:[function(require,module,exports){
// @@replace logic
require('./_fix-re-wks')('replace', 2, function(defined, REPLACE, $replace){
  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
  return [function replace(searchValue, replaceValue){
    'use strict';
    var O  = defined(this)
      , fn = searchValue == undefined ? undefined : searchValue[REPLACE];
    return fn !== undefined
      ? fn.call(searchValue, O, replaceValue)
      : $replace.call(String(O), searchValue, replaceValue);
  }, $replace];
});
},{"./_fix-re-wks":89}],271:[function(require,module,exports){
// @@search logic
require('./_fix-re-wks')('search', 1, function(defined, SEARCH, $search){
  // 21.1.3.15 String.prototype.search(regexp)
  return [function search(regexp){
    'use strict';
    var O  = defined(this)
      , fn = regexp == undefined ? undefined : regexp[SEARCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, $search];
});
},{"./_fix-re-wks":89}],272:[function(require,module,exports){
// @@split logic
require('./_fix-re-wks')('split', 2, function(defined, SPLIT, $split){
  'use strict';
  var isRegExp   = require('./_is-regexp')
    , _split     = $split
    , $push      = [].push
    , $SPLIT     = 'split'
    , LENGTH     = 'length'
    , LAST_INDEX = 'lastIndex';
  if(
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ){
    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
    // based on es5-shim implementation, need to rework it
    $split = function(separator, limit){
      var string = String(this);
      if(separator === undefined && limit === 0)return [];
      // If `separator` is not a regex, use native split
      if(!isRegExp(separator))return _split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var separator2, match, lastIndex, lastLength, i;
      // Doesn't need flags gy, but they don't hurt
      if(!NPCG)separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
      while(match = separatorCopy.exec(string)){
        // `separatorCopy.lastIndex` is not reliable cross-browser
        lastIndex = match.index + match[0][LENGTH];
        if(lastIndex > lastLastIndex){
          output.push(string.slice(lastLastIndex, match.index));
          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
          if(!NPCG && match[LENGTH] > 1)match[0].replace(separator2, function(){
            for(i = 1; i < arguments[LENGTH] - 2; i++)if(arguments[i] === undefined)match[i] = undefined;
          });
          if(match[LENGTH] > 1 && match.index < string[LENGTH])$push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if(output[LENGTH] >= splitLimit)break;
        }
        if(separatorCopy[LAST_INDEX] === match.index)separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if(lastLastIndex === string[LENGTH]){
        if(lastLength || !separatorCopy.test(''))output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if('0'[$SPLIT](undefined, 0)[LENGTH]){
    $split = function(separator, limit){
      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
    };
  }
  // 21.1.3.17 String.prototype.split(separator, limit)
  return [function split(separator, limit){
    var O  = defined(this)
      , fn = separator == undefined ? undefined : separator[SPLIT];
    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
  }, $split];
});
},{"./_fix-re-wks":89,"./_is-regexp":104}],273:[function(require,module,exports){
'use strict';
require('./es6.regexp.flags');
var anObject    = require('./_an-object')
  , $flags      = require('./_flags')
  , DESCRIPTORS = require('./_descriptors')
  , TO_STRING   = 'toString'
  , $toString   = /./[TO_STRING];

var define = function(fn){
  require('./_redefine')(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if(require('./_fails')(function(){ return $toString.call({source: 'a', flags: 'b'}) != '/a/b'; })){
  define(function toString(){
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if($toString.name != TO_STRING){
  define(function toString(){
    return $toString.call(this);
  });
}
},{"./_an-object":61,"./_descriptors":82,"./_fails":88,"./_flags":90,"./_redefine":141,"./es6.regexp.flags":268}],274:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');

// 23.2 Set Objects
module.exports = require('./_collection')('Set', function(get){
  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value){
    return strong.def(this, value = value === 0 ? 0 : value, value);
  }
}, strong);
},{"./_collection":76,"./_collection-strong":73}],275:[function(require,module,exports){
'use strict';
// B.2.3.2 String.prototype.anchor(name)
require('./_string-html')('anchor', function(createHTML){
  return function anchor(name){
    return createHTML(this, 'a', 'name', name);
  }
});
},{"./_string-html":153}],276:[function(require,module,exports){
'use strict';
// B.2.3.3 String.prototype.big()
require('./_string-html')('big', function(createHTML){
  return function big(){
    return createHTML(this, 'big', '', '');
  }
});
},{"./_string-html":153}],277:[function(require,module,exports){
'use strict';
// B.2.3.4 String.prototype.blink()
require('./_string-html')('blink', function(createHTML){
  return function blink(){
    return createHTML(this, 'blink', '', '');
  }
});
},{"./_string-html":153}],278:[function(require,module,exports){
'use strict';
// B.2.3.5 String.prototype.bold()
require('./_string-html')('bold', function(createHTML){
  return function bold(){
    return createHTML(this, 'b', '', '');
  }
});
},{"./_string-html":153}],279:[function(require,module,exports){
'use strict';
var $export = require('./_export')
  , $at     = require('./_string-at')(false);
$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos){
    return $at(this, pos);
  }
});
},{"./_export":86,"./_string-at":151}],280:[function(require,module,exports){
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
'use strict';
var $export   = require('./_export')
  , toLength  = require('./_to-length')
  , context   = require('./_string-context')
  , ENDS_WITH = 'endsWith'
  , $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /*, endPosition = @length */){
    var that = context(this, searchString, ENDS_WITH)
      , endPosition = arguments.length > 1 ? arguments[1] : undefined
      , len    = toLength(that.length)
      , end    = endPosition === undefined ? len : Math.min(toLength(endPosition), len)
      , search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});
},{"./_export":86,"./_fails-is-regexp":87,"./_string-context":152,"./_to-length":162}],281:[function(require,module,exports){
'use strict';
// B.2.3.6 String.prototype.fixed()
require('./_string-html')('fixed', function(createHTML){
  return function fixed(){
    return createHTML(this, 'tt', '', '');
  }
});
},{"./_string-html":153}],282:[function(require,module,exports){
'use strict';
// B.2.3.7 String.prototype.fontcolor(color)
require('./_string-html')('fontcolor', function(createHTML){
  return function fontcolor(color){
    return createHTML(this, 'font', 'color', color);
  }
});
},{"./_string-html":153}],283:[function(require,module,exports){
'use strict';
// B.2.3.8 String.prototype.fontsize(size)
require('./_string-html')('fontsize', function(createHTML){
  return function fontsize(size){
    return createHTML(this, 'font', 'size', size);
  }
});
},{"./_string-html":153}],284:[function(require,module,exports){
var $export        = require('./_export')
  , toIndex        = require('./_to-index')
  , fromCharCode   = String.fromCharCode
  , $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x){ // eslint-disable-line no-unused-vars
    var res  = []
      , aLen = arguments.length
      , i    = 0
      , code;
    while(aLen > i){
      code = +arguments[i++];
      if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});
},{"./_export":86,"./_to-index":159}],285:[function(require,module,exports){
// 21.1.3.7 String.prototype.includes(searchString, position = 0)
'use strict';
var $export  = require('./_export')
  , context  = require('./_string-context')
  , INCLUDES = 'includes';

$export($export.P + $export.F * require('./_fails-is-regexp')(INCLUDES), 'String', {
  includes: function includes(searchString /*, position = 0 */){
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});
},{"./_export":86,"./_fails-is-regexp":87,"./_string-context":152}],286:[function(require,module,exports){
'use strict';
// B.2.3.9 String.prototype.italics()
require('./_string-html')('italics', function(createHTML){
  return function italics(){
    return createHTML(this, 'i', '', '');
  }
});
},{"./_string-html":153}],287:[function(require,module,exports){
'use strict';
var $at  = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function(iterated){
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function(){
  var O     = this._t
    , index = this._i
    , point;
  if(index >= O.length)return {value: undefined, done: true};
  point = $at(O, index);
  this._i += point.length;
  return {value: point, done: false};
});
},{"./_iter-define":107,"./_string-at":151}],288:[function(require,module,exports){
'use strict';
// B.2.3.10 String.prototype.link(url)
require('./_string-html')('link', function(createHTML){
  return function link(url){
    return createHTML(this, 'a', 'href', url);
  }
});
},{"./_string-html":153}],289:[function(require,module,exports){
var $export   = require('./_export')
  , toIObject = require('./_to-iobject')
  , toLength  = require('./_to-length');

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite){
    var tpl  = toIObject(callSite.raw)
      , len  = toLength(tpl.length)
      , aLen = arguments.length
      , res  = []
      , i    = 0;
    while(len > i){
      res.push(String(tpl[i++]));
      if(i < aLen)res.push(String(arguments[i]));
    } return res.join('');
  }
});
},{"./_export":86,"./_to-iobject":161,"./_to-length":162}],290:[function(require,module,exports){
var $export = require('./_export');

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: require('./_string-repeat')
});
},{"./_export":86,"./_string-repeat":155}],291:[function(require,module,exports){
'use strict';
// B.2.3.11 String.prototype.small()
require('./_string-html')('small', function(createHTML){
  return function small(){
    return createHTML(this, 'small', '', '');
  }
});
},{"./_string-html":153}],292:[function(require,module,exports){
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
'use strict';
var $export     = require('./_export')
  , toLength    = require('./_to-length')
  , context     = require('./_string-context')
  , STARTS_WITH = 'startsWith'
  , $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /*, position = 0 */){
    var that   = context(this, searchString, STARTS_WITH)
      , index  = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length))
      , search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});
},{"./_export":86,"./_fails-is-regexp":87,"./_string-context":152,"./_to-length":162}],293:[function(require,module,exports){
'use strict';
// B.2.3.12 String.prototype.strike()
require('./_string-html')('strike', function(createHTML){
  return function strike(){
    return createHTML(this, 'strike', '', '');
  }
});
},{"./_string-html":153}],294:[function(require,module,exports){
'use strict';
// B.2.3.13 String.prototype.sub()
require('./_string-html')('sub', function(createHTML){
  return function sub(){
    return createHTML(this, 'sub', '', '');
  }
});
},{"./_string-html":153}],295:[function(require,module,exports){
'use strict';
// B.2.3.14 String.prototype.sup()
require('./_string-html')('sup', function(createHTML){
  return function sup(){
    return createHTML(this, 'sup', '', '');
  }
});
},{"./_string-html":153}],296:[function(require,module,exports){
'use strict';
// 21.1.3.25 String.prototype.trim()
require('./_string-trim')('trim', function($trim){
  return function trim(){
    return $trim(this, 3);
  };
});
},{"./_string-trim":156}],297:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var global         = require('./_global')
  , has            = require('./_has')
  , DESCRIPTORS    = require('./_descriptors')
  , $export        = require('./_export')
  , redefine       = require('./_redefine')
  , META           = require('./_meta').KEY
  , $fails         = require('./_fails')
  , shared         = require('./_shared')
  , setToStringTag = require('./_set-to-string-tag')
  , uid            = require('./_uid')
  , wks            = require('./_wks')
  , wksExt         = require('./_wks-ext')
  , wksDefine      = require('./_wks-define')
  , keyOf          = require('./_keyof')
  , enumKeys       = require('./_enum-keys')
  , isArray        = require('./_is-array')
  , anObject       = require('./_an-object')
  , toIObject      = require('./_to-iobject')
  , toPrimitive    = require('./_to-primitive')
  , createDesc     = require('./_property-desc')
  , _create        = require('./_object-create')
  , gOPNExt        = require('./_object-gopn-ext')
  , $GOPD          = require('./_object-gopd')
  , $DP            = require('./_object-dp')
  , $keys          = require('./_object-keys')
  , gOPD           = $GOPD.f
  , dP             = $DP.f
  , gOPN           = gOPNExt.f
  , $Symbol        = global.Symbol
  , $JSON          = global.JSON
  , _stringify     = $JSON && $JSON.stringify
  , PROTOTYPE      = 'prototype'
  , HIDDEN         = wks('_hidden')
  , TO_PRIMITIVE   = wks('toPrimitive')
  , isEnum         = {}.propertyIsEnumerable
  , SymbolRegistry = shared('symbol-registry')
  , AllSymbols     = shared('symbols')
  , OPSymbols      = shared('op-symbols')
  , ObjectProto    = Object[PROTOTYPE]
  , USE_NATIVE     = typeof $Symbol == 'function'
  , QObject        = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function(){
  return _create(dP({}, 'a', {
    get: function(){ return dP(this, 'a', {value: 7}).a; }
  })).a != 7;
}) ? function(it, key, D){
  var protoDesc = gOPD(ObjectProto, key);
  if(protoDesc)delete ObjectProto[key];
  dP(it, key, D);
  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function(tag){
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
  return typeof it == 'symbol';
} : function(it){
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D){
  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if(has(AllSymbols, key)){
    if(!D.enumerable){
      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
      D = _create(D, {enumerable: createDesc(0, false)});
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P){
  anObject(it);
  var keys = enumKeys(P = toIObject(P))
    , i    = 0
    , l = keys.length
    , key;
  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P){
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key){
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
  it  = toIObject(it);
  key = toPrimitive(key, true);
  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
  var D = gOPD(it, key);
  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it){
  var names  = gOPN(toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
  var IS_OP  = it === ObjectProto
    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
    , result = []
    , i      = 0
    , key;
  while(names.length > i){
    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if(!USE_NATIVE){
  $Symbol = function Symbol(){
    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function(value){
      if(this === ObjectProto)$set.call(OPSymbols, value);
      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f   = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f  = $propertyIsEnumerable;
  require('./_object-gops').f = $getOwnPropertySymbols;

  if(DESCRIPTORS && !require('./_library')){
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function(name){
    return wrap(wks(name));
  }
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});

for(var symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);

for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function(key){
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(key){
    if(isSymbol(key))return keyOf(SymbolRegistry, key);
    throw TypeError(key + ' is not a symbol!');
  },
  useSetter: function(){ setter = true; },
  useSimple: function(){ setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it){
    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
    var args = [it]
      , i    = 1
      , replacer, $replacer;
    while(arguments.length > i)args.push(arguments[i++]);
    replacer = args[1];
    if(typeof replacer == 'function')$replacer = replacer;
    if($replacer || !isArray(replacer))replacer = function(key, value){
      if($replacer)value = $replacer.call(this, key, value);
      if(!isSymbol(value))return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);
},{"./_an-object":61,"./_descriptors":82,"./_enum-keys":85,"./_export":86,"./_fails":88,"./_global":92,"./_has":93,"./_hide":94,"./_is-array":101,"./_keyof":111,"./_library":112,"./_meta":116,"./_object-create":120,"./_object-dp":121,"./_object-gopd":124,"./_object-gopn":126,"./_object-gopn-ext":125,"./_object-gops":127,"./_object-keys":130,"./_object-pie":131,"./_property-desc":139,"./_redefine":141,"./_set-to-string-tag":146,"./_shared":148,"./_to-iobject":161,"./_to-primitive":164,"./_uid":168,"./_wks":171,"./_wks-define":169,"./_wks-ext":170}],298:[function(require,module,exports){
'use strict';
var $export      = require('./_export')
  , $typed       = require('./_typed')
  , buffer       = require('./_typed-buffer')
  , anObject     = require('./_an-object')
  , toIndex      = require('./_to-index')
  , toLength     = require('./_to-length')
  , isObject     = require('./_is-object')
  , ArrayBuffer  = require('./_global').ArrayBuffer
  , speciesConstructor = require('./_species-constructor')
  , $ArrayBuffer = buffer.ArrayBuffer
  , $DataView    = buffer.DataView
  , $isView      = $typed.ABV && ArrayBuffer.isView
  , $slice       = $ArrayBuffer.prototype.slice
  , VIEW         = $typed.VIEW
  , ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), {ArrayBuffer: $ArrayBuffer});

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it){
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * require('./_fails')(function(){
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end){
    if($slice !== undefined && end === undefined)return $slice.call(anObject(this), start); // FF fix
    var len    = anObject(this).byteLength
      , first  = toIndex(start, len)
      , final  = toIndex(end === undefined ? len : end, len)
      , result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first))
      , viewS  = new $DataView(this)
      , viewT  = new $DataView(result)
      , index  = 0;
    while(first < final){
      viewT.setUint8(index++, viewS.getUint8(first++));
    } return result;
  }
});

require('./_set-species')(ARRAY_BUFFER);
},{"./_an-object":61,"./_export":86,"./_fails":88,"./_global":92,"./_is-object":103,"./_set-species":145,"./_species-constructor":149,"./_to-index":159,"./_to-length":162,"./_typed":167,"./_typed-buffer":166}],299:[function(require,module,exports){
var $export = require('./_export');
$export($export.G + $export.W + $export.F * !require('./_typed').ABV, {
  DataView: require('./_typed-buffer').DataView
});
},{"./_export":86,"./_typed":167,"./_typed-buffer":166}],300:[function(require,module,exports){
require('./_typed-array')('Float32', 4, function(init){
  return function Float32Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":165}],301:[function(require,module,exports){
require('./_typed-array')('Float64', 8, function(init){
  return function Float64Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":165}],302:[function(require,module,exports){
require('./_typed-array')('Int16', 2, function(init){
  return function Int16Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":165}],303:[function(require,module,exports){
require('./_typed-array')('Int32', 4, function(init){
  return function Int32Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":165}],304:[function(require,module,exports){
require('./_typed-array')('Int8', 1, function(init){
  return function Int8Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":165}],305:[function(require,module,exports){
require('./_typed-array')('Uint16', 2, function(init){
  return function Uint16Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":165}],306:[function(require,module,exports){
require('./_typed-array')('Uint32', 4, function(init){
  return function Uint32Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":165}],307:[function(require,module,exports){
require('./_typed-array')('Uint8', 1, function(init){
  return function Uint8Array(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
});
},{"./_typed-array":165}],308:[function(require,module,exports){
require('./_typed-array')('Uint8', 1, function(init){
  return function Uint8ClampedArray(data, byteOffset, length){
    return init(this, data, byteOffset, length);
  };
}, true);
},{"./_typed-array":165}],309:[function(require,module,exports){
'use strict';
var each         = require('./_array-methods')(0)
  , redefine     = require('./_redefine')
  , meta         = require('./_meta')
  , assign       = require('./_object-assign')
  , weak         = require('./_collection-weak')
  , isObject     = require('./_is-object')
  , getWeak      = meta.getWeak
  , isExtensible = Object.isExtensible
  , uncaughtFrozenStore = weak.ufstore
  , tmp          = {}
  , InternalMap;

var wrapper = function(get){
  return function WeakMap(){
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key){
    if(isObject(key)){
      var data = getWeak(key);
      if(data === true)return uncaughtFrozenStore(this).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value){
    return weak.def(this, key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = require('./_collection')('WeakMap', wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if(new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7){
  InternalMap = weak.getConstructor(wrapper);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function(key){
    var proto  = $WeakMap.prototype
      , method = proto[key];
    redefine(proto, key, function(a, b){
      // store frozen objects on internal weakmap shim
      if(isObject(a) && !isExtensible(a)){
        if(!this._f)this._f = new InternalMap;
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}
},{"./_array-methods":66,"./_collection":76,"./_collection-weak":75,"./_is-object":103,"./_meta":116,"./_object-assign":119,"./_redefine":141}],310:[function(require,module,exports){
'use strict';
var weak = require('./_collection-weak');

// 23.4 WeakSet Objects
require('./_collection')('WeakSet', function(get){
  return function WeakSet(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value){
    return weak.def(this, value, true);
  }
}, weak, false, true);
},{"./_collection":76,"./_collection-weak":75}],311:[function(require,module,exports){
'use strict';
// https://github.com/tc39/Array.prototype.includes
var $export   = require('./_export')
  , $includes = require('./_array-includes')(true);

$export($export.P, 'Array', {
  includes: function includes(el /*, fromIndex = 0 */){
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

require('./_add-to-unscopables')('includes');
},{"./_add-to-unscopables":59,"./_array-includes":65,"./_export":86}],312:[function(require,module,exports){
// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
var $export   = require('./_export')
  , microtask = require('./_microtask')()
  , process   = require('./_global').process
  , isNode    = require('./_cof')(process) == 'process';

$export($export.G, {
  asap: function asap(fn){
    var domain = isNode && process.domain;
    microtask(domain ? domain.bind(fn) : fn);
  }
});
},{"./_cof":72,"./_export":86,"./_global":92,"./_microtask":118}],313:[function(require,module,exports){
// https://github.com/ljharb/proposal-is-error
var $export = require('./_export')
  , cof     = require('./_cof');

$export($export.S, 'Error', {
  isError: function isError(it){
    return cof(it) === 'Error';
  }
});
},{"./_cof":72,"./_export":86}],314:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export  = require('./_export');

$export($export.P + $export.R, 'Map', {toJSON: require('./_collection-to-json')('Map')});
},{"./_collection-to-json":74,"./_export":86}],315:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  iaddh: function iaddh(x0, x1, y0, y1){
    var $x0 = x0 >>> 0
      , $x1 = x1 >>> 0
      , $y0 = y0 >>> 0;
    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
  }
});
},{"./_export":86}],316:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  imulh: function imulh(u, v){
    var UINT16 = 0xffff
      , $u = +u
      , $v = +v
      , u0 = $u & UINT16
      , v0 = $v & UINT16
      , u1 = $u >> 16
      , v1 = $v >> 16
      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
  }
});
},{"./_export":86}],317:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  isubh: function isubh(x0, x1, y0, y1){
    var $x0 = x0 >>> 0
      , $x1 = x1 >>> 0
      , $y0 = y0 >>> 0;
    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
  }
});
},{"./_export":86}],318:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  umulh: function umulh(u, v){
    var UINT16 = 0xffff
      , $u = +u
      , $v = +v
      , u0 = $u & UINT16
      , v0 = $v & UINT16
      , u1 = $u >>> 16
      , v1 = $v >>> 16
      , t  = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
  }
});
},{"./_export":86}],319:[function(require,module,exports){
'use strict';
var $export         = require('./_export')
  , toObject        = require('./_to-object')
  , aFunction       = require('./_a-function')
  , $defineProperty = require('./_object-dp');

// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __defineGetter__: function __defineGetter__(P, getter){
    $defineProperty.f(toObject(this), P, {get: aFunction(getter), enumerable: true, configurable: true});
  }
});
},{"./_a-function":57,"./_descriptors":82,"./_export":86,"./_object-dp":121,"./_object-forced-pam":123,"./_to-object":163}],320:[function(require,module,exports){
'use strict';
var $export         = require('./_export')
  , toObject        = require('./_to-object')
  , aFunction       = require('./_a-function')
  , $defineProperty = require('./_object-dp');

// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __defineSetter__: function __defineSetter__(P, setter){
    $defineProperty.f(toObject(this), P, {set: aFunction(setter), enumerable: true, configurable: true});
  }
});
},{"./_a-function":57,"./_descriptors":82,"./_export":86,"./_object-dp":121,"./_object-forced-pam":123,"./_to-object":163}],321:[function(require,module,exports){
// https://github.com/tc39/proposal-object-values-entries
var $export  = require('./_export')
  , $entries = require('./_object-to-array')(true);

$export($export.S, 'Object', {
  entries: function entries(it){
    return $entries(it);
  }
});
},{"./_export":86,"./_object-to-array":133}],322:[function(require,module,exports){
// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export        = require('./_export')
  , ownKeys        = require('./_own-keys')
  , toIObject      = require('./_to-iobject')
  , gOPD           = require('./_object-gopd')
  , createProperty = require('./_create-property');

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object){
    var O       = toIObject(object)
      , getDesc = gOPD.f
      , keys    = ownKeys(O)
      , result  = {}
      , i       = 0
      , key;
    while(keys.length > i)createProperty(result, key = keys[i++], getDesc(O, key));
    return result;
  }
});
},{"./_create-property":78,"./_export":86,"./_object-gopd":124,"./_own-keys":134,"./_to-iobject":161}],323:[function(require,module,exports){
'use strict';
var $export                  = require('./_export')
  , toObject                 = require('./_to-object')
  , toPrimitive              = require('./_to-primitive')
  , getPrototypeOf           = require('./_object-gpo')
  , getOwnPropertyDescriptor = require('./_object-gopd').f;

// B.2.2.4 Object.prototype.__lookupGetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __lookupGetter__: function __lookupGetter__(P){
    var O = toObject(this)
      , K = toPrimitive(P, true)
      , D;
    do {
      if(D = getOwnPropertyDescriptor(O, K))return D.get;
    } while(O = getPrototypeOf(O));
  }
});
},{"./_descriptors":82,"./_export":86,"./_object-forced-pam":123,"./_object-gopd":124,"./_object-gpo":128,"./_to-object":163,"./_to-primitive":164}],324:[function(require,module,exports){
'use strict';
var $export                  = require('./_export')
  , toObject                 = require('./_to-object')
  , toPrimitive              = require('./_to-primitive')
  , getPrototypeOf           = require('./_object-gpo')
  , getOwnPropertyDescriptor = require('./_object-gopd').f;

// B.2.2.5 Object.prototype.__lookupSetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __lookupSetter__: function __lookupSetter__(P){
    var O = toObject(this)
      , K = toPrimitive(P, true)
      , D;
    do {
      if(D = getOwnPropertyDescriptor(O, K))return D.set;
    } while(O = getPrototypeOf(O));
  }
});
},{"./_descriptors":82,"./_export":86,"./_object-forced-pam":123,"./_object-gopd":124,"./_object-gpo":128,"./_to-object":163,"./_to-primitive":164}],325:[function(require,module,exports){
// https://github.com/tc39/proposal-object-values-entries
var $export = require('./_export')
  , $values = require('./_object-to-array')(false);

$export($export.S, 'Object', {
  values: function values(it){
    return $values(it);
  }
});
},{"./_export":86,"./_object-to-array":133}],326:[function(require,module,exports){
'use strict';
// https://github.com/zenparsing/es-observable
var $export     = require('./_export')
  , global      = require('./_global')
  , core        = require('./_core')
  , microtask   = require('./_microtask')()
  , OBSERVABLE  = require('./_wks')('observable')
  , aFunction   = require('./_a-function')
  , anObject    = require('./_an-object')
  , anInstance  = require('./_an-instance')
  , redefineAll = require('./_redefine-all')
  , hide        = require('./_hide')
  , forOf       = require('./_for-of')
  , RETURN      = forOf.RETURN;

var getMethod = function(fn){
  return fn == null ? undefined : aFunction(fn);
};

var cleanupSubscription = function(subscription){
  var cleanup = subscription._c;
  if(cleanup){
    subscription._c = undefined;
    cleanup();
  }
};

var subscriptionClosed = function(subscription){
  return subscription._o === undefined;
};

var closeSubscription = function(subscription){
  if(!subscriptionClosed(subscription)){
    subscription._o = undefined;
    cleanupSubscription(subscription);
  }
};

var Subscription = function(observer, subscriber){
  anObject(observer);
  this._c = undefined;
  this._o = observer;
  observer = new SubscriptionObserver(this);
  try {
    var cleanup      = subscriber(observer)
      , subscription = cleanup;
    if(cleanup != null){
      if(typeof cleanup.unsubscribe === 'function')cleanup = function(){ subscription.unsubscribe(); };
      else aFunction(cleanup);
      this._c = cleanup;
    }
  } catch(e){
    observer.error(e);
    return;
  } if(subscriptionClosed(this))cleanupSubscription(this);
};

Subscription.prototype = redefineAll({}, {
  unsubscribe: function unsubscribe(){ closeSubscription(this); }
});

var SubscriptionObserver = function(subscription){
  this._s = subscription;
};

SubscriptionObserver.prototype = redefineAll({}, {
  next: function next(value){
    var subscription = this._s;
    if(!subscriptionClosed(subscription)){
      var observer = subscription._o;
      try {
        var m = getMethod(observer.next);
        if(m)return m.call(observer, value);
      } catch(e){
        try {
          closeSubscription(subscription);
        } finally {
          throw e;
        }
      }
    }
  },
  error: function error(value){
    var subscription = this._s;
    if(subscriptionClosed(subscription))throw value;
    var observer = subscription._o;
    subscription._o = undefined;
    try {
      var m = getMethod(observer.error);
      if(!m)throw value;
      value = m.call(observer, value);
    } catch(e){
      try {
        cleanupSubscription(subscription);
      } finally {
        throw e;
      }
    } cleanupSubscription(subscription);
    return value;
  },
  complete: function complete(value){
    var subscription = this._s;
    if(!subscriptionClosed(subscription)){
      var observer = subscription._o;
      subscription._o = undefined;
      try {
        var m = getMethod(observer.complete);
        value = m ? m.call(observer, value) : undefined;
      } catch(e){
        try {
          cleanupSubscription(subscription);
        } finally {
          throw e;
        }
      } cleanupSubscription(subscription);
      return value;
    }
  }
});

var $Observable = function Observable(subscriber){
  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
};

redefineAll($Observable.prototype, {
  subscribe: function subscribe(observer){
    return new Subscription(observer, this._f);
  },
  forEach: function forEach(fn){
    var that = this;
    return new (core.Promise || global.Promise)(function(resolve, reject){
      aFunction(fn);
      var subscription = that.subscribe({
        next : function(value){
          try {
            return fn(value);
          } catch(e){
            reject(e);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  }
});

redefineAll($Observable, {
  from: function from(x){
    var C = typeof this === 'function' ? this : $Observable;
    var method = getMethod(anObject(x)[OBSERVABLE]);
    if(method){
      var observable = anObject(method.call(x));
      return observable.constructor === C ? observable : new C(function(observer){
        return observable.subscribe(observer);
      });
    }
    return new C(function(observer){
      var done = false;
      microtask(function(){
        if(!done){
          try {
            if(forOf(x, false, function(it){
              observer.next(it);
              if(done)return RETURN;
            }) === RETURN)return;
          } catch(e){
            if(done)throw e;
            observer.error(e);
            return;
          } observer.complete();
        }
      });
      return function(){ done = true; };
    });
  },
  of: function of(){
    for(var i = 0, l = arguments.length, items = Array(l); i < l;)items[i] = arguments[i++];
    return new (typeof this === 'function' ? this : $Observable)(function(observer){
      var done = false;
      microtask(function(){
        if(!done){
          for(var i = 0; i < items.length; ++i){
            observer.next(items[i]);
            if(done)return;
          } observer.complete();
        }
      });
      return function(){ done = true; };
    });
  }
});

hide($Observable.prototype, OBSERVABLE, function(){ return this; });

$export($export.G, {Observable: $Observable});

require('./_set-species')('Observable');
},{"./_a-function":57,"./_an-instance":60,"./_an-object":61,"./_core":77,"./_export":86,"./_for-of":91,"./_global":92,"./_hide":94,"./_microtask":118,"./_redefine-all":140,"./_set-species":145,"./_wks":171}],327:[function(require,module,exports){
var metadata                  = require('./_metadata')
  , anObject                  = require('./_an-object')
  , toMetaKey                 = metadata.key
  , ordinaryDefineOwnMetadata = metadata.set;

metadata.exp({defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey){
  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
}});
},{"./_an-object":61,"./_metadata":117}],328:[function(require,module,exports){
var metadata               = require('./_metadata')
  , anObject               = require('./_an-object')
  , toMetaKey              = metadata.key
  , getOrCreateMetadataMap = metadata.map
  , store                  = metadata.store;

metadata.exp({deleteMetadata: function deleteMetadata(metadataKey, target /*, targetKey */){
  var targetKey   = arguments.length < 3 ? undefined : toMetaKey(arguments[2])
    , metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
  if(metadataMap === undefined || !metadataMap['delete'](metadataKey))return false;
  if(metadataMap.size)return true;
  var targetMetadata = store.get(target);
  targetMetadata['delete'](targetKey);
  return !!targetMetadata.size || store['delete'](target);
}});
},{"./_an-object":61,"./_metadata":117}],329:[function(require,module,exports){
var Set                     = require('./es6.set')
  , from                    = require('./_array-from-iterable')
  , metadata                = require('./_metadata')
  , anObject                = require('./_an-object')
  , getPrototypeOf          = require('./_object-gpo')
  , ordinaryOwnMetadataKeys = metadata.keys
  , toMetaKey               = metadata.key;

var ordinaryMetadataKeys = function(O, P){
  var oKeys  = ordinaryOwnMetadataKeys(O, P)
    , parent = getPrototypeOf(O);
  if(parent === null)return oKeys;
  var pKeys  = ordinaryMetadataKeys(parent, P);
  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
};

metadata.exp({getMetadataKeys: function getMetadataKeys(target /*, targetKey */){
  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
}});
},{"./_an-object":61,"./_array-from-iterable":64,"./_metadata":117,"./_object-gpo":128,"./es6.set":274}],330:[function(require,module,exports){
var metadata               = require('./_metadata')
  , anObject               = require('./_an-object')
  , getPrototypeOf         = require('./_object-gpo')
  , ordinaryHasOwnMetadata = metadata.has
  , ordinaryGetOwnMetadata = metadata.get
  , toMetaKey              = metadata.key;

var ordinaryGetMetadata = function(MetadataKey, O, P){
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if(hasOwn)return ordinaryGetOwnMetadata(MetadataKey, O, P);
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
};

metadata.exp({getMetadata: function getMetadata(metadataKey, target /*, targetKey */){
  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
}});
},{"./_an-object":61,"./_metadata":117,"./_object-gpo":128}],331:[function(require,module,exports){
var metadata                = require('./_metadata')
  , anObject                = require('./_an-object')
  , ordinaryOwnMetadataKeys = metadata.keys
  , toMetaKey               = metadata.key;

metadata.exp({getOwnMetadataKeys: function getOwnMetadataKeys(target /*, targetKey */){
  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
}});
},{"./_an-object":61,"./_metadata":117}],332:[function(require,module,exports){
var metadata               = require('./_metadata')
  , anObject               = require('./_an-object')
  , ordinaryGetOwnMetadata = metadata.get
  , toMetaKey              = metadata.key;

metadata.exp({getOwnMetadata: function getOwnMetadata(metadataKey, target /*, targetKey */){
  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
}});
},{"./_an-object":61,"./_metadata":117}],333:[function(require,module,exports){
var metadata               = require('./_metadata')
  , anObject               = require('./_an-object')
  , getPrototypeOf         = require('./_object-gpo')
  , ordinaryHasOwnMetadata = metadata.has
  , toMetaKey              = metadata.key;

var ordinaryHasMetadata = function(MetadataKey, O, P){
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if(hasOwn)return true;
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};

metadata.exp({hasMetadata: function hasMetadata(metadataKey, target /*, targetKey */){
  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
}});
},{"./_an-object":61,"./_metadata":117,"./_object-gpo":128}],334:[function(require,module,exports){
var metadata               = require('./_metadata')
  , anObject               = require('./_an-object')
  , ordinaryHasOwnMetadata = metadata.has
  , toMetaKey              = metadata.key;

metadata.exp({hasOwnMetadata: function hasOwnMetadata(metadataKey, target /*, targetKey */){
  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
}});
},{"./_an-object":61,"./_metadata":117}],335:[function(require,module,exports){
var metadata                  = require('./_metadata')
  , anObject                  = require('./_an-object')
  , aFunction                 = require('./_a-function')
  , toMetaKey                 = metadata.key
  , ordinaryDefineOwnMetadata = metadata.set;

metadata.exp({metadata: function metadata(metadataKey, metadataValue){
  return function decorator(target, targetKey){
    ordinaryDefineOwnMetadata(
      metadataKey, metadataValue,
      (targetKey !== undefined ? anObject : aFunction)(target),
      toMetaKey(targetKey)
    );
  };
}});
},{"./_a-function":57,"./_an-object":61,"./_metadata":117}],336:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export  = require('./_export');

$export($export.P + $export.R, 'Set', {toJSON: require('./_collection-to-json')('Set')});
},{"./_collection-to-json":74,"./_export":86}],337:[function(require,module,exports){
'use strict';
// https://github.com/mathiasbynens/String.prototype.at
var $export = require('./_export')
  , $at     = require('./_string-at')(true);

$export($export.P, 'String', {
  at: function at(pos){
    return $at(this, pos);
  }
});
},{"./_export":86,"./_string-at":151}],338:[function(require,module,exports){
'use strict';
// https://tc39.github.io/String.prototype.matchAll/
var $export     = require('./_export')
  , defined     = require('./_defined')
  , toLength    = require('./_to-length')
  , isRegExp    = require('./_is-regexp')
  , getFlags    = require('./_flags')
  , RegExpProto = RegExp.prototype;

var $RegExpStringIterator = function(regexp, string){
  this._r = regexp;
  this._s = string;
};

require('./_iter-create')($RegExpStringIterator, 'RegExp String', function next(){
  var match = this._r.exec(this._s);
  return {value: match, done: match === null};
});

$export($export.P, 'String', {
  matchAll: function matchAll(regexp){
    defined(this);
    if(!isRegExp(regexp))throw TypeError(regexp + ' is not a regexp!');
    var S     = String(this)
      , flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp)
      , rx    = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
    rx.lastIndex = toLength(regexp.lastIndex);
    return new $RegExpStringIterator(rx, S);
  }
});
},{"./_defined":81,"./_export":86,"./_flags":90,"./_is-regexp":104,"./_iter-create":106,"./_to-length":162}],339:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export')
  , $pad    = require('./_string-pad');

$export($export.P, 'String', {
  padEnd: function padEnd(maxLength /*, fillString = ' ' */){
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});
},{"./_export":86,"./_string-pad":154}],340:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export')
  , $pad    = require('./_string-pad');

$export($export.P, 'String', {
  padStart: function padStart(maxLength /*, fillString = ' ' */){
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});
},{"./_export":86,"./_string-pad":154}],341:[function(require,module,exports){
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimLeft', function($trim){
  return function trimLeft(){
    return $trim(this, 1);
  };
}, 'trimStart');
},{"./_string-trim":156}],342:[function(require,module,exports){
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimRight', function($trim){
  return function trimRight(){
    return $trim(this, 2);
  };
}, 'trimEnd');
},{"./_string-trim":156}],343:[function(require,module,exports){
require('./_wks-define')('asyncIterator');
},{"./_wks-define":169}],344:[function(require,module,exports){
require('./_wks-define')('observable');
},{"./_wks-define":169}],345:[function(require,module,exports){
// https://github.com/ljharb/proposal-global
var $export = require('./_export');

$export($export.S, 'System', {global: require('./_global')});
},{"./_export":86,"./_global":92}],346:[function(require,module,exports){
var $iterators    = require('./es6.array.iterator')
  , redefine      = require('./_redefine')
  , global        = require('./_global')
  , hide          = require('./_hide')
  , Iterators     = require('./_iterators')
  , wks           = require('./_wks')
  , ITERATOR      = wks('iterator')
  , TO_STRING_TAG = wks('toStringTag')
  , ArrayValues   = Iterators.Array;

for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
  var NAME       = collections[i]
    , Collection = global[NAME]
    , proto      = Collection && Collection.prototype
    , key;
  if(proto){
    if(!proto[ITERATOR])hide(proto, ITERATOR, ArrayValues);
    if(!proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    for(key in $iterators)if(!proto[key])redefine(proto, key, $iterators[key], true);
  }
}
},{"./_global":92,"./_hide":94,"./_iterators":110,"./_redefine":141,"./_wks":171,"./es6.array.iterator":184}],347:[function(require,module,exports){
var $export = require('./_export')
  , $task   = require('./_task');
$export($export.G + $export.B, {
  setImmediate:   $task.set,
  clearImmediate: $task.clear
});
},{"./_export":86,"./_task":158}],348:[function(require,module,exports){
// ie9- setTimeout & setInterval additional parameters fix
var global     = require('./_global')
  , $export    = require('./_export')
  , invoke     = require('./_invoke')
  , partial    = require('./_partial')
  , navigator  = global.navigator
  , MSIE       = !!navigator && /MSIE .\./.test(navigator.userAgent); // <- dirty ie9- check
var wrap = function(set){
  return MSIE ? function(fn, time /*, ...args */){
    return set(invoke(
      partial,
      [].slice.call(arguments, 2),
      typeof fn == 'function' ? fn : Function(fn)
    ), time);
  } : set;
};
$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout:  wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});
},{"./_export":86,"./_global":92,"./_invoke":98,"./_partial":137}],349:[function(require,module,exports){
require('./modules/es6.symbol');
require('./modules/es6.object.create');
require('./modules/es6.object.define-property');
require('./modules/es6.object.define-properties');
require('./modules/es6.object.get-own-property-descriptor');
require('./modules/es6.object.get-prototype-of');
require('./modules/es6.object.keys');
require('./modules/es6.object.get-own-property-names');
require('./modules/es6.object.freeze');
require('./modules/es6.object.seal');
require('./modules/es6.object.prevent-extensions');
require('./modules/es6.object.is-frozen');
require('./modules/es6.object.is-sealed');
require('./modules/es6.object.is-extensible');
require('./modules/es6.object.assign');
require('./modules/es6.object.is');
require('./modules/es6.object.set-prototype-of');
require('./modules/es6.object.to-string');
require('./modules/es6.function.bind');
require('./modules/es6.function.name');
require('./modules/es6.function.has-instance');
require('./modules/es6.parse-int');
require('./modules/es6.parse-float');
require('./modules/es6.number.constructor');
require('./modules/es6.number.to-fixed');
require('./modules/es6.number.to-precision');
require('./modules/es6.number.epsilon');
require('./modules/es6.number.is-finite');
require('./modules/es6.number.is-integer');
require('./modules/es6.number.is-nan');
require('./modules/es6.number.is-safe-integer');
require('./modules/es6.number.max-safe-integer');
require('./modules/es6.number.min-safe-integer');
require('./modules/es6.number.parse-float');
require('./modules/es6.number.parse-int');
require('./modules/es6.math.acosh');
require('./modules/es6.math.asinh');
require('./modules/es6.math.atanh');
require('./modules/es6.math.cbrt');
require('./modules/es6.math.clz32');
require('./modules/es6.math.cosh');
require('./modules/es6.math.expm1');
require('./modules/es6.math.fround');
require('./modules/es6.math.hypot');
require('./modules/es6.math.imul');
require('./modules/es6.math.log10');
require('./modules/es6.math.log1p');
require('./modules/es6.math.log2');
require('./modules/es6.math.sign');
require('./modules/es6.math.sinh');
require('./modules/es6.math.tanh');
require('./modules/es6.math.trunc');
require('./modules/es6.string.from-code-point');
require('./modules/es6.string.raw');
require('./modules/es6.string.trim');
require('./modules/es6.string.iterator');
require('./modules/es6.string.code-point-at');
require('./modules/es6.string.ends-with');
require('./modules/es6.string.includes');
require('./modules/es6.string.repeat');
require('./modules/es6.string.starts-with');
require('./modules/es6.string.anchor');
require('./modules/es6.string.big');
require('./modules/es6.string.blink');
require('./modules/es6.string.bold');
require('./modules/es6.string.fixed');
require('./modules/es6.string.fontcolor');
require('./modules/es6.string.fontsize');
require('./modules/es6.string.italics');
require('./modules/es6.string.link');
require('./modules/es6.string.small');
require('./modules/es6.string.strike');
require('./modules/es6.string.sub');
require('./modules/es6.string.sup');
require('./modules/es6.date.now');
require('./modules/es6.date.to-json');
require('./modules/es6.date.to-iso-string');
require('./modules/es6.date.to-string');
require('./modules/es6.date.to-primitive');
require('./modules/es6.array.is-array');
require('./modules/es6.array.from');
require('./modules/es6.array.of');
require('./modules/es6.array.join');
require('./modules/es6.array.slice');
require('./modules/es6.array.sort');
require('./modules/es6.array.for-each');
require('./modules/es6.array.map');
require('./modules/es6.array.filter');
require('./modules/es6.array.some');
require('./modules/es6.array.every');
require('./modules/es6.array.reduce');
require('./modules/es6.array.reduce-right');
require('./modules/es6.array.index-of');
require('./modules/es6.array.last-index-of');
require('./modules/es6.array.copy-within');
require('./modules/es6.array.fill');
require('./modules/es6.array.find');
require('./modules/es6.array.find-index');
require('./modules/es6.array.species');
require('./modules/es6.array.iterator');
require('./modules/es6.regexp.constructor');
require('./modules/es6.regexp.to-string');
require('./modules/es6.regexp.flags');
require('./modules/es6.regexp.match');
require('./modules/es6.regexp.replace');
require('./modules/es6.regexp.search');
require('./modules/es6.regexp.split');
require('./modules/es6.promise');
require('./modules/es6.map');
require('./modules/es6.set');
require('./modules/es6.weak-map');
require('./modules/es6.weak-set');
require('./modules/es6.typed.array-buffer');
require('./modules/es6.typed.data-view');
require('./modules/es6.typed.int8-array');
require('./modules/es6.typed.uint8-array');
require('./modules/es6.typed.uint8-clamped-array');
require('./modules/es6.typed.int16-array');
require('./modules/es6.typed.uint16-array');
require('./modules/es6.typed.int32-array');
require('./modules/es6.typed.uint32-array');
require('./modules/es6.typed.float32-array');
require('./modules/es6.typed.float64-array');
require('./modules/es6.reflect.apply');
require('./modules/es6.reflect.construct');
require('./modules/es6.reflect.define-property');
require('./modules/es6.reflect.delete-property');
require('./modules/es6.reflect.enumerate');
require('./modules/es6.reflect.get');
require('./modules/es6.reflect.get-own-property-descriptor');
require('./modules/es6.reflect.get-prototype-of');
require('./modules/es6.reflect.has');
require('./modules/es6.reflect.is-extensible');
require('./modules/es6.reflect.own-keys');
require('./modules/es6.reflect.prevent-extensions');
require('./modules/es6.reflect.set');
require('./modules/es6.reflect.set-prototype-of');
require('./modules/es7.array.includes');
require('./modules/es7.string.at');
require('./modules/es7.string.pad-start');
require('./modules/es7.string.pad-end');
require('./modules/es7.string.trim-left');
require('./modules/es7.string.trim-right');
require('./modules/es7.string.match-all');
require('./modules/es7.symbol.async-iterator');
require('./modules/es7.symbol.observable');
require('./modules/es7.object.get-own-property-descriptors');
require('./modules/es7.object.values');
require('./modules/es7.object.entries');
require('./modules/es7.object.define-getter');
require('./modules/es7.object.define-setter');
require('./modules/es7.object.lookup-getter');
require('./modules/es7.object.lookup-setter');
require('./modules/es7.map.to-json');
require('./modules/es7.set.to-json');
require('./modules/es7.system.global');
require('./modules/es7.error.is-error');
require('./modules/es7.math.iaddh');
require('./modules/es7.math.isubh');
require('./modules/es7.math.imulh');
require('./modules/es7.math.umulh');
require('./modules/es7.reflect.define-metadata');
require('./modules/es7.reflect.delete-metadata');
require('./modules/es7.reflect.get-metadata');
require('./modules/es7.reflect.get-metadata-keys');
require('./modules/es7.reflect.get-own-metadata');
require('./modules/es7.reflect.get-own-metadata-keys');
require('./modules/es7.reflect.has-metadata');
require('./modules/es7.reflect.has-own-metadata');
require('./modules/es7.reflect.metadata');
require('./modules/es7.asap');
require('./modules/es7.observable');
require('./modules/web.timers');
require('./modules/web.immediate');
require('./modules/web.dom.iterable');
module.exports = require('./modules/_core');
},{"./modules/_core":77,"./modules/es6.array.copy-within":174,"./modules/es6.array.every":175,"./modules/es6.array.fill":176,"./modules/es6.array.filter":177,"./modules/es6.array.find":179,"./modules/es6.array.find-index":178,"./modules/es6.array.for-each":180,"./modules/es6.array.from":181,"./modules/es6.array.index-of":182,"./modules/es6.array.is-array":183,"./modules/es6.array.iterator":184,"./modules/es6.array.join":185,"./modules/es6.array.last-index-of":186,"./modules/es6.array.map":187,"./modules/es6.array.of":188,"./modules/es6.array.reduce":190,"./modules/es6.array.reduce-right":189,"./modules/es6.array.slice":191,"./modules/es6.array.some":192,"./modules/es6.array.sort":193,"./modules/es6.array.species":194,"./modules/es6.date.now":195,"./modules/es6.date.to-iso-string":196,"./modules/es6.date.to-json":197,"./modules/es6.date.to-primitive":198,"./modules/es6.date.to-string":199,"./modules/es6.function.bind":200,"./modules/es6.function.has-instance":201,"./modules/es6.function.name":202,"./modules/es6.map":203,"./modules/es6.math.acosh":204,"./modules/es6.math.asinh":205,"./modules/es6.math.atanh":206,"./modules/es6.math.cbrt":207,"./modules/es6.math.clz32":208,"./modules/es6.math.cosh":209,"./modules/es6.math.expm1":210,"./modules/es6.math.fround":211,"./modules/es6.math.hypot":212,"./modules/es6.math.imul":213,"./modules/es6.math.log10":214,"./modules/es6.math.log1p":215,"./modules/es6.math.log2":216,"./modules/es6.math.sign":217,"./modules/es6.math.sinh":218,"./modules/es6.math.tanh":219,"./modules/es6.math.trunc":220,"./modules/es6.number.constructor":221,"./modules/es6.number.epsilon":222,"./modules/es6.number.is-finite":223,"./modules/es6.number.is-integer":224,"./modules/es6.number.is-nan":225,"./modules/es6.number.is-safe-integer":226,"./modules/es6.number.max-safe-integer":227,"./modules/es6.number.min-safe-integer":228,"./modules/es6.number.parse-float":229,"./modules/es6.number.parse-int":230,"./modules/es6.number.to-fixed":231,"./modules/es6.number.to-precision":232,"./modules/es6.object.assign":233,"./modules/es6.object.create":234,"./modules/es6.object.define-properties":235,"./modules/es6.object.define-property":236,"./modules/es6.object.freeze":237,"./modules/es6.object.get-own-property-descriptor":238,"./modules/es6.object.get-own-property-names":239,"./modules/es6.object.get-prototype-of":240,"./modules/es6.object.is":244,"./modules/es6.object.is-extensible":241,"./modules/es6.object.is-frozen":242,"./modules/es6.object.is-sealed":243,"./modules/es6.object.keys":245,"./modules/es6.object.prevent-extensions":246,"./modules/es6.object.seal":247,"./modules/es6.object.set-prototype-of":248,"./modules/es6.object.to-string":249,"./modules/es6.parse-float":250,"./modules/es6.parse-int":251,"./modules/es6.promise":252,"./modules/es6.reflect.apply":253,"./modules/es6.reflect.construct":254,"./modules/es6.reflect.define-property":255,"./modules/es6.reflect.delete-property":256,"./modules/es6.reflect.enumerate":257,"./modules/es6.reflect.get":260,"./modules/es6.reflect.get-own-property-descriptor":258,"./modules/es6.reflect.get-prototype-of":259,"./modules/es6.reflect.has":261,"./modules/es6.reflect.is-extensible":262,"./modules/es6.reflect.own-keys":263,"./modules/es6.reflect.prevent-extensions":264,"./modules/es6.reflect.set":266,"./modules/es6.reflect.set-prototype-of":265,"./modules/es6.regexp.constructor":267,"./modules/es6.regexp.flags":268,"./modules/es6.regexp.match":269,"./modules/es6.regexp.replace":270,"./modules/es6.regexp.search":271,"./modules/es6.regexp.split":272,"./modules/es6.regexp.to-string":273,"./modules/es6.set":274,"./modules/es6.string.anchor":275,"./modules/es6.string.big":276,"./modules/es6.string.blink":277,"./modules/es6.string.bold":278,"./modules/es6.string.code-point-at":279,"./modules/es6.string.ends-with":280,"./modules/es6.string.fixed":281,"./modules/es6.string.fontcolor":282,"./modules/es6.string.fontsize":283,"./modules/es6.string.from-code-point":284,"./modules/es6.string.includes":285,"./modules/es6.string.italics":286,"./modules/es6.string.iterator":287,"./modules/es6.string.link":288,"./modules/es6.string.raw":289,"./modules/es6.string.repeat":290,"./modules/es6.string.small":291,"./modules/es6.string.starts-with":292,"./modules/es6.string.strike":293,"./modules/es6.string.sub":294,"./modules/es6.string.sup":295,"./modules/es6.string.trim":296,"./modules/es6.symbol":297,"./modules/es6.typed.array-buffer":298,"./modules/es6.typed.data-view":299,"./modules/es6.typed.float32-array":300,"./modules/es6.typed.float64-array":301,"./modules/es6.typed.int16-array":302,"./modules/es6.typed.int32-array":303,"./modules/es6.typed.int8-array":304,"./modules/es6.typed.uint16-array":305,"./modules/es6.typed.uint32-array":306,"./modules/es6.typed.uint8-array":307,"./modules/es6.typed.uint8-clamped-array":308,"./modules/es6.weak-map":309,"./modules/es6.weak-set":310,"./modules/es7.array.includes":311,"./modules/es7.asap":312,"./modules/es7.error.is-error":313,"./modules/es7.map.to-json":314,"./modules/es7.math.iaddh":315,"./modules/es7.math.imulh":316,"./modules/es7.math.isubh":317,"./modules/es7.math.umulh":318,"./modules/es7.object.define-getter":319,"./modules/es7.object.define-setter":320,"./modules/es7.object.entries":321,"./modules/es7.object.get-own-property-descriptors":322,"./modules/es7.object.lookup-getter":323,"./modules/es7.object.lookup-setter":324,"./modules/es7.object.values":325,"./modules/es7.observable":326,"./modules/es7.reflect.define-metadata":327,"./modules/es7.reflect.delete-metadata":328,"./modules/es7.reflect.get-metadata":330,"./modules/es7.reflect.get-metadata-keys":329,"./modules/es7.reflect.get-own-metadata":332,"./modules/es7.reflect.get-own-metadata-keys":331,"./modules/es7.reflect.has-metadata":333,"./modules/es7.reflect.has-own-metadata":334,"./modules/es7.reflect.metadata":335,"./modules/es7.set.to-json":336,"./modules/es7.string.at":337,"./modules/es7.string.match-all":338,"./modules/es7.string.pad-end":339,"./modules/es7.string.pad-start":340,"./modules/es7.string.trim-left":341,"./modules/es7.string.trim-right":342,"./modules/es7.symbol.async-iterator":343,"./modules/es7.symbol.observable":344,"./modules/es7.system.global":345,"./modules/web.dom.iterable":346,"./modules/web.immediate":347,"./modules/web.timers":348}],350:[function(require,module,exports){
// Copyright (c) 2013-2014 Quildreen Motta <quildreen@gmail.com>
//
// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation files
// (the "Software"), to deal in the Software without restriction,
// including without limitation the rights to use, copy, modify, merge,
// publish, distribute, sublicense, and/or sell copies of the Software,
// and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = require('./maybe')
},{"./maybe":351}],351:[function(require,module,exports){
// Copyright (c) 2013-2014 Quildreen Motta <quildreen@gmail.com>
//
// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation files
// (the "Software"), to deal in the Software without restriction,
// including without limitation the rights to use, copy, modify, merge,
// publish, distribute, sublicense, and/or sell copies of the Software,
// and to permit persons to whom the Software is furnished to do so,
// subject to the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

/**
 * @module lib/maybe
 */
module.exports = Maybe

// -- Aliases ----------------------------------------------------------
var clone         = Object.create
var unimplemented = function(){ throw new Error('Not implemented.') }
var noop          = function(){ return this                         }

// -- Implementation ---------------------------------------------------

/**
 * A structure for values that may not be present, or computations that may
 * fail. `Maybe(a)` explicitly models the effects that are implicit in
 * `Nullable` types, thus has none of the problems associated with
 * `null` or `undefined` â€” like `NullPointerExceptions`.
 *
 * The class models two different cases:
 *
 *  + `Just a` â€” represents a `Maybe(a)` that contains a value. `a` may
 *     be any value, including `null` or `undefined`.
 *
 *  + `Nothing` â€” represents a `Maybe(a)` that has no values. Or a
 *     failure that needs no additional information.
 *
 * Common uses of this structure includes modelling values that may or may
 * not be present in a collection, thus instead of needing a
 * `collection.has(a)`, the `collection.get(a)` operation gives you all
 * the information you need â€” `collection.get(a).is-nothing` being
 * equivalent to `collection.has(a)`; Similarly the same reasoning may
 * be applied to computations that may fail to provide a value, e.g.:
 * `collection.find(predicate)` can safely return a `Maybe(a)` instance,
 * even if the collection contains nullable values.
 *
 * Furthermore, the values of `Maybe(a)` can be combined and manipulated
 * by using the expressive monadic operations. This allows safely
 * sequencing operations that may fail, and safely composing values that
 * you don't know whether they're present or not, failing early
 * (returning a `Nothing`) if any of the operations fail.
 *
 * If one wants to store additional information about failures, the
 * [Either][] and [Validation][] structures provide such a capability, and
 * should be used instead of the `Maybe(a)` structure.
 *
 * [Either]: https://github.com/folktale/data.either
 * [Validation]: https://github.com/folktale/data.validation
 *
 *
 * @class
 */
function Maybe() {}

// The case for successful values
Just.prototype = clone(Maybe.prototype)
function Just(a){
  this.value = a
}

// The case for failure values
Nothing.prototype = clone(Maybe.prototype)
function Nothing(){}


// -- Constructors -----------------------------------------------------

/**
 * Constructs a new `Maybe[Î±]` structure with an absent value. Commonly used
 * to represent a failure.
 *
 * @summary Void â†’ Maybe[Î±]
 */
Maybe.Nothing = function() {
  return new Nothing
}
Maybe.prototype.Nothing = Maybe.Nothing

/**
 * Constructs a new `Maybe[Î±]` structure that holds the single value
 * `Î±`. Commonly used to represent a success.
 *
 * `Î±` can be any value, including `null`, `undefined` or another
 * `Maybe[Î±]` structure.
 *
 * @summary Î± â†’ Maybe[Î±]
 */
Maybe.Just = function(a) {
  return new Just(a)
}
Maybe.prototype.Just = Maybe.Just


// -- Conversions ------------------------------------------------------

/**
 * Constructs a new `Maybe[Î±]` structure from a nullable type.
 *
 * If the value is either `null` or `undefined`, this function returns a
 * `Nothing`, otherwise the value is wrapped in a `Just(Î±)`.
 *
 * @summary Î± â†’ Maybe[Î±]
 */
Maybe.fromNullable = function(a) {
  return a != null?       new Just(a)
  :      /* otherwise */  new Nothing
}
Maybe.prototype.fromNullable = Maybe.fromNullable

/**
 * Constructs a new `Maybe[Î²]` structure from an `Either[Î±, Î²]` type.
 *
 * The left side of the `Either` becomes `Nothing`, and the right side
 * is wrapped in a `Just(Î²)`.
 *
 * @summary Either[Î±, Î²] â†’ Maybe[Î²]
 */
Maybe.fromEither = function(a) {
  return a.fold(Maybe.Nothing, Maybe.Just)
}
Maybe.prototype.fromEither = Maybe.fromEither

/**
 * Constructs a new `Maybe[Î²]` structure from a `Validation[Î±, Î²]` type.
 *
 * The failure side of the `Validation` becomes `Nothing`, and the right
 * side is wrapped in a `Just(Î²)`.
 *
 * @method
 * @summary Validation[Î±, Î²] â†’ Maybe[Î²]
 */
Maybe.fromValidation           = Maybe.fromEither
Maybe.prototype.fromValidation = Maybe.fromEither


// -- Predicates -------------------------------------------------------

/**
 * True if the `Maybe[Î±]` structure contains a failure (i.e.: `Nothing`).
 *
 * @summary Boolean
 */
Maybe.prototype.isNothing   = false
Nothing.prototype.isNothing = true


/**
 * True if the `Maybe[Î±]` structure contains a single value (i.e.: `Just(Î±)`).
 *
 * @summary Boolean
 */
Maybe.prototype.isJust = false
Just.prototype.isJust  = true


// -- Applicative ------------------------------------------------------

/**
 * Creates a new `Maybe[Î±]` structure holding the single value `Î±`.
 *
 * `Î±` can be any value, including `null`, `undefined`, or another
 * `Maybe[Î±]` structure.
 *
 * @summary Î± â†’ Maybe[Î±]
 */
Maybe.of = function(a) {
  return new Just(a)
}
Maybe.prototype.of = Maybe.of


/**
 * Applies the function inside the `Maybe[Î±]` structure to another
 * applicative type.
 *
 * The `Maybe[Î±]` structure should contain a function value, otherwise a
 * `TypeError` is thrown.
 *
 * @method
 * @summary (@Maybe[Î± â†’ Î²], f:Applicative[_]) => f[Î±] â†’ f[Î²]
 */
Maybe.prototype.ap = unimplemented

Nothing.prototype.ap = noop

Just.prototype.ap = function(b) {
  return b.map(this.value)
}




// -- Functor ----------------------------------------------------------

/**
 * Transforms the value of the `Maybe[Î±]` structure using a regular unary
 * function.
 *
 * @method
 * @summary @Maybe[Î±] => (Î± â†’ Î²) â†’ Maybe[Î²]
 */
Maybe.prototype.map   = unimplemented
Nothing.prototype.map = noop

Just.prototype.map = function(f) {
  return this.of(f(this.value))
}


// -- Chain ------------------------------------------------------------

/**
 * Transforms the value of the `Maybe[Î±]` structure using an unary function
 * to monads.
 *
 * @method
 * @summary (@Maybe[Î±], m:Monad[_]) => (Î± â†’ m[Î²]) â†’ m[Î²]
 */
Maybe.prototype.chain   = unimplemented
Nothing.prototype.chain = noop

Just.prototype.chain = function(f) {
  return f(this.value)
}


// -- Show -------------------------------------------------------------

/**
 * Returns a textual representation of the `Maybe[Î±]` structure.
 *
 * @method
 * @summary @Maybe[Î±] => Void â†’ String
 */
Maybe.prototype.toString = unimplemented

Nothing.prototype.toString = function() {
  return 'Maybe.Nothing'
}

Just.prototype.toString = function() {
  return 'Maybe.Just(' + this.value + ')'
}


// -- Eq ---------------------------------------------------------------

/**
 * Tests if a `Maybe[Î±]` structure is equal to another `Maybe[Î±]` structure.
 *
 * @method
 * @summary @Maybe[Î±] => Maybe[Î±] â†’ Boolean
 */
Maybe.prototype.isEqual = unimplemented

Nothing.prototype.isEqual = function(b) {
  return b.isNothing
}

Just.prototype.isEqual = function(b) {
  return b.isJust
  &&     b.value === this.value
}


// -- Extracting and recovering ----------------------------------------

/**
 * Extracts the value out of the `Maybe[Î±]` structure, if it
 * exists. Otherwise throws a `TypeError`.
 *
 * @method
 * @summary @Maybe[Î±] => Void â†’ a,      :: partial, throws
 * @see {@link module:lib/maybe~Maybe#getOrElse} â€” A getter that can handle failures
 * @throws {TypeError} if the structure has no value (`Nothing`).
 */
Maybe.prototype.get = unimplemented

Nothing.prototype.get = function() {
  throw new TypeError("Can't extract the value of a Nothing.")
}

Just.prototype.get = function() {
  return this.value
}


/**
 * Extracts the value out of the `Maybe[Î±]` structure. If there is no value,
 * returns the given default.
 *
 * @method
 * @summary @Maybe[Î±] => Î± â†’ Î±
 */
Maybe.prototype.getOrElse = unimplemented

Nothing.prototype.getOrElse = function(a) {
  return a
}

Just.prototype.getOrElse = function(_) {
  return this.value
}


/**
 * Transforms a failure into a new `Maybe[Î±]` structure. Does nothing if the
 * structure already contains a value.
 *
 * @method
 * @summary @Maybe[Î±] => (Void â†’ Maybe[Î±]) â†’ Maybe[Î±]
 */
Maybe.prototype.orElse = unimplemented

Nothing.prototype.orElse = function(f) {
  return f()
}

Just.prototype.orElse = function(_) {
  return this
}


/**
 * Catamorphism.
 * 
 * @method
 * @summary @Maybe[Î±] => { Nothing: Void â†’ Î², Just: Î± â†’ Î² } â†’ Î²
 */
Maybe.prototype.cata = unimplemented

Nothing.prototype.cata = function(pattern) {
  return pattern.Nothing()
}

Just.prototype.cata = function(pattern) {
  return pattern.Just(this.value);
}


/**
 * JSON serialisation
 *
 * @method
 * @summary @Maybe[Î±] => Void â†’ Object
 */
Maybe.prototype.toJSON = unimplemented

Nothing.prototype.toJSON = function() {
  return { '#type': 'folktale:Maybe.Nothing' }
}

Just.prototype.toJSON = function() {
  return { '#type': 'folktale:Maybe.Just'
         , value: this.value }
}

},{}],352:[function(require,module,exports){
/*!
 * https://github.com/es-shims/es5-shim
 * @license es5-shim Copyright 2009-2015 by contributors, MIT License
 * see https://github.com/es-shims/es5-shim/blob/master/LICENSE
 */

// vim: ts=4 sts=4 sw=4 expandtab

// Add semicolon to prevent IIFE from being passed as argument to concatenated code.
;

// UMD (Universal Module Definition)
// see https://github.com/umdjs/umd/blob/master/templates/returnExports.js
(function (root, factory) {
    'use strict';

    /* global define, exports, module */
    if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(factory);
    } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like enviroments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals (root is window)
        root.returnExports = factory();
    }
}(this, function () {
    /**
     * Brings an environment as close to ECMAScript 5 compliance
     * as is possible with the facilities of erstwhile engines.
     *
     * Annotated ES5: http://es5.github.com/ (specific links below)
     * ES5 Spec: http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf
     * Required reading: http://javascriptweblog.wordpress.com/2011/12/05/extending-javascript-natives/
     */

    // Shortcut to an often accessed properties, in order to avoid multiple
    // dereference that costs universally. This also holds a reference to known-good
    // functions.
    var $Array = Array;
    var ArrayPrototype = $Array.prototype;
    var $Object = Object;
    var ObjectPrototype = $Object.prototype;
    var $Function = Function;
    var FunctionPrototype = $Function.prototype;
    var $String = String;
    var StringPrototype = $String.prototype;
    var $Number = Number;
    var NumberPrototype = $Number.prototype;
    var array_slice = ArrayPrototype.slice;
    var array_splice = ArrayPrototype.splice;
    var array_push = ArrayPrototype.push;
    var array_unshift = ArrayPrototype.unshift;
    var array_concat = ArrayPrototype.concat;
    var array_join = ArrayPrototype.join;
    var call = FunctionPrototype.call;
    var apply = FunctionPrototype.apply;
    var max = Math.max;
    var min = Math.min;

    // Having a toString local variable name breaks in Opera so use to_string.
    var to_string = ObjectPrototype.toString;

    /* global Symbol */
    /* eslint-disable one-var-declaration-per-line, no-redeclare, max-statements-per-line */
    var hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';
    var isCallable; /* inlined from https://npmjs.com/is-callable */ var fnToStr = Function.prototype.toString, constructorRegex = /^\s*class /, isES6ClassFn = function isES6ClassFn(value) { try { var fnStr = fnToStr.call(value); var singleStripped = fnStr.replace(/\/\/.*\n/g, ''); var multiStripped = singleStripped.replace(/\/\*[.\s\S]*\*\//g, ''); var spaceStripped = multiStripped.replace(/\n/mg, ' ').replace(/ {2}/g, ' '); return constructorRegex.test(spaceStripped); } catch (e) { return false; /* not a function */ } }, tryFunctionObject = function tryFunctionObject(value) { try { if (isES6ClassFn(value)) { return false; } fnToStr.call(value); return true; } catch (e) { return false; } }, fnClass = '[object Function]', genClass = '[object GeneratorFunction]', isCallable = function isCallable(value) { if (!value) { return false; } if (typeof value !== 'function' && typeof value !== 'object') { return false; } if (hasToStringTag) { return tryFunctionObject(value); } if (isES6ClassFn(value)) { return false; } var strClass = to_string.call(value); return strClass === fnClass || strClass === genClass; };

    var isRegex; /* inlined from https://npmjs.com/is-regex */ var regexExec = RegExp.prototype.exec, tryRegexExec = function tryRegexExec(value) { try { regexExec.call(value); return true; } catch (e) { return false; } }, regexClass = '[object RegExp]'; isRegex = function isRegex(value) { if (typeof value !== 'object') { return false; } return hasToStringTag ? tryRegexExec(value) : to_string.call(value) === regexClass; };
    var isString; /* inlined from https://npmjs.com/is-string */ var strValue = String.prototype.valueOf, tryStringObject = function tryStringObject(value) { try { strValue.call(value); return true; } catch (e) { return false; } }, stringClass = '[object String]'; isString = function isString(value) { if (typeof value === 'string') { return true; } if (typeof value !== 'object') { return false; } return hasToStringTag ? tryStringObject(value) : to_string.call(value) === stringClass; };
    /* eslint-enable one-var-declaration-per-line, no-redeclare, max-statements-per-line */

    /* inlined from http://npmjs.com/define-properties */
    var supportsDescriptors = $Object.defineProperty && (function () {
        try {
            var obj = {};
            $Object.defineProperty(obj, 'x', { enumerable: false, value: obj });
            for (var _ in obj) { // jscs:ignore disallowUnusedVariables
                return false;
            }
            return obj.x === obj;
        } catch (e) { /* this is ES3 */
            return false;
        }
    }());
    var defineProperties = (function (has) {
        // Define configurable, writable, and non-enumerable props
        // if they don't exist.
        var defineProperty;
        if (supportsDescriptors) {
            defineProperty = function (object, name, method, forceAssign) {
                if (!forceAssign && (name in object)) {
                    return;
                }
                $Object.defineProperty(object, name, {
                    configurable: true,
                    enumerable: false,
                    writable: true,
                    value: method
                });
            };
        } else {
            defineProperty = function (object, name, method, forceAssign) {
                if (!forceAssign && (name in object)) {
                    return;
                }
                object[name] = method;
            };
        }
        return function defineProperties(object, map, forceAssign) {
            for (var name in map) {
                if (has.call(map, name)) {
                    defineProperty(object, name, map[name], forceAssign);
                }
            }
        };
    }(ObjectPrototype.hasOwnProperty));

    //
    // Util
    // ======
    //

    /* replaceable with https://npmjs.com/package/es-abstract /helpers/isPrimitive */
    var isPrimitive = function isPrimitive(input) {
        var type = typeof input;
        return input === null || (type !== 'object' && type !== 'function');
    };

    var isActualNaN = $Number.isNaN || function isActualNaN(x) {
        return x !== x;
    };

    var ES = {
        // ES5 9.4
        // http://es5.github.com/#x9.4
        // http://jsperf.com/to-integer
        /* replaceable with https://npmjs.com/package/es-abstract ES5.ToInteger */
        ToInteger: function ToInteger(num) {
            var n = +num;
            if (isActualNaN(n)) {
                n = 0;
            } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
                n = (n > 0 || -1) * Math.floor(Math.abs(n));
            }
            return n;
        },

        /* replaceable with https://npmjs.com/package/es-abstract ES5.ToPrimitive */
        ToPrimitive: function ToPrimitive(input) {
            var val, valueOf, toStr;
            if (isPrimitive(input)) {
                return input;
            }
            valueOf = input.valueOf;
            if (isCallable(valueOf)) {
                val = valueOf.call(input);
                if (isPrimitive(val)) {
                    return val;
                }
            }
            toStr = input.toString;
            if (isCallable(toStr)) {
                val = toStr.call(input);
                if (isPrimitive(val)) {
                    return val;
                }
            }
            throw new TypeError();
        },

        // ES5 9.9
        // http://es5.github.com/#x9.9
        /* replaceable with https://npmjs.com/package/es-abstract ES5.ToObject */
        ToObject: function (o) {
            if (o == null) { // this matches both null and undefined
                throw new TypeError("can't convert " + o + ' to object');
            }
            return $Object(o);
        },

        /* replaceable with https://npmjs.com/package/es-abstract ES5.ToUint32 */
        ToUint32: function ToUint32(x) {
            return x >>> 0;
        }
    };

    //
    // Function
    // ========
    //

    // ES-5 15.3.4.5
    // http://es5.github.com/#x15.3.4.5

    var Empty = function Empty() {};

    defineProperties(FunctionPrototype, {
        bind: function bind(that) { // .length is 1
            // 1. Let Target be the this value.
            var target = this;
            // 2. If IsCallable(Target) is false, throw a TypeError exception.
            if (!isCallable(target)) {
                throw new TypeError('Function.prototype.bind called on incompatible ' + target);
            }
            // 3. Let A be a new (possibly empty) internal list of all of the
            //   argument values provided after thisArg (arg1, arg2 etc), in order.
            // XXX slicedArgs will stand in for "A" if used
            var args = array_slice.call(arguments, 1); // for normal call
            // 4. Let F be a new native ECMAScript object.
            // 11. Set the [[Prototype]] internal property of F to the standard
            //   built-in Function prototype object as specified in 15.3.3.1.
            // 12. Set the [[Call]] internal property of F as described in
            //   15.3.4.5.1.
            // 13. Set the [[Construct]] internal property of F as described in
            //   15.3.4.5.2.
            // 14. Set the [[HasInstance]] internal property of F as described in
            //   15.3.4.5.3.
            var bound;
            var binder = function () {

                if (this instanceof bound) {
                    // 15.3.4.5.2 [[Construct]]
                    // When the [[Construct]] internal method of a function object,
                    // F that was created using the bind function is called with a
                    // list of arguments ExtraArgs, the following steps are taken:
                    // 1. Let target be the value of F's [[TargetFunction]]
                    //   internal property.
                    // 2. If target has no [[Construct]] internal method, a
                    //   TypeError exception is thrown.
                    // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
                    //   property.
                    // 4. Let args be a new list containing the same values as the
                    //   list boundArgs in the same order followed by the same
                    //   values as the list ExtraArgs in the same order.
                    // 5. Return the result of calling the [[Construct]] internal
                    //   method of target providing args as the arguments.

                    var result = apply.call(
                        target,
                        this,
                        array_concat.call(args, array_slice.call(arguments))
                    );
                    if ($Object(result) === result) {
                        return result;
                    }
                    return this;

                } else {
                    // 15.3.4.5.1 [[Call]]
                    // When the [[Call]] internal method of a function object, F,
                    // which was created using the bind function is called with a
                    // this value and a list of arguments ExtraArgs, the following
                    // steps are taken:
                    // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
                    //   property.
                    // 2. Let boundThis be the value of F's [[BoundThis]] internal
                    //   property.
                    // 3. Let target be the value of F's [[TargetFunction]] internal
                    //   property.
                    // 4. Let args be a new list containing the same values as the
                    //   list boundArgs in the same order followed by the same
                    //   values as the list ExtraArgs in the same order.
                    // 5. Return the result of calling the [[Call]] internal method
                    //   of target providing boundThis as the this value and
                    //   providing args as the arguments.

                    // equiv: target.call(this, ...boundArgs, ...args)
                    return apply.call(
                        target,
                        that,
                        array_concat.call(args, array_slice.call(arguments))
                    );

                }

            };

            // 15. If the [[Class]] internal property of Target is "Function", then
            //     a. Let L be the length property of Target minus the length of A.
            //     b. Set the length own property of F to either 0 or L, whichever is
            //       larger.
            // 16. Else set the length own property of F to 0.

            var boundLength = max(0, target.length - args.length);

            // 17. Set the attributes of the length own property of F to the values
            //   specified in 15.3.5.1.
            var boundArgs = [];
            for (var i = 0; i < boundLength; i++) {
                array_push.call(boundArgs, '$' + i);
            }

            // XXX Build a dynamic function with desired amount of arguments is the only
            // way to set the length property of a function.
            // In environments where Content Security Policies enabled (Chrome extensions,
            // for ex.) all use of eval or Function costructor throws an exception.
            // However in all of these environments Function.prototype.bind exists
            // and so this code will never be executed.
            bound = $Function('binder', 'return function (' + array_join.call(boundArgs, ',') + '){ return binder.apply(this, arguments); }')(binder);

            if (target.prototype) {
                Empty.prototype = target.prototype;
                bound.prototype = new Empty();
                // Clean up dangling references.
                Empty.prototype = null;
            }

            // TODO
            // 18. Set the [[Extensible]] internal property of F to true.

            // TODO
            // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
            // 20. Call the [[DefineOwnProperty]] internal method of F with
            //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
            //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
            //   false.
            // 21. Call the [[DefineOwnProperty]] internal method of F with
            //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
            //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
            //   and false.

            // TODO
            // NOTE Function objects created using Function.prototype.bind do not
            // have a prototype property or the [[Code]], [[FormalParameters]], and
            // [[Scope]] internal properties.
            // XXX can't delete prototype in pure-js.

            // 22. Return F.
            return bound;
        }
    });

    // _Please note: Shortcuts are defined after `Function.prototype.bind` as we
    // use it in defining shortcuts.
    var owns = call.bind(ObjectPrototype.hasOwnProperty);
    var toStr = call.bind(ObjectPrototype.toString);
    var arraySlice = call.bind(array_slice);
    var arraySliceApply = apply.bind(array_slice);
    var strSlice = call.bind(StringPrototype.slice);
    var strSplit = call.bind(StringPrototype.split);
    var strIndexOf = call.bind(StringPrototype.indexOf);
    var pushCall = call.bind(array_push);
    var isEnum = call.bind(ObjectPrototype.propertyIsEnumerable);
    var arraySort = call.bind(ArrayPrototype.sort);

    //
    // Array
    // =====
    //

    var isArray = $Array.isArray || function isArray(obj) {
        return toStr(obj) === '[object Array]';
    };

    // ES5 15.4.4.12
    // http://es5.github.com/#x15.4.4.13
    // Return len+argCount.
    // [bugfix, ielt8]
    // IE < 8 bug: [].unshift(0) === undefined but should be "1"
    var hasUnshiftReturnValueBug = [].unshift(0) !== 1;
    defineProperties(ArrayPrototype, {
        unshift: function () {
            array_unshift.apply(this, arguments);
            return this.length;
        }
    }, hasUnshiftReturnValueBug);

    // ES5 15.4.3.2
    // http://es5.github.com/#x15.4.3.2
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
    defineProperties($Array, { isArray: isArray });

    // The IsCallable() check in the Array functions
    // has been replaced with a strict check on the
    // internal class of the object to trap cases where
    // the provided function was actually a regular
    // expression literal, which in V8 and
    // JavaScriptCore is a typeof "function".  Only in
    // V8 are regular expression literals permitted as
    // reduce parameters, so it is desirable in the
    // general case for the shim to match the more
    // strict and common behavior of rejecting regular
    // expressions.

    // ES5 15.4.4.18
    // http://es5.github.com/#x15.4.4.18
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/forEach

    // Check failure of by-index access of string characters (IE < 9)
    // and failure of `0 in boxedString` (Rhino)
    var boxedString = $Object('a');
    var splitString = boxedString[0] !== 'a' || !(0 in boxedString);

    var properlyBoxesContext = function properlyBoxed(method) {
        // Check node 0.6.21 bug where third parameter is not boxed
        var properlyBoxesNonStrict = true;
        var properlyBoxesStrict = true;
        var threwException = false;
        if (method) {
            try {
                method.call('foo', function (_, __, context) {
                    if (typeof context !== 'object') {
                        properlyBoxesNonStrict = false;
                    }
                });

                method.call([1], function () {
                    'use strict';

                    properlyBoxesStrict = typeof this === 'string';
                }, 'x');
            } catch (e) {
                threwException = true;
            }
        }
        return !!method && !threwException && properlyBoxesNonStrict && properlyBoxesStrict;
    };

    defineProperties(ArrayPrototype, {
        forEach: function forEach(callbackfn/*, thisArg*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var i = -1;
            var length = ES.ToUint32(self.length);
            var T;
            if (arguments.length > 1) {
                T = arguments[1];
            }

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.forEach callback must be a function');
            }

            while (++i < length) {
                if (i in self) {
                    // Invoke the callback function with call, passing arguments:
                    // context, property value, property key, thisArg object
                    if (typeof T === 'undefined') {
                        callbackfn(self[i], i, object);
                    } else {
                        callbackfn.call(T, self[i], i, object);
                    }
                }
            }
        }
    }, !properlyBoxesContext(ArrayPrototype.forEach));

    // ES5 15.4.4.19
    // http://es5.github.com/#x15.4.4.19
    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
    defineProperties(ArrayPrototype, {
        map: function map(callbackfn/*, thisArg*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);
            var result = $Array(length);
            var T;
            if (arguments.length > 1) {
                T = arguments[1];
            }

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.map callback must be a function');
            }

            for (var i = 0; i < length; i++) {
                if (i in self) {
                    if (typeof T === 'undefined') {
                        result[i] = callbackfn(self[i], i, object);
                    } else {
                        result[i] = callbackfn.call(T, self[i], i, object);
                    }
                }
            }
            return result;
        }
    }, !properlyBoxesContext(ArrayPrototype.map));

    // ES5 15.4.4.20
    // http://es5.github.com/#x15.4.4.20
    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
    defineProperties(ArrayPrototype, {
        filter: function filter(callbackfn/*, thisArg*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);
            var result = [];
            var value;
            var T;
            if (arguments.length > 1) {
                T = arguments[1];
            }

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.filter callback must be a function');
            }

            for (var i = 0; i < length; i++) {
                if (i in self) {
                    value = self[i];
                    if (typeof T === 'undefined' ? callbackfn(value, i, object) : callbackfn.call(T, value, i, object)) {
                        pushCall(result, value);
                    }
                }
            }
            return result;
        }
    }, !properlyBoxesContext(ArrayPrototype.filter));

    // ES5 15.4.4.16
    // http://es5.github.com/#x15.4.4.16
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every
    defineProperties(ArrayPrototype, {
        every: function every(callbackfn/*, thisArg*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);
            var T;
            if (arguments.length > 1) {
                T = arguments[1];
            }

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.every callback must be a function');
            }

            for (var i = 0; i < length; i++) {
                if (i in self && !(typeof T === 'undefined' ? callbackfn(self[i], i, object) : callbackfn.call(T, self[i], i, object))) {
                    return false;
                }
            }
            return true;
        }
    }, !properlyBoxesContext(ArrayPrototype.every));

    // ES5 15.4.4.17
    // http://es5.github.com/#x15.4.4.17
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some
    defineProperties(ArrayPrototype, {
        some: function some(callbackfn/*, thisArg */) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);
            var T;
            if (arguments.length > 1) {
                T = arguments[1];
            }

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.some callback must be a function');
            }

            for (var i = 0; i < length; i++) {
                if (i in self && (typeof T === 'undefined' ? callbackfn(self[i], i, object) : callbackfn.call(T, self[i], i, object))) {
                    return true;
                }
            }
            return false;
        }
    }, !properlyBoxesContext(ArrayPrototype.some));

    // ES5 15.4.4.21
    // http://es5.github.com/#x15.4.4.21
    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduce
    var reduceCoercesToObject = false;
    if (ArrayPrototype.reduce) {
        reduceCoercesToObject = typeof ArrayPrototype.reduce.call('es5', function (_, __, ___, list) {
            return list;
        }) === 'object';
    }
    defineProperties(ArrayPrototype, {
        reduce: function reduce(callbackfn/*, initialValue*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.reduce callback must be a function');
            }

            // no value to return if no initial value and an empty array
            if (length === 0 && arguments.length === 1) {
                throw new TypeError('reduce of empty array with no initial value');
            }

            var i = 0;
            var result;
            if (arguments.length >= 2) {
                result = arguments[1];
            } else {
                do {
                    if (i in self) {
                        result = self[i++];
                        break;
                    }

                    // if array contains no values, no initial value to return
                    if (++i >= length) {
                        throw new TypeError('reduce of empty array with no initial value');
                    }
                } while (true);
            }

            for (; i < length; i++) {
                if (i in self) {
                    result = callbackfn(result, self[i], i, object);
                }
            }

            return result;
        }
    }, !reduceCoercesToObject);

    // ES5 15.4.4.22
    // http://es5.github.com/#x15.4.4.22
    // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduceRight
    var reduceRightCoercesToObject = false;
    if (ArrayPrototype.reduceRight) {
        reduceRightCoercesToObject = typeof ArrayPrototype.reduceRight.call('es5', function (_, __, ___, list) {
            return list;
        }) === 'object';
    }
    defineProperties(ArrayPrototype, {
        reduceRight: function reduceRight(callbackfn/*, initial*/) {
            var object = ES.ToObject(this);
            var self = splitString && isString(this) ? strSplit(this, '') : object;
            var length = ES.ToUint32(self.length);

            // If no callback function or if callback is not a callable function
            if (!isCallable(callbackfn)) {
                throw new TypeError('Array.prototype.reduceRight callback must be a function');
            }

            // no value to return if no initial value, empty array
            if (length === 0 && arguments.length === 1) {
                throw new TypeError('reduceRight of empty array with no initial value');
            }

            var result;
            var i = length - 1;
            if (arguments.length >= 2) {
                result = arguments[1];
            } else {
                do {
                    if (i in self) {
                        result = self[i--];
                        break;
                    }

                    // if array contains no values, no initial value to return
                    if (--i < 0) {
                        throw new TypeError('reduceRight of empty array with no initial value');
                    }
                } while (true);
            }

            if (i < 0) {
                return result;
            }

            do {
                if (i in self) {
                    result = callbackfn(result, self[i], i, object);
                }
            } while (i--);

            return result;
        }
    }, !reduceRightCoercesToObject);

    // ES5 15.4.4.14
    // http://es5.github.com/#x15.4.4.14
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
    var hasFirefox2IndexOfBug = ArrayPrototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
    defineProperties(ArrayPrototype, {
        indexOf: function indexOf(searchElement/*, fromIndex */) {
            var self = splitString && isString(this) ? strSplit(this, '') : ES.ToObject(this);
            var length = ES.ToUint32(self.length);

            if (length === 0) {
                return -1;
            }

            var i = 0;
            if (arguments.length > 1) {
                i = ES.ToInteger(arguments[1]);
            }

            // handle negative indices
            i = i >= 0 ? i : max(0, length + i);
            for (; i < length; i++) {
                if (i in self && self[i] === searchElement) {
                    return i;
                }
            }
            return -1;
        }
    }, hasFirefox2IndexOfBug);

    // ES5 15.4.4.15
    // http://es5.github.com/#x15.4.4.15
    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/lastIndexOf
    var hasFirefox2LastIndexOfBug = ArrayPrototype.lastIndexOf && [0, 1].lastIndexOf(0, -3) !== -1;
    defineProperties(ArrayPrototype, {
        lastIndexOf: function lastIndexOf(searchElement/*, fromIndex */) {
            var self = splitString && isString(this) ? strSplit(this, '') : ES.ToObject(this);
            var length = ES.ToUint32(self.length);

            if (length === 0) {
                return -1;
            }
            var i = length - 1;
            if (arguments.length > 1) {
                i = min(i, ES.ToInteger(arguments[1]));
            }
            // handle negative indices
            i = i >= 0 ? i : length - Math.abs(i);
            for (; i >= 0; i--) {
                if (i in self && searchElement === self[i]) {
                    return i;
                }
            }
            return -1;
        }
    }, hasFirefox2LastIndexOfBug);

    // ES5 15.4.4.12
    // http://es5.github.com/#x15.4.4.12
    var spliceNoopReturnsEmptyArray = (function () {
        var a = [1, 2];
        var result = a.splice();
        return a.length === 2 && isArray(result) && result.length === 0;
    }());
    defineProperties(ArrayPrototype, {
        // Safari 5.0 bug where .splice() returns undefined
        splice: function splice(start, deleteCount) {
            if (arguments.length === 0) {
                return [];
            } else {
                return array_splice.apply(this, arguments);
            }
        }
    }, !spliceNoopReturnsEmptyArray);

    var spliceWorksWithEmptyObject = (function () {
        var obj = {};
        ArrayPrototype.splice.call(obj, 0, 0, 1);
        return obj.length === 1;
    }());
    defineProperties(ArrayPrototype, {
        splice: function splice(start, deleteCount) {
            if (arguments.length === 0) {
                return [];
            }
            var args = arguments;
            this.length = max(ES.ToInteger(this.length), 0);
            if (arguments.length > 0 && typeof deleteCount !== 'number') {
                args = arraySlice(arguments);
                if (args.length < 2) {
                    pushCall(args, this.length - start);
                } else {
                    args[1] = ES.ToInteger(deleteCount);
                }
            }
            return array_splice.apply(this, args);
        }
    }, !spliceWorksWithEmptyObject);
    var spliceWorksWithLargeSparseArrays = (function () {
        // Per https://github.com/es-shims/es5-shim/issues/295
        // Safari 7/8 breaks with sparse arrays of size 1e5 or greater
        var arr = new $Array(1e5);
        // note: the index MUST be 8 or larger or the test will false pass
        arr[8] = 'x';
        arr.splice(1, 1);
        // note: this test must be defined *after* the indexOf shim
        // per https://github.com/es-shims/es5-shim/issues/313
        return arr.indexOf('x') === 7;
    }());
    var spliceWorksWithSmallSparseArrays = (function () {
        // Per https://github.com/es-shims/es5-shim/issues/295
        // Opera 12.15 breaks on this, no idea why.
        var n = 256;
        var arr = [];
        arr[n] = 'a';
        arr.splice(n + 1, 0, 'b');
        return arr[n] === 'a';
    }());
    defineProperties(ArrayPrototype, {
        splice: function splice(start, deleteCount) {
            var O = ES.ToObject(this);
            var A = [];
            var len = ES.ToUint32(O.length);
            var relativeStart = ES.ToInteger(start);
            var actualStart = relativeStart < 0 ? max((len + relativeStart), 0) : min(relativeStart, len);
            var actualDeleteCount = min(max(ES.ToInteger(deleteCount), 0), len - actualStart);

            var k = 0;
            var from;
            while (k < actualDeleteCount) {
                from = $String(actualStart + k);
                if (owns(O, from)) {
                    A[k] = O[from];
                }
                k += 1;
            }

            var items = arraySlice(arguments, 2);
            var itemCount = items.length;
            var to;
            if (itemCount < actualDeleteCount) {
                k = actualStart;
                var maxK = len - actualDeleteCount;
                while (k < maxK) {
                    from = $String(k + actualDeleteCount);
                    to = $String(k + itemCount);
                    if (owns(O, from)) {
                        O[to] = O[from];
                    } else {
                        delete O[to];
                    }
                    k += 1;
                }
                k = len;
                var minK = len - actualDeleteCount + itemCount;
                while (k > minK) {
                    delete O[k - 1];
                    k -= 1;
                }
            } else if (itemCount > actualDeleteCount) {
                k = len - actualDeleteCount;
                while (k > actualStart) {
                    from = $String(k + actualDeleteCount - 1);
                    to = $String(k + itemCount - 1);
                    if (owns(O, from)) {
                        O[to] = O[from];
                    } else {
                        delete O[to];
                    }
                    k -= 1;
                }
            }
            k = actualStart;
            for (var i = 0; i < items.length; ++i) {
                O[k] = items[i];
                k += 1;
            }
            O.length = len - actualDeleteCount + itemCount;

            return A;
        }
    }, !spliceWorksWithLargeSparseArrays || !spliceWorksWithSmallSparseArrays);

    var originalJoin = ArrayPrototype.join;
    var hasStringJoinBug;
    try {
        hasStringJoinBug = Array.prototype.join.call('123', ',') !== '1,2,3';
    } catch (e) {
        hasStringJoinBug = true;
    }
    if (hasStringJoinBug) {
        defineProperties(ArrayPrototype, {
            join: function join(separator) {
                var sep = typeof separator === 'undefined' ? ',' : separator;
                return originalJoin.call(isString(this) ? strSplit(this, '') : this, sep);
            }
        }, hasStringJoinBug);
    }

    var hasJoinUndefinedBug = [1, 2].join(undefined) !== '1,2';
    if (hasJoinUndefinedBug) {
        defineProperties(ArrayPrototype, {
            join: function join(separator) {
                var sep = typeof separator === 'undefined' ? ',' : separator;
                return originalJoin.call(this, sep);
            }
        }, hasJoinUndefinedBug);
    }

    var pushShim = function push(item) {
        var O = ES.ToObject(this);
        var n = ES.ToUint32(O.length);
        var i = 0;
        while (i < arguments.length) {
            O[n + i] = arguments[i];
            i += 1;
        }
        O.length = n + i;
        return n + i;
    };

    var pushIsNotGeneric = (function () {
        var obj = {};
        var result = Array.prototype.push.call(obj, undefined);
        return result !== 1 || obj.length !== 1 || typeof obj[0] !== 'undefined' || !owns(obj, 0);
    }());
    defineProperties(ArrayPrototype, {
        push: function push(item) {
            if (isArray(this)) {
                return array_push.apply(this, arguments);
            }
            return pushShim.apply(this, arguments);
        }
    }, pushIsNotGeneric);

    // This fixes a very weird bug in Opera 10.6 when pushing `undefined
    var pushUndefinedIsWeird = (function () {
        var arr = [];
        var result = arr.push(undefined);
        return result !== 1 || arr.length !== 1 || typeof arr[0] !== 'undefined' || !owns(arr, 0);
    }());
    defineProperties(ArrayPrototype, { push: pushShim }, pushUndefinedIsWeird);

    // ES5 15.2.3.14
    // http://es5.github.io/#x15.4.4.10
    // Fix boxed string bug
    defineProperties(ArrayPrototype, {
        slice: function (start, end) {
            var arr = isString(this) ? strSplit(this, '') : this;
            return arraySliceApply(arr, arguments);
        }
    }, splitString);

    var sortIgnoresNonFunctions = (function () {
        try {
            [1, 2].sort(null);
            [1, 2].sort({});
            return true;
        } catch (e) {}
        return false;
    }());
    var sortThrowsOnRegex = (function () {
        // this is a problem in Firefox 4, in which `typeof /a/ === 'function'`
        try {
            [1, 2].sort(/a/);
            return false;
        } catch (e) {}
        return true;
    }());
    var sortIgnoresUndefined = (function () {
        // applies in IE 8, for one.
        try {
            [1, 2].sort(undefined);
            return true;
        } catch (e) {}
        return false;
    }());
    defineProperties(ArrayPrototype, {
        sort: function sort(compareFn) {
            if (typeof compareFn === 'undefined') {
                return arraySort(this);
            }
            if (!isCallable(compareFn)) {
                throw new TypeError('Array.prototype.sort callback must be a function');
            }
            return arraySort(this, compareFn);
        }
    }, sortIgnoresNonFunctions || !sortIgnoresUndefined || !sortThrowsOnRegex);

    //
    // Object
    // ======
    //

    // ES5 15.2.3.14
    // http://es5.github.com/#x15.2.3.14

    // http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
    var hasDontEnumBug = !isEnum({ 'toString': null }, 'toString');
    var hasProtoEnumBug = isEnum(function () {}, 'prototype');
    var hasStringEnumBug = !owns('x', '0');
    var equalsConstructorPrototype = function (o) {
        var ctor = o.constructor;
        return ctor && ctor.prototype === o;
    };
    var blacklistedKeys = {
        $window: true,
        $console: true,
        $parent: true,
        $self: true,
        $frame: true,
        $frames: true,
        $frameElement: true,
        $webkitIndexedDB: true,
        $webkitStorageInfo: true,
        $external: true
    };
    var hasAutomationEqualityBug = (function () {
        /* globals window */
        if (typeof window === 'undefined') {
            return false;
        }
        for (var k in window) {
            try {
                if (!blacklistedKeys['$' + k] && owns(window, k) && window[k] !== null && typeof window[k] === 'object') {
                    equalsConstructorPrototype(window[k]);
                }
            } catch (e) {
                return true;
            }
        }
        return false;
    }());
    var equalsConstructorPrototypeIfNotBuggy = function (object) {
        if (typeof window === 'undefined' || !hasAutomationEqualityBug) {
            return equalsConstructorPrototype(object);
        }
        try {
            return equalsConstructorPrototype(object);
        } catch (e) {
            return false;
        }
    };
    var dontEnums = [
        'toString',
        'toLocaleString',
        'valueOf',
        'hasOwnProperty',
        'isPrototypeOf',
        'propertyIsEnumerable',
        'constructor'
    ];
    var dontEnumsLength = dontEnums.length;

    // taken directly from https://github.com/ljharb/is-arguments/blob/master/index.js
    // can be replaced with require('is-arguments') if we ever use a build process instead
    var isStandardArguments = function isArguments(value) {
        return toStr(value) === '[object Arguments]';
    };
    var isLegacyArguments = function isArguments(value) {
        return value !== null &&
            typeof value === 'object' &&
            typeof value.length === 'number' &&
            value.length >= 0 &&
            !isArray(value) &&
            isCallable(value.callee);
    };
    var isArguments = isStandardArguments(arguments) ? isStandardArguments : isLegacyArguments;

    defineProperties($Object, {
        keys: function keys(object) {
            var isFn = isCallable(object);
            var isArgs = isArguments(object);
            var isObject = object !== null && typeof object === 'object';
            var isStr = isObject && isString(object);

            if (!isObject && !isFn && !isArgs) {
                throw new TypeError('Object.keys called on a non-object');
            }

            var theKeys = [];
            var skipProto = hasProtoEnumBug && isFn;
            if ((isStr && hasStringEnumBug) || isArgs) {
                for (var i = 0; i < object.length; ++i) {
                    pushCall(theKeys, $String(i));
                }
            }

            if (!isArgs) {
                for (var name in object) {
                    if (!(skipProto && name === 'prototype') && owns(object, name)) {
                        pushCall(theKeys, $String(name));
                    }
                }
            }

            if (hasDontEnumBug) {
                var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
                for (var j = 0; j < dontEnumsLength; j++) {
                    var dontEnum = dontEnums[j];
                    if (!(skipConstructor && dontEnum === 'constructor') && owns(object, dontEnum)) {
                        pushCall(theKeys, dontEnum);
                    }
                }
            }
            return theKeys;
        }
    });

    var keysWorksWithArguments = $Object.keys && (function () {
        // Safari 5.0 bug
        return $Object.keys(arguments).length === 2;
    }(1, 2));
    var keysHasArgumentsLengthBug = $Object.keys && (function () {
        var argKeys = $Object.keys(arguments);
        return arguments.length !== 1 || argKeys.length !== 1 || argKeys[0] !== 1;
    }(1));
    var originalKeys = $Object.keys;
    defineProperties($Object, {
        keys: function keys(object) {
            if (isArguments(object)) {
                return originalKeys(arraySlice(object));
            } else {
                return originalKeys(object);
            }
        }
    }, !keysWorksWithArguments || keysHasArgumentsLengthBug);

    //
    // Date
    // ====
    //

    var hasNegativeMonthYearBug = new Date(-3509827329600292).getUTCMonth() !== 0;
    var aNegativeTestDate = new Date(-1509842289600292);
    var aPositiveTestDate = new Date(1449662400000);
    var hasToUTCStringFormatBug = aNegativeTestDate.toUTCString() !== 'Mon, 01 Jan -45875 11:59:59 GMT';
    var hasToDateStringFormatBug;
    var hasToStringFormatBug;
    var timeZoneOffset = aNegativeTestDate.getTimezoneOffset();
    if (timeZoneOffset < -720) {
        hasToDateStringFormatBug = aNegativeTestDate.toDateString() !== 'Tue Jan 02 -45875';
        hasToStringFormatBug = !(/^Thu Dec 10 2015 \d\d:\d\d:\d\d GMT[-\+]\d\d\d\d(?: |$)/).test(aPositiveTestDate.toString());
    } else {
        hasToDateStringFormatBug = aNegativeTestDate.toDateString() !== 'Mon Jan 01 -45875';
        hasToStringFormatBug = !(/^Wed Dec 09 2015 \d\d:\d\d:\d\d GMT[-\+]\d\d\d\d(?: |$)/).test(aPositiveTestDate.toString());
    }

    var originalGetFullYear = call.bind(Date.prototype.getFullYear);
    var originalGetMonth = call.bind(Date.prototype.getMonth);
    var originalGetDate = call.bind(Date.prototype.getDate);
    var originalGetUTCFullYear = call.bind(Date.prototype.getUTCFullYear);
    var originalGetUTCMonth = call.bind(Date.prototype.getUTCMonth);
    var originalGetUTCDate = call.bind(Date.prototype.getUTCDate);
    var originalGetUTCDay = call.bind(Date.prototype.getUTCDay);
    var originalGetUTCHours = call.bind(Date.prototype.getUTCHours);
    var originalGetUTCMinutes = call.bind(Date.prototype.getUTCMinutes);
    var originalGetUTCSeconds = call.bind(Date.prototype.getUTCSeconds);
    var originalGetUTCMilliseconds = call.bind(Date.prototype.getUTCMilliseconds);
    var dayName = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    var monthName = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    var daysInMonth = function daysInMonth(month, year) {
        return originalGetDate(new Date(year, month, 0));
    };

    defineProperties(Date.prototype, {
        getFullYear: function getFullYear() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetFullYear(this);
            if (year < 0 && originalGetMonth(this) > 11) {
                return year + 1;
            }
            return year;
        },
        getMonth: function getMonth() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetFullYear(this);
            var month = originalGetMonth(this);
            if (year < 0 && month > 11) {
                return 0;
            }
            return month;
        },
        getDate: function getDate() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetFullYear(this);
            var month = originalGetMonth(this);
            var date = originalGetDate(this);
            if (year < 0 && month > 11) {
                if (month === 12) {
                    return date;
                }
                var days = daysInMonth(0, year + 1);
                return (days - date) + 1;
            }
            return date;
        },
        getUTCFullYear: function getUTCFullYear() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetUTCFullYear(this);
            if (year < 0 && originalGetUTCMonth(this) > 11) {
                return year + 1;
            }
            return year;
        },
        getUTCMonth: function getUTCMonth() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetUTCFullYear(this);
            var month = originalGetUTCMonth(this);
            if (year < 0 && month > 11) {
                return 0;
            }
            return month;
        },
        getUTCDate: function getUTCDate() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var year = originalGetUTCFullYear(this);
            var month = originalGetUTCMonth(this);
            var date = originalGetUTCDate(this);
            if (year < 0 && month > 11) {
                if (month === 12) {
                    return date;
                }
                var days = daysInMonth(0, year + 1);
                return (days - date) + 1;
            }
            return date;
        }
    }, hasNegativeMonthYearBug);

    defineProperties(Date.prototype, {
        toUTCString: function toUTCString() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var day = originalGetUTCDay(this);
            var date = originalGetUTCDate(this);
            var month = originalGetUTCMonth(this);
            var year = originalGetUTCFullYear(this);
            var hour = originalGetUTCHours(this);
            var minute = originalGetUTCMinutes(this);
            var second = originalGetUTCSeconds(this);
            return dayName[day] + ', ' +
                (date < 10 ? '0' + date : date) + ' ' +
                monthName[month] + ' ' +
                year + ' ' +
                (hour < 10 ? '0' + hour : hour) + ':' +
                (minute < 10 ? '0' + minute : minute) + ':' +
                (second < 10 ? '0' + second : second) + ' GMT';
        }
    }, hasNegativeMonthYearBug || hasToUTCStringFormatBug);

    // Opera 12 has `,`
    defineProperties(Date.prototype, {
        toDateString: function toDateString() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var day = this.getDay();
            var date = this.getDate();
            var month = this.getMonth();
            var year = this.getFullYear();
            return dayName[day] + ' ' +
                monthName[month] + ' ' +
                (date < 10 ? '0' + date : date) + ' ' +
                year;
        }
    }, hasNegativeMonthYearBug || hasToDateStringFormatBug);

    // can't use defineProperties here because of toString enumeration issue in IE <= 8
    if (hasNegativeMonthYearBug || hasToStringFormatBug) {
        Date.prototype.toString = function toString() {
            if (!this || !(this instanceof Date)) {
                throw new TypeError('this is not a Date object.');
            }
            var day = this.getDay();
            var date = this.getDate();
            var month = this.getMonth();
            var year = this.getFullYear();
            var hour = this.getHours();
            var minute = this.getMinutes();
            var second = this.getSeconds();
            var timezoneOffset = this.getTimezoneOffset();
            var hoursOffset = Math.floor(Math.abs(timezoneOffset) / 60);
            var minutesOffset = Math.floor(Math.abs(timezoneOffset) % 60);
            return dayName[day] + ' ' +
                monthName[month] + ' ' +
                (date < 10 ? '0' + date : date) + ' ' +
                year + ' ' +
                (hour < 10 ? '0' + hour : hour) + ':' +
                (minute < 10 ? '0' + minute : minute) + ':' +
                (second < 10 ? '0' + second : second) + ' GMT' +
                (timezoneOffset > 0 ? '-' : '+') +
                (hoursOffset < 10 ? '0' + hoursOffset : hoursOffset) +
                (minutesOffset < 10 ? '0' + minutesOffset : minutesOffset);
        };
        if (supportsDescriptors) {
            $Object.defineProperty(Date.prototype, 'toString', {
                configurable: true,
                enumerable: false,
                writable: true
            });
        }
    }

    // ES5 15.9.5.43
    // http://es5.github.com/#x15.9.5.43
    // This function returns a String value represent the instance in time
    // represented by this Date object. The format of the String is the Date Time
    // string format defined in 15.9.1.15. All fields are present in the String.
    // The time zone is always UTC, denoted by the suffix Z. If the time value of
    // this object is not a finite Number a RangeError exception is thrown.
    var negativeDate = -62198755200000;
    var negativeYearString = '-000001';
    var hasNegativeDateBug = Date.prototype.toISOString && new Date(negativeDate).toISOString().indexOf(negativeYearString) === -1;
    var hasSafari51DateBug = Date.prototype.toISOString && new Date(-1).toISOString() !== '1969-12-31T23:59:59.999Z';

    var getTime = call.bind(Date.prototype.getTime);

    defineProperties(Date.prototype, {
        toISOString: function toISOString() {
            if (!isFinite(this) || !isFinite(getTime(this))) {
                // Adope Photoshop requires the second check.
                throw new RangeError('Date.prototype.toISOString called on non-finite value.');
            }

            var year = originalGetUTCFullYear(this);

            var month = originalGetUTCMonth(this);
            // see https://github.com/es-shims/es5-shim/issues/111
            year += Math.floor(month / 12);
            month = (month % 12 + 12) % 12;

            // the date time string format is specified in 15.9.1.15.
            var result = [month + 1, originalGetUTCDate(this), originalGetUTCHours(this), originalGetUTCMinutes(this), originalGetUTCSeconds(this)];
            year = (
                (year < 0 ? '-' : (year > 9999 ? '+' : '')) +
                strSlice('00000' + Math.abs(year), (0 <= year && year <= 9999) ? -4 : -6)
            );

            for (var i = 0; i < result.length; ++i) {
                // pad months, days, hours, minutes, and seconds to have two digits.
                result[i] = strSlice('00' + result[i], -2);
            }
            // pad milliseconds to have three digits.
            return (
                year + '-' + arraySlice(result, 0, 2).join('-') +
                'T' + arraySlice(result, 2).join(':') + '.' +
                strSlice('000' + originalGetUTCMilliseconds(this), -3) + 'Z'
            );
        }
    }, hasNegativeDateBug || hasSafari51DateBug);

    // ES5 15.9.5.44
    // http://es5.github.com/#x15.9.5.44
    // This function provides a String representation of a Date object for use by
    // JSON.stringify (15.12.3).
    var dateToJSONIsSupported = (function () {
        try {
            return Date.prototype.toJSON &&
                new Date(NaN).toJSON() === null &&
                new Date(negativeDate).toJSON().indexOf(negativeYearString) !== -1 &&
                Date.prototype.toJSON.call({ // generic
                    toISOString: function () { return true; }
                });
        } catch (e) {
            return false;
        }
    }());
    if (!dateToJSONIsSupported) {
        Date.prototype.toJSON = function toJSON(key) {
            // When the toJSON method is called with argument key, the following
            // steps are taken:

            // 1.  Let O be the result of calling ToObject, giving it the this
            // value as its argument.
            // 2. Let tv be ES.ToPrimitive(O, hint Number).
            var O = $Object(this);
            var tv = ES.ToPrimitive(O);
            // 3. If tv is a Number and is not finite, return null.
            if (typeof tv === 'number' && !isFinite(tv)) {
                return null;
            }
            // 4. Let toISO be the result of calling the [[Get]] internal method of
            // O with argument "toISOString".
            var toISO = O.toISOString;
            // 5. If IsCallable(toISO) is false, throw a TypeError exception.
            if (!isCallable(toISO)) {
                throw new TypeError('toISOString property is not callable');
            }
            // 6. Return the result of calling the [[Call]] internal method of
            //  toISO with O as the this value and an empty argument list.
            return toISO.call(O);

            // NOTE 1 The argument is ignored.

            // NOTE 2 The toJSON function is intentionally generic; it does not
            // require that its this value be a Date object. Therefore, it can be
            // transferred to other kinds of objects for use as a method. However,
            // it does require that any such object have a toISOString method. An
            // object is free to use the argument key to filter its
            // stringification.
        };
    }

    // ES5 15.9.4.2
    // http://es5.github.com/#x15.9.4.2
    // based on work shared by Daniel Friesen (dantman)
    // http://gist.github.com/303249
    var supportsExtendedYears = Date.parse('+033658-09-27T01:46:40.000Z') === 1e15;
    var acceptsInvalidDates = !isNaN(Date.parse('2012-04-04T24:00:00.500Z')) || !isNaN(Date.parse('2012-11-31T23:59:59.000Z')) || !isNaN(Date.parse('2012-12-31T23:59:60.000Z'));
    var doesNotParseY2KNewYear = isNaN(Date.parse('2000-01-01T00:00:00.000Z'));
    if (doesNotParseY2KNewYear || acceptsInvalidDates || !supportsExtendedYears) {
        // XXX global assignment won't work in embeddings that use
        // an alternate object for the context.
        /* global Date: true */
        /* eslint-disable no-undef */
        var maxSafeUnsigned32Bit = Math.pow(2, 31) - 1;
        var hasSafariSignedIntBug = isActualNaN(new Date(1970, 0, 1, 0, 0, 0, maxSafeUnsigned32Bit + 1).getTime());
        /* eslint-disable no-implicit-globals */
        Date = (function (NativeDate) {
        /* eslint-enable no-implicit-globals */
        /* eslint-enable no-undef */
            // Date.length === 7
            var DateShim = function Date(Y, M, D, h, m, s, ms) {
                var length = arguments.length;
                var date;
                if (this instanceof NativeDate) {
                    var seconds = s;
                    var millis = ms;
                    if (hasSafariSignedIntBug && length >= 7 && ms > maxSafeUnsigned32Bit) {
                        // work around a Safari 8/9 bug where it treats the seconds as signed
                        var msToShift = Math.floor(ms / maxSafeUnsigned32Bit) * maxSafeUnsigned32Bit;
                        var sToShift = Math.floor(msToShift / 1e3);
                        seconds += sToShift;
                        millis -= sToShift * 1e3;
                    }
                    date = length === 1 && $String(Y) === Y ? // isString(Y)
                        // We explicitly pass it through parse:
                        new NativeDate(DateShim.parse(Y)) :
                        // We have to manually make calls depending on argument
                        // length here
                        length >= 7 ? new NativeDate(Y, M, D, h, m, seconds, millis) :
                        length >= 6 ? new NativeDate(Y, M, D, h, m, seconds) :
                        length >= 5 ? new NativeDate(Y, M, D, h, m) :
                        length >= 4 ? new NativeDate(Y, M, D, h) :
                        length >= 3 ? new NativeDate(Y, M, D) :
                        length >= 2 ? new NativeDate(Y, M) :
                        length >= 1 ? new NativeDate(Y instanceof NativeDate ? +Y : Y) :
                                      new NativeDate();
                } else {
                    date = NativeDate.apply(this, arguments);
                }
                if (!isPrimitive(date)) {
                    // Prevent mixups with unfixed Date object
                    defineProperties(date, { constructor: DateShim }, true);
                }
                return date;
            };

            // 15.9.1.15 Date Time String Format.
            var isoDateExpression = new RegExp('^' +
                '(\\d{4}|[+-]\\d{6})' + // four-digit year capture or sign +
                                          // 6-digit extended year
                '(?:-(\\d{2})' + // optional month capture
                '(?:-(\\d{2})' + // optional day capture
                '(?:' + // capture hours:minutes:seconds.milliseconds
                    'T(\\d{2})' + // hours capture
                    ':(\\d{2})' + // minutes capture
                    '(?:' + // optional :seconds.milliseconds
                        ':(\\d{2})' + // seconds capture
                        '(?:(\\.\\d{1,}))?' + // milliseconds capture
                    ')?' +
                '(' + // capture UTC offset component
                    'Z|' + // UTC capture
                    '(?:' + // offset specifier +/-hours:minutes
                        '([-+])' + // sign capture
                        '(\\d{2})' + // hours offset capture
                        ':(\\d{2})' + // minutes offset capture
                    ')' +
                ')?)?)?)?' +
            '$');

            var months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365];

            var dayFromMonth = function dayFromMonth(year, month) {
                var t = month > 1 ? 1 : 0;
                return (
                    months[month] +
                    Math.floor((year - 1969 + t) / 4) -
                    Math.floor((year - 1901 + t) / 100) +
                    Math.floor((year - 1601 + t) / 400) +
                    365 * (year - 1970)
                );
            };

            var toUTC = function toUTC(t) {
                var s = 0;
                var ms = t;
                if (hasSafariSignedIntBug && ms > maxSafeUnsigned32Bit) {
                    // work around a Safari 8/9 bug where it treats the seconds as signed
                    var msToShift = Math.floor(ms / maxSafeUnsigned32Bit) * maxSafeUnsigned32Bit;
                    var sToShift = Math.floor(msToShift / 1e3);
                    s += sToShift;
                    ms -= sToShift * 1e3;
                }
                return $Number(new NativeDate(1970, 0, 1, 0, 0, s, ms));
            };

            // Copy any custom methods a 3rd party library may have added
            for (var key in NativeDate) {
                if (owns(NativeDate, key)) {
                    DateShim[key] = NativeDate[key];
                }
            }

            // Copy "native" methods explicitly; they may be non-enumerable
            defineProperties(DateShim, {
                now: NativeDate.now,
                UTC: NativeDate.UTC
            }, true);
            DateShim.prototype = NativeDate.prototype;
            defineProperties(DateShim.prototype, {
                constructor: DateShim
            }, true);

            // Upgrade Date.parse to handle simplified ISO 8601 strings
            var parseShim = function parse(string) {
                var match = isoDateExpression.exec(string);
                if (match) {
                    // parse months, days, hours, minutes, seconds, and milliseconds
                    // provide default values if necessary
                    // parse the UTC offset component
                    var year = $Number(match[1]),
                        month = $Number(match[2] || 1) - 1,
                        day = $Number(match[3] || 1) - 1,
                        hour = $Number(match[4] || 0),
                        minute = $Number(match[5] || 0),
                        second = $Number(match[6] || 0),
                        millisecond = Math.floor($Number(match[7] || 0) * 1000),
                        // When time zone is missed, local offset should be used
                        // (ES 5.1 bug)
                        // see https://bugs.ecmascript.org/show_bug.cgi?id=112
                        isLocalTime = Boolean(match[4] && !match[8]),
                        signOffset = match[9] === '-' ? 1 : -1,
                        hourOffset = $Number(match[10] || 0),
                        minuteOffset = $Number(match[11] || 0),
                        result;
                    var hasMinutesOrSecondsOrMilliseconds = minute > 0 || second > 0 || millisecond > 0;
                    if (
                        hour < (hasMinutesOrSecondsOrMilliseconds ? 24 : 25) &&
                        minute < 60 && second < 60 && millisecond < 1000 &&
                        month > -1 && month < 12 && hourOffset < 24 &&
                        minuteOffset < 60 && // detect invalid offsets
                        day > -1 &&
                        day < (dayFromMonth(year, month + 1) - dayFromMonth(year, month))
                    ) {
                        result = (
                            (dayFromMonth(year, month) + day) * 24 +
                            hour +
                            hourOffset * signOffset
                        ) * 60;
                        result = (
                            (result + minute + minuteOffset * signOffset) * 60 +
                            second
                        ) * 1000 + millisecond;
                        if (isLocalTime) {
                            result = toUTC(result);
                        }
                        if (-8.64e15 <= result && result <= 8.64e15) {
                            return result;
                        }
                    }
                    return NaN;
                }
                return NativeDate.parse.apply(this, arguments);
            };
            defineProperties(DateShim, { parse: parseShim });

            return DateShim;
        }(Date));
        /* global Date: false */
    }

    // ES5 15.9.4.4
    // http://es5.github.com/#x15.9.4.4
    if (!Date.now) {
        Date.now = function now() {
            return new Date().getTime();
        };
    }

    //
    // Number
    // ======
    //

    // ES5.1 15.7.4.5
    // http://es5.github.com/#x15.7.4.5
    var hasToFixedBugs = NumberPrototype.toFixed && (
      (0.00008).toFixed(3) !== '0.000' ||
      (0.9).toFixed(0) !== '1' ||
      (1.255).toFixed(2) !== '1.25' ||
      (1000000000000000128).toFixed(0) !== '1000000000000000128'
    );

    var toFixedHelpers = {
        base: 1e7,
        size: 6,
        data: [0, 0, 0, 0, 0, 0],
        multiply: function multiply(n, c) {
            var i = -1;
            var c2 = c;
            while (++i < toFixedHelpers.size) {
                c2 += n * toFixedHelpers.data[i];
                toFixedHelpers.data[i] = c2 % toFixedHelpers.base;
                c2 = Math.floor(c2 / toFixedHelpers.base);
            }
        },
        divide: function divide(n) {
            var i = toFixedHelpers.size;
            var c = 0;
            while (--i >= 0) {
                c += toFixedHelpers.data[i];
                toFixedHelpers.data[i] = Math.floor(c / n);
                c = (c % n) * toFixedHelpers.base;
            }
        },
        numToString: function numToString() {
            var i = toFixedHelpers.size;
            var s = '';
            while (--i >= 0) {
                if (s !== '' || i === 0 || toFixedHelpers.data[i] !== 0) {
                    var t = $String(toFixedHelpers.data[i]);
                    if (s === '') {
                        s = t;
                    } else {
                        s += strSlice('0000000', 0, 7 - t.length) + t;
                    }
                }
            }
            return s;
        },
        pow: function pow(x, n, acc) {
            return (n === 0 ? acc : (n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc)));
        },
        log: function log(x) {
            var n = 0;
            var x2 = x;
            while (x2 >= 4096) {
                n += 12;
                x2 /= 4096;
            }
            while (x2 >= 2) {
                n += 1;
                x2 /= 2;
            }
            return n;
        }
    };

    var toFixedShim = function toFixed(fractionDigits) {
        var f, x, s, m, e, z, j, k;

        // Test for NaN and round fractionDigits down
        f = $Number(fractionDigits);
        f = isActualNaN(f) ? 0 : Math.floor(f);

        if (f < 0 || f > 20) {
            throw new RangeError('Number.toFixed called with invalid number of decimals');
        }

        x = $Number(this);

        if (isActualNaN(x)) {
            return 'NaN';
        }

        // If it is too big or small, return the string value of the number
        if (x <= -1e21 || x >= 1e21) {
            return $String(x);
        }

        s = '';

        if (x < 0) {
            s = '-';
            x = -x;
        }

        m = '0';

        if (x > 1e-21) {
            // 1e-21 < x < 1e21
            // -70 < log2(x) < 70
            e = toFixedHelpers.log(x * toFixedHelpers.pow(2, 69, 1)) - 69;
            z = (e < 0 ? x * toFixedHelpers.pow(2, -e, 1) : x / toFixedHelpers.pow(2, e, 1));
            z *= 0x10000000000000; // Math.pow(2, 52);
            e = 52 - e;

            // -18 < e < 122
            // x = z / 2 ^ e
            if (e > 0) {
                toFixedHelpers.multiply(0, z);
                j = f;

                while (j >= 7) {
                    toFixedHelpers.multiply(1e7, 0);
                    j -= 7;
                }

                toFixedHelpers.multiply(toFixedHelpers.pow(10, j, 1), 0);
                j = e - 1;

                while (j >= 23) {
                    toFixedHelpers.divide(1 << 23);
                    j -= 23;
                }

                toFixedHelpers.divide(1 << j);
                toFixedHelpers.multiply(1, 1);
                toFixedHelpers.divide(2);
                m = toFixedHelpers.numToString();
            } else {
                toFixedHelpers.multiply(0, z);
                toFixedHelpers.multiply(1 << (-e), 0);
                m = toFixedHelpers.numToString() + strSlice('0.00000000000000000000', 2, 2 + f);
            }
        }

        if (f > 0) {
            k = m.length;

            if (k <= f) {
                m = s + strSlice('0.0000000000000000000', 0, f - k + 2) + m;
            } else {
                m = s + strSlice(m, 0, k - f) + '.' + strSlice(m, k - f);
            }
        } else {
            m = s + m;
        }

        return m;
    };
    defineProperties(NumberPrototype, { toFixed: toFixedShim }, hasToFixedBugs);

    var hasToPrecisionUndefinedBug = (function () {
        try {
            return 1.0.toPrecision(undefined) === '1';
        } catch (e) {
            return true;
        }
    }());
    var originalToPrecision = NumberPrototype.toPrecision;
    defineProperties(NumberPrototype, {
        toPrecision: function toPrecision(precision) {
            return typeof precision === 'undefined' ? originalToPrecision.call(this) : originalToPrecision.call(this, precision);
        }
    }, hasToPrecisionUndefinedBug);

    //
    // String
    // ======
    //

    // ES5 15.5.4.14
    // http://es5.github.com/#x15.5.4.14

    // [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
    // Many browsers do not split properly with regular expressions or they
    // do not perform the split correctly under obscure conditions.
    // See http://blog.stevenlevithan.com/archives/cross-browser-split
    // I've tested in many browsers and this seems to cover the deviant ones:
    //    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
    //    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
    //    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
    //       [undefined, "t", undefined, "e", ...]
    //    ''.split(/.?/) should be [], not [""]
    //    '.'.split(/()()/) should be ["."], not ["", "", "."]

    if (
        'ab'.split(/(?:ab)*/).length !== 2 ||
        '.'.split(/(.?)(.?)/).length !== 4 ||
        'tesst'.split(/(s)*/)[1] === 't' ||
        'test'.split(/(?:)/, -1).length !== 4 ||
        ''.split(/.?/).length ||
        '.'.split(/()()/).length > 1
    ) {
        (function () {
            var compliantExecNpcg = typeof (/()??/).exec('')[1] === 'undefined'; // NPCG: nonparticipating capturing group
            var maxSafe32BitInt = Math.pow(2, 32) - 1;

            StringPrototype.split = function (separator, limit) {
                var string = String(this);
                if (typeof separator === 'undefined' && limit === 0) {
                    return [];
                }

                // If `separator` is not a regex, use native split
                if (!isRegex(separator)) {
                    return strSplit(this, separator, limit);
                }

                var output = [];
                var flags = (separator.ignoreCase ? 'i' : '') +
                            (separator.multiline ? 'm' : '') +
                            (separator.unicode ? 'u' : '') + // in ES6
                            (separator.sticky ? 'y' : ''), // Firefox 3+ and ES6
                    lastLastIndex = 0,
                    // Make `global` and avoid `lastIndex` issues by working with a copy
                    separator2, match, lastIndex, lastLength;
                var separatorCopy = new RegExp(separator.source, flags + 'g');
                if (!compliantExecNpcg) {
                    // Doesn't need flags gy, but they don't hurt
                    separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
                }
                /* Values for `limit`, per the spec:
                 * If undefined: 4294967295 // maxSafe32BitInt
                 * If 0, Infinity, or NaN: 0
                 * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
                 * If negative number: 4294967296 - Math.floor(Math.abs(limit))
                 * If other: Type-convert, then use the above rules
                 */
                var splitLimit = typeof limit === 'undefined' ? maxSafe32BitInt : ES.ToUint32(limit);
                match = separatorCopy.exec(string);
                while (match) {
                    // `separatorCopy.lastIndex` is not reliable cross-browser
                    lastIndex = match.index + match[0].length;
                    if (lastIndex > lastLastIndex) {
                        pushCall(output, strSlice(string, lastLastIndex, match.index));
                        // Fix browsers whose `exec` methods don't consistently return `undefined` for
                        // nonparticipating capturing groups
                        if (!compliantExecNpcg && match.length > 1) {
                            /* eslint-disable no-loop-func */
                            match[0].replace(separator2, function () {
                                for (var i = 1; i < arguments.length - 2; i++) {
                                    if (typeof arguments[i] === 'undefined') {
                                        match[i] = void 0;
                                    }
                                }
                            });
                            /* eslint-enable no-loop-func */
                        }
                        if (match.length > 1 && match.index < string.length) {
                            array_push.apply(output, arraySlice(match, 1));
                        }
                        lastLength = match[0].length;
                        lastLastIndex = lastIndex;
                        if (output.length >= splitLimit) {
                            break;
                        }
                    }
                    if (separatorCopy.lastIndex === match.index) {
                        separatorCopy.lastIndex++; // Avoid an infinite loop
                    }
                    match = separatorCopy.exec(string);
                }
                if (lastLastIndex === string.length) {
                    if (lastLength || !separatorCopy.test('')) {
                        pushCall(output, '');
                    }
                } else {
                    pushCall(output, strSlice(string, lastLastIndex));
                }
                return output.length > splitLimit ? arraySlice(output, 0, splitLimit) : output;
            };
        }());

    // [bugfix, chrome]
    // If separator is undefined, then the result array contains just one String,
    // which is the this value (converted to a String). If limit is not undefined,
    // then the output array is truncated so that it contains no more than limit
    // elements.
    // "0".split(undefined, 0) -> []
    } else if ('0'.split(void 0, 0).length) {
        StringPrototype.split = function split(separator, limit) {
            if (typeof separator === 'undefined' && limit === 0) {
                return [];
            }
            return strSplit(this, separator, limit);
        };
    }

    var str_replace = StringPrototype.replace;
    var replaceReportsGroupsCorrectly = (function () {
        var groups = [];
        'x'.replace(/x(.)?/g, function (match, group) {
            pushCall(groups, group);
        });
        return groups.length === 1 && typeof groups[0] === 'undefined';
    }());

    if (!replaceReportsGroupsCorrectly) {
        StringPrototype.replace = function replace(searchValue, replaceValue) {
            var isFn = isCallable(replaceValue);
            var hasCapturingGroups = isRegex(searchValue) && (/\)[*?]/).test(searchValue.source);
            if (!isFn || !hasCapturingGroups) {
                return str_replace.call(this, searchValue, replaceValue);
            } else {
                var wrappedReplaceValue = function (match) {
                    var length = arguments.length;
                    var originalLastIndex = searchValue.lastIndex;
                    searchValue.lastIndex = 0;
                    var args = searchValue.exec(match) || [];
                    searchValue.lastIndex = originalLastIndex;
                    pushCall(args, arguments[length - 2], arguments[length - 1]);
                    return replaceValue.apply(this, args);
                };
                return str_replace.call(this, searchValue, wrappedReplaceValue);
            }
        };
    }

    // ECMA-262, 3rd B.2.3
    // Not an ECMAScript standard, although ECMAScript 3rd Edition has a
    // non-normative section suggesting uniform semantics and it should be
    // normalized across all browsers
    // [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
    var string_substr = StringPrototype.substr;
    var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
    defineProperties(StringPrototype, {
        substr: function substr(start, length) {
            var normalizedStart = start;
            if (start < 0) {
                normalizedStart = max(this.length + start, 0);
            }
            return string_substr.call(this, normalizedStart, length);
        }
    }, hasNegativeSubstrBug);

    // ES5 15.5.4.20
    // whitespace from: http://es5.github.io/#x15.5.4.20
    var ws = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
        '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' +
        '\u2029\uFEFF';
    var zeroWidth = '\u200b';
    var wsRegexChars = '[' + ws + ']';
    var trimBeginRegexp = new RegExp('^' + wsRegexChars + wsRegexChars + '*');
    var trimEndRegexp = new RegExp(wsRegexChars + wsRegexChars + '*$');
    var hasTrimWhitespaceBug = StringPrototype.trim && (ws.trim() || !zeroWidth.trim());
    defineProperties(StringPrototype, {
        // http://blog.stevenlevithan.com/archives/faster-trim-javascript
        // http://perfectionkills.com/whitespace-deviations/
        trim: function trim() {
            if (typeof this === 'undefined' || this === null) {
                throw new TypeError("can't convert " + this + ' to object');
            }
            return $String(this).replace(trimBeginRegexp, '').replace(trimEndRegexp, '');
        }
    }, hasTrimWhitespaceBug);
    var trim = call.bind(String.prototype.trim);

    var hasLastIndexBug = StringPrototype.lastIndexOf && 'abcã‚ã„'.lastIndexOf('ã‚ã„', 2) !== -1;
    defineProperties(StringPrototype, {
        lastIndexOf: function lastIndexOf(searchString) {
            if (typeof this === 'undefined' || this === null) {
                throw new TypeError("can't convert " + this + ' to object');
            }
            var S = $String(this);
            var searchStr = $String(searchString);
            var numPos = arguments.length > 1 ? $Number(arguments[1]) : NaN;
            var pos = isActualNaN(numPos) ? Infinity : ES.ToInteger(numPos);
            var start = min(max(pos, 0), S.length);
            var searchLen = searchStr.length;
            var k = start + searchLen;
            while (k > 0) {
                k = max(0, k - searchLen);
                var index = strIndexOf(strSlice(S, k, start + searchLen), searchStr);
                if (index !== -1) {
                    return k + index;
                }
            }
            return -1;
        }
    }, hasLastIndexBug);

    var originalLastIndexOf = StringPrototype.lastIndexOf;
    defineProperties(StringPrototype, {
        lastIndexOf: function lastIndexOf(searchString) {
            return originalLastIndexOf.apply(this, arguments);
        }
    }, StringPrototype.lastIndexOf.length !== 1);

    // ES-5 15.1.2.2
    /* eslint-disable radix */
    if (parseInt(ws + '08') !== 8 || parseInt(ws + '0x16') !== 22) {
    /* eslint-enable radix */
        /* global parseInt: true */
        parseInt = (function (origParseInt) {
            var hexRegex = /^[\-+]?0[xX]/;
            return function parseInt(str, radix) {
                var string = trim(String(str));
                var defaultedRadix = $Number(radix) || (hexRegex.test(string) ? 16 : 10);
                return origParseInt(string, defaultedRadix);
            };
        }(parseInt));
    }

    // https://es5.github.io/#x15.1.2.3
    if (1 / parseFloat('-0') !== -Infinity) {
        /* global parseFloat: true */
        parseFloat = (function (origParseFloat) {
            return function parseFloat(string) {
                var inputString = trim(String(string));
                var result = origParseFloat(inputString);
                return result === 0 && strSlice(inputString, 0, 1) === '-' ? -0 : result;
            };
        }(parseFloat));
    }

    if (String(new RangeError('test')) !== 'RangeError: test') {
        var errorToStringShim = function toString() {
            if (typeof this === 'undefined' || this === null) {
                throw new TypeError("can't convert " + this + ' to object');
            }
            var name = this.name;
            if (typeof name === 'undefined') {
                name = 'Error';
            } else if (typeof name !== 'string') {
                name = $String(name);
            }
            var msg = this.message;
            if (typeof msg === 'undefined') {
                msg = '';
            } else if (typeof msg !== 'string') {
                msg = $String(msg);
            }
            if (!name) {
                return msg;
            }
            if (!msg) {
                return name;
            }
            return name + ': ' + msg;
        };
        // can't use defineProperties here because of toString enumeration issue in IE <= 8
        Error.prototype.toString = errorToStringShim;
    }

    if (supportsDescriptors) {
        var ensureNonEnumerable = function (obj, prop) {
            if (isEnum(obj, prop)) {
                var desc = Object.getOwnPropertyDescriptor(obj, prop);
                if (desc.configurable) {
                    desc.enumerable = false;
                    Object.defineProperty(obj, prop, desc);
                }
            }
        };
        ensureNonEnumerable(Error.prototype, 'message');
        if (Error.prototype.message !== '') {
            Error.prototype.message = '';
        }
        ensureNonEnumerable(Error.prototype, 'name');
    }

    if (String(/a/mig) !== '/a/gim') {
        var regexToString = function toString() {
            var str = '/' + this.source + '/';
            if (this.global) {
                str += 'g';
            }
            if (this.ignoreCase) {
                str += 'i';
            }
            if (this.multiline) {
                str += 'm';
            }
            return str;
        };
        // can't use defineProperties here because of toString enumeration issue in IE <= 8
        RegExp.prototype.toString = regexToString;
    }
}));

},{}],353:[function(require,module,exports){
(function (process,global){
 /*!
  * https://github.com/paulmillr/es6-shim
  * @license es6-shim Copyright 2013-2016 by Paul Miller (http://paulmillr.com)
  *   and contributors,  MIT License
  * es6-shim: v0.35.1
  * see https://github.com/paulmillr/es6-shim/blob/0.35.1/LICENSE
  * Details and documentation:
  * https://github.com/paulmillr/es6-shim/
  */

// UMD (Universal Module Definition)
// see https://github.com/umdjs/umd/blob/master/returnExports.js
(function (root, factory) {
  /*global define, module, exports */
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(factory);
  } else if (typeof exports === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like environments that support module.exports,
    // like Node.
    module.exports = factory();
  } else {
    // Browser globals (root is window)
    root.returnExports = factory();
  }
}(this, function () {
  'use strict';

  var _apply = Function.call.bind(Function.apply);
  var _call = Function.call.bind(Function.call);
  var isArray = Array.isArray;
  var keys = Object.keys;

  var not = function notThunker(func) {
    return function notThunk() {
      return !_apply(func, this, arguments);
    };
  };
  var throwsError = function (func) {
    try {
      func();
      return false;
    } catch (e) {
      return true;
    }
  };
  var valueOrFalseIfThrows = function valueOrFalseIfThrows(func) {
    try {
      return func();
    } catch (e) {
      return false;
    }
  };

  var isCallableWithoutNew = not(throwsError);
  var arePropertyDescriptorsSupported = function () {
    // if Object.defineProperty exists but throws, it's IE 8
    return !throwsError(function () {
      Object.defineProperty({}, 'x', { get: function () {} });
    });
  };
  var supportsDescriptors = !!Object.defineProperty && arePropertyDescriptorsSupported();
  var functionsHaveNames = (function foo() {}).name === 'foo'; // eslint-disable-line no-extra-parens

  var _forEach = Function.call.bind(Array.prototype.forEach);
  var _reduce = Function.call.bind(Array.prototype.reduce);
  var _filter = Function.call.bind(Array.prototype.filter);
  var _some = Function.call.bind(Array.prototype.some);

  var defineProperty = function (object, name, value, force) {
    if (!force && name in object) { return; }
    if (supportsDescriptors) {
      Object.defineProperty(object, name, {
        configurable: true,
        enumerable: false,
        writable: true,
        value: value
      });
    } else {
      object[name] = value;
    }
  };

  // Define configurable, writable and non-enumerable props
  // if they donâ€™t exist.
  var defineProperties = function (object, map, forceOverride) {
    _forEach(keys(map), function (name) {
      var method = map[name];
      defineProperty(object, name, method, !!forceOverride);
    });
  };

  var _toString = Function.call.bind(Object.prototype.toString);
  var isCallable = typeof /abc/ === 'function' ? function IsCallableSlow(x) {
    // Some old browsers (IE, FF) say that typeof /abc/ === 'function'
    return typeof x === 'function' && _toString(x) === '[object Function]';
  } : function IsCallableFast(x) { return typeof x === 'function'; };

  var Value = {
    getter: function (object, name, getter) {
      if (!supportsDescriptors) {
        throw new TypeError('getters require true ES5 support');
      }
      Object.defineProperty(object, name, {
        configurable: true,
        enumerable: false,
        get: getter
      });
    },
    proxy: function (originalObject, key, targetObject) {
      if (!supportsDescriptors) {
        throw new TypeError('getters require true ES5 support');
      }
      var originalDescriptor = Object.getOwnPropertyDescriptor(originalObject, key);
      Object.defineProperty(targetObject, key, {
        configurable: originalDescriptor.configurable,
        enumerable: originalDescriptor.enumerable,
        get: function getKey() { return originalObject[key]; },
        set: function setKey(value) { originalObject[key] = value; }
      });
    },
    redefine: function (object, property, newValue) {
      if (supportsDescriptors) {
        var descriptor = Object.getOwnPropertyDescriptor(object, property);
        descriptor.value = newValue;
        Object.defineProperty(object, property, descriptor);
      } else {
        object[property] = newValue;
      }
    },
    defineByDescriptor: function (object, property, descriptor) {
      if (supportsDescriptors) {
        Object.defineProperty(object, property, descriptor);
      } else if ('value' in descriptor) {
        object[property] = descriptor.value;
      }
    },
    preserveToString: function (target, source) {
      if (source && isCallable(source.toString)) {
        defineProperty(target, 'toString', source.toString.bind(source), true);
      }
    }
  };

  // Simple shim for Object.create on ES3 browsers
  // (unlike real shim, no attempt to support `prototype === null`)
  var create = Object.create || function (prototype, properties) {
    var Prototype = function Prototype() {};
    Prototype.prototype = prototype;
    var object = new Prototype();
    if (typeof properties !== 'undefined') {
      keys(properties).forEach(function (key) {
        Value.defineByDescriptor(object, key, properties[key]);
      });
    }
    return object;
  };

  var supportsSubclassing = function (C, f) {
    if (!Object.setPrototypeOf) { return false; /* skip test on IE < 11 */ }
    return valueOrFalseIfThrows(function () {
      var Sub = function Subclass(arg) {
        var o = new C(arg);
        Object.setPrototypeOf(o, Subclass.prototype);
        return o;
      };
      Object.setPrototypeOf(Sub, C);
      Sub.prototype = create(C.prototype, {
        constructor: { value: Sub }
      });
      return f(Sub);
    });
  };

  var getGlobal = function () {
    /* global self, window, global */
    // the only reliable means to get the global object is
    // `Function('return this')()`
    // However, this causes CSP violations in Chrome apps.
    if (typeof self !== 'undefined') { return self; }
    if (typeof window !== 'undefined') { return window; }
    if (typeof global !== 'undefined') { return global; }
    throw new Error('unable to locate global object');
  };

  var globals = getGlobal();
  var globalIsFinite = globals.isFinite;
  var _indexOf = Function.call.bind(String.prototype.indexOf);
  var _arrayIndexOfApply = Function.apply.bind(Array.prototype.indexOf);
  var _concat = Function.call.bind(Array.prototype.concat);
  // var _sort = Function.call.bind(Array.prototype.sort);
  var _strSlice = Function.call.bind(String.prototype.slice);
  var _push = Function.call.bind(Array.prototype.push);
  var _pushApply = Function.apply.bind(Array.prototype.push);
  var _shift = Function.call.bind(Array.prototype.shift);
  var _max = Math.max;
  var _min = Math.min;
  var _floor = Math.floor;
  var _abs = Math.abs;
  var _exp = Math.exp;
  var _log = Math.log;
  var _sqrt = Math.sqrt;
  var _hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);
  var ArrayIterator; // make our implementation private
  var noop = function () {};

  var Symbol = globals.Symbol || {};
  var symbolSpecies = Symbol.species || '@@species';

  var numberIsNaN = Number.isNaN || function isNaN(value) {
    // NaN !== NaN, but they are identical.
    // NaNs are the only non-reflexive value, i.e., if x !== x,
    // then x is NaN.
    // isNaN is broken: it converts its argument to number, so
    // isNaN('foo') => true
    return value !== value;
  };
  var numberIsFinite = Number.isFinite || function isFinite(value) {
    return typeof value === 'number' && globalIsFinite(value);
  };
  var _sign = isCallable(Math.sign) ? Math.sign : function sign(value) {
    var number = Number(value);
    if (number === 0) { return number; }
    if (numberIsNaN(number)) { return number; }
    return number < 0 ? -1 : 1;
  };

  // taken directly from https://github.com/ljharb/is-arguments/blob/master/index.js
  // can be replaced with require('is-arguments') if we ever use a build process instead
  var isStandardArguments = function isArguments(value) {
    return _toString(value) === '[object Arguments]';
  };
  var isLegacyArguments = function isArguments(value) {
    return value !== null &&
      typeof value === 'object' &&
      typeof value.length === 'number' &&
      value.length >= 0 &&
      _toString(value) !== '[object Array]' &&
      _toString(value.callee) === '[object Function]';
  };
  var isArguments = isStandardArguments(arguments) ? isStandardArguments : isLegacyArguments;

  var Type = {
    primitive: function (x) { return x === null || (typeof x !== 'function' && typeof x !== 'object'); },
    string: function (x) { return _toString(x) === '[object String]'; },
    regex: function (x) { return _toString(x) === '[object RegExp]'; },
    symbol: function (x) {
      return typeof globals.Symbol === 'function' && typeof x === 'symbol';
    }
  };

  var overrideNative = function overrideNative(object, property, replacement) {
    var original = object[property];
    defineProperty(object, property, replacement, true);
    Value.preserveToString(object[property], original);
  };

  var hasSymbols = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' && Type.symbol(Symbol());

  // This is a private name in the es6 spec, equal to '[Symbol.iterator]'
  // we're going to use an arbitrary _-prefixed name to make our shims
  // work properly with each other, even though we don't have full Iterator
  // support.  That is, `Array.from(map.keys())` will work, but we don't
  // pretend to export a "real" Iterator interface.
  var $iterator$ = Type.symbol(Symbol.iterator) ? Symbol.iterator : '_es6-shim iterator_';
  // Firefox ships a partial implementation using the name @@iterator.
  // https://bugzilla.mozilla.org/show_bug.cgi?id=907077#c14
  // So use that name if we detect it.
  if (globals.Set && typeof new globals.Set()['@@iterator'] === 'function') {
    $iterator$ = '@@iterator';
  }

  // Reflect
  if (!globals.Reflect) {
    defineProperty(globals, 'Reflect', {}, true);
  }
  var Reflect = globals.Reflect;

  var $String = String;

  var ES = {
    // http://www.ecma-international.org/ecma-262/6.0/#sec-call
    Call: function Call(F, V) {
      var args = arguments.length > 2 ? arguments[2] : [];
      if (!ES.IsCallable(F)) {
        throw new TypeError(F + ' is not a function');
      }
      return _apply(F, V, args);
    },

    RequireObjectCoercible: function (x, optMessage) {
      /* jshint eqnull:true */
      if (x == null) {
        throw new TypeError(optMessage || 'Cannot call method on ' + x);
      }
      return x;
    },

    // This might miss the "(non-standard exotic and does not implement
    // [[Call]])" case from
    // http://www.ecma-international.org/ecma-262/6.0/#sec-typeof-operator-runtime-semantics-evaluation
    // but we can't find any evidence these objects exist in practice.
    // If we find some in the future, you could test `Object(x) === x`,
    // which is reliable according to
    // http://www.ecma-international.org/ecma-262/6.0/#sec-toobject
    // but is not well optimized by runtimes and creates an object
    // whenever it returns false, and thus is very slow.
    TypeIsObject: function (x) {
      if (x === void 0 || x === null || x === true || x === false) {
        return false;
      }
      return typeof x === 'function' || typeof x === 'object';
    },

    ToObject: function (o, optMessage) {
      return Object(ES.RequireObjectCoercible(o, optMessage));
    },

    IsCallable: isCallable,

    IsConstructor: function (x) {
      // We can't tell callables from constructors in ES5
      return ES.IsCallable(x);
    },

    ToInt32: function (x) {
      return ES.ToNumber(x) >> 0;
    },

    ToUint32: function (x) {
      return ES.ToNumber(x) >>> 0;
    },

    ToNumber: function (value) {
      if (_toString(value) === '[object Symbol]') {
        throw new TypeError('Cannot convert a Symbol value to a number');
      }
      return +value;
    },

    ToInteger: function (value) {
      var number = ES.ToNumber(value);
      if (numberIsNaN(number)) { return 0; }
      if (number === 0 || !numberIsFinite(number)) { return number; }
      return (number > 0 ? 1 : -1) * _floor(_abs(number));
    },

    ToLength: function (value) {
      var len = ES.ToInteger(value);
      if (len <= 0) { return 0; } // includes converting -0 to +0
      if (len > Number.MAX_SAFE_INTEGER) { return Number.MAX_SAFE_INTEGER; }
      return len;
    },

    SameValue: function (a, b) {
      if (a === b) {
        // 0 === -0, but they are not identical.
        if (a === 0) { return 1 / a === 1 / b; }
        return true;
      }
      return numberIsNaN(a) && numberIsNaN(b);
    },

    SameValueZero: function (a, b) {
      // same as SameValue except for SameValueZero(+0, -0) == true
      return (a === b) || (numberIsNaN(a) && numberIsNaN(b));
    },

    IsIterable: function (o) {
      return ES.TypeIsObject(o) && (typeof o[$iterator$] !== 'undefined' || isArguments(o));
    },

    GetIterator: function (o) {
      if (isArguments(o)) {
        // special case support for `arguments`
        return new ArrayIterator(o, 'value');
      }
      var itFn = ES.GetMethod(o, $iterator$);
      if (!ES.IsCallable(itFn)) {
        // Better diagnostics if itFn is null or undefined
        throw new TypeError('value is not an iterable');
      }
      var it = ES.Call(itFn, o);
      if (!ES.TypeIsObject(it)) {
        throw new TypeError('bad iterator');
      }
      return it;
    },

    GetMethod: function (o, p) {
      var func = ES.ToObject(o)[p];
      if (func === void 0 || func === null) {
        return void 0;
      }
      if (!ES.IsCallable(func)) {
        throw new TypeError('Method not callable: ' + p);
      }
      return func;
    },

    IteratorComplete: function (iterResult) {
      return !!iterResult.done;
    },

    IteratorClose: function (iterator, completionIsThrow) {
      var returnMethod = ES.GetMethod(iterator, 'return');
      if (returnMethod === void 0) {
        return;
      }
      var innerResult, innerException;
      try {
        innerResult = ES.Call(returnMethod, iterator);
      } catch (e) {
        innerException = e;
      }
      if (completionIsThrow) {
        return;
      }
      if (innerException) {
        throw innerException;
      }
      if (!ES.TypeIsObject(innerResult)) {
        throw new TypeError("Iterator's return method returned a non-object.");
      }
    },

    IteratorNext: function (it) {
      var result = arguments.length > 1 ? it.next(arguments[1]) : it.next();
      if (!ES.TypeIsObject(result)) {
        throw new TypeError('bad iterator');
      }
      return result;
    },

    IteratorStep: function (it) {
      var result = ES.IteratorNext(it);
      var done = ES.IteratorComplete(result);
      return done ? false : result;
    },

    Construct: function (C, args, newTarget, isES6internal) {
      var target = typeof newTarget === 'undefined' ? C : newTarget;

      if (!isES6internal && Reflect.construct) {
        // Try to use Reflect.construct if available
        return Reflect.construct(C, args, target);
      }
      // OK, we have to fake it.  This will only work if the
      // C.[[ConstructorKind]] == "base" -- but that's the only
      // kind we can make in ES5 code anyway.

      // OrdinaryCreateFromConstructor(target, "%ObjectPrototype%")
      var proto = target.prototype;
      if (!ES.TypeIsObject(proto)) {
        proto = Object.prototype;
      }
      var obj = create(proto);
      // Call the constructor.
      var result = ES.Call(C, obj, args);
      return ES.TypeIsObject(result) ? result : obj;
    },

    SpeciesConstructor: function (O, defaultConstructor) {
      var C = O.constructor;
      if (C === void 0) {
        return defaultConstructor;
      }
      if (!ES.TypeIsObject(C)) {
        throw new TypeError('Bad constructor');
      }
      var S = C[symbolSpecies];
      if (S === void 0 || S === null) {
        return defaultConstructor;
      }
      if (!ES.IsConstructor(S)) {
        throw new TypeError('Bad @@species');
      }
      return S;
    },

    CreateHTML: function (string, tag, attribute, value) {
      var S = ES.ToString(string);
      var p1 = '<' + tag;
      if (attribute !== '') {
        var V = ES.ToString(value);
        var escapedV = V.replace(/"/g, '&quot;');
        p1 += ' ' + attribute + '="' + escapedV + '"';
      }
      var p2 = p1 + '>';
      var p3 = p2 + S;
      return p3 + '</' + tag + '>';
    },

    IsRegExp: function IsRegExp(argument) {
      if (!ES.TypeIsObject(argument)) {
        return false;
      }
      var isRegExp = argument[Symbol.match];
      if (typeof isRegExp !== 'undefined') {
        return !!isRegExp;
      }
      return Type.regex(argument);
    },

    ToString: function ToString(string) {
      return $String(string);
    }
  };

  // Well-known Symbol shims
  if (supportsDescriptors && hasSymbols) {
    var defineWellKnownSymbol = function defineWellKnownSymbol(name) {
      if (Type.symbol(Symbol[name])) {
        return Symbol[name];
      }
      var sym = Symbol['for']('Symbol.' + name);
      Object.defineProperty(Symbol, name, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: sym
      });
      return sym;
    };
    if (!Type.symbol(Symbol.search)) {
      var symbolSearch = defineWellKnownSymbol('search');
      var originalSearch = String.prototype.search;
      defineProperty(RegExp.prototype, symbolSearch, function search(string) {
        return ES.Call(originalSearch, string, [this]);
      });
      var searchShim = function search(regexp) {
        var O = ES.RequireObjectCoercible(this);
        if (regexp !== null && typeof regexp !== 'undefined') {
          var searcher = ES.GetMethod(regexp, symbolSearch);
          if (typeof searcher !== 'undefined') {
            return ES.Call(searcher, regexp, [O]);
          }
        }
        return ES.Call(originalSearch, O, [ES.ToString(regexp)]);
      };
      overrideNative(String.prototype, 'search', searchShim);
    }
    if (!Type.symbol(Symbol.replace)) {
      var symbolReplace = defineWellKnownSymbol('replace');
      var originalReplace = String.prototype.replace;
      defineProperty(RegExp.prototype, symbolReplace, function replace(string, replaceValue) {
        return ES.Call(originalReplace, string, [this, replaceValue]);
      });
      var replaceShim = function replace(searchValue, replaceValue) {
        var O = ES.RequireObjectCoercible(this);
        if (searchValue !== null && typeof searchValue !== 'undefined') {
          var replacer = ES.GetMethod(searchValue, symbolReplace);
          if (typeof replacer !== 'undefined') {
            return ES.Call(replacer, searchValue, [O, replaceValue]);
          }
        }
        return ES.Call(originalReplace, O, [ES.ToString(searchValue), replaceValue]);
      };
      overrideNative(String.prototype, 'replace', replaceShim);
    }
    if (!Type.symbol(Symbol.split)) {
      var symbolSplit = defineWellKnownSymbol('split');
      var originalSplit = String.prototype.split;
      defineProperty(RegExp.prototype, symbolSplit, function split(string, limit) {
        return ES.Call(originalSplit, string, [this, limit]);
      });
      var splitShim = function split(separator, limit) {
        var O = ES.RequireObjectCoercible(this);
        if (separator !== null && typeof separator !== 'undefined') {
          var splitter = ES.GetMethod(separator, symbolSplit);
          if (typeof splitter !== 'undefined') {
            return ES.Call(splitter, separator, [O, limit]);
          }
        }
        return ES.Call(originalSplit, O, [ES.ToString(separator), limit]);
      };
      overrideNative(String.prototype, 'split', splitShim);
    }
    var symbolMatchExists = Type.symbol(Symbol.match);
    var stringMatchIgnoresSymbolMatch = symbolMatchExists && (function () {
      // Firefox 41, through Nightly 45 has Symbol.match, but String#match ignores it.
      // Firefox 40 and below have Symbol.match but String#match works fine.
      var o = {};
      o[Symbol.match] = function () { return 42; };
      return 'a'.match(o) !== 42;
    }());
    if (!symbolMatchExists || stringMatchIgnoresSymbolMatch) {
      var symbolMatch = defineWellKnownSymbol('match');

      var originalMatch = String.prototype.match;
      defineProperty(RegExp.prototype, symbolMatch, function match(string) {
        return ES.Call(originalMatch, string, [this]);
      });

      var matchShim = function match(regexp) {
        var O = ES.RequireObjectCoercible(this);
        if (regexp !== null && typeof regexp !== 'undefined') {
          var matcher = ES.GetMethod(regexp, symbolMatch);
          if (typeof matcher !== 'undefined') {
            return ES.Call(matcher, regexp, [O]);
          }
        }
        return ES.Call(originalMatch, O, [ES.ToString(regexp)]);
      };
      overrideNative(String.prototype, 'match', matchShim);
    }
  }

  var wrapConstructor = function wrapConstructor(original, replacement, keysToSkip) {
    Value.preserveToString(replacement, original);
    if (Object.setPrototypeOf) {
      // sets up proper prototype chain where possible
      Object.setPrototypeOf(original, replacement);
    }
    if (supportsDescriptors) {
      _forEach(Object.getOwnPropertyNames(original), function (key) {
        if (key in noop || keysToSkip[key]) { return; }
        Value.proxy(original, key, replacement);
      });
    } else {
      _forEach(Object.keys(original), function (key) {
        if (key in noop || keysToSkip[key]) { return; }
        replacement[key] = original[key];
      });
    }
    replacement.prototype = original.prototype;
    Value.redefine(original.prototype, 'constructor', replacement);
  };

  var defaultSpeciesGetter = function () { return this; };
  var addDefaultSpecies = function (C) {
    if (supportsDescriptors && !_hasOwnProperty(C, symbolSpecies)) {
      Value.getter(C, symbolSpecies, defaultSpeciesGetter);
    }
  };

  var addIterator = function (prototype, impl) {
    var implementation = impl || function iterator() { return this; };
    defineProperty(prototype, $iterator$, implementation);
    if (!prototype[$iterator$] && Type.symbol($iterator$)) {
      // implementations are buggy when $iterator$ is a Symbol
      prototype[$iterator$] = implementation;
    }
  };

  var createDataProperty = function createDataProperty(object, name, value) {
    if (supportsDescriptors) {
      Object.defineProperty(object, name, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: value
      });
    } else {
      object[name] = value;
    }
  };
  var createDataPropertyOrThrow = function createDataPropertyOrThrow(object, name, value) {
    createDataProperty(object, name, value);
    if (!ES.SameValue(object[name], value)) {
      throw new TypeError('property is nonconfigurable');
    }
  };

  var emulateES6construct = function (o, defaultNewTarget, defaultProto, slots) {
    // This is an es5 approximation to es6 construct semantics.  in es6,
    // 'new Foo' invokes Foo.[[Construct]] which (for almost all objects)
    // just sets the internal variable NewTarget (in es6 syntax `new.target`)
    // to Foo and then returns Foo().

    // Many ES6 object then have constructors of the form:
    // 1. If NewTarget is undefined, throw a TypeError exception
    // 2. Let xxx by OrdinaryCreateFromConstructor(NewTarget, yyy, zzz)

    // So we're going to emulate those first two steps.
    if (!ES.TypeIsObject(o)) {
      throw new TypeError('Constructor requires `new`: ' + defaultNewTarget.name);
    }
    var proto = defaultNewTarget.prototype;
    if (!ES.TypeIsObject(proto)) {
      proto = defaultProto;
    }
    var obj = create(proto);
    for (var name in slots) {
      if (_hasOwnProperty(slots, name)) {
        var value = slots[name];
        defineProperty(obj, name, value, true);
      }
    }
    return obj;
  };

  // Firefox 31 reports this function's length as 0
  // https://bugzilla.mozilla.org/show_bug.cgi?id=1062484
  if (String.fromCodePoint && String.fromCodePoint.length !== 1) {
    var originalFromCodePoint = String.fromCodePoint;
    overrideNative(String, 'fromCodePoint', function fromCodePoint(codePoints) {
      return ES.Call(originalFromCodePoint, this, arguments);
    });
  }

  var StringShims = {
    fromCodePoint: function fromCodePoint(codePoints) {
      var result = [];
      var next;
      for (var i = 0, length = arguments.length; i < length; i++) {
        next = Number(arguments[i]);
        if (!ES.SameValue(next, ES.ToInteger(next)) || next < 0 || next > 0x10FFFF) {
          throw new RangeError('Invalid code point ' + next);
        }

        if (next < 0x10000) {
          _push(result, String.fromCharCode(next));
        } else {
          next -= 0x10000;
          _push(result, String.fromCharCode((next >> 10) + 0xD800));
          _push(result, String.fromCharCode((next % 0x400) + 0xDC00));
        }
      }
      return result.join('');
    },

    raw: function raw(callSite) {
      var cooked = ES.ToObject(callSite, 'bad callSite');
      var rawString = ES.ToObject(cooked.raw, 'bad raw value');
      var len = rawString.length;
      var literalsegments = ES.ToLength(len);
      if (literalsegments <= 0) {
        return '';
      }

      var stringElements = [];
      var nextIndex = 0;
      var nextKey, next, nextSeg, nextSub;
      while (nextIndex < literalsegments) {
        nextKey = ES.ToString(nextIndex);
        nextSeg = ES.ToString(rawString[nextKey]);
        _push(stringElements, nextSeg);
        if (nextIndex + 1 >= literalsegments) {
          break;
        }
        next = nextIndex + 1 < arguments.length ? arguments[nextIndex + 1] : '';
        nextSub = ES.ToString(next);
        _push(stringElements, nextSub);
        nextIndex += 1;
      }
      return stringElements.join('');
    }
  };
  if (String.raw && String.raw({ raw: { 0: 'x', 1: 'y', length: 2 } }) !== 'xy') {
    // IE 11 TP has a broken String.raw implementation
    overrideNative(String, 'raw', StringShims.raw);
  }
  defineProperties(String, StringShims);

  // Fast repeat, uses the `Exponentiation by squaring` algorithm.
  // Perf: http://jsperf.com/string-repeat2/2
  var stringRepeat = function repeat(s, times) {
    if (times < 1) { return ''; }
    if (times % 2) { return repeat(s, times - 1) + s; }
    var half = repeat(s, times / 2);
    return half + half;
  };
  var stringMaxLength = Infinity;

  var StringPrototypeShims = {
    repeat: function repeat(times) {
      var thisStr = ES.ToString(ES.RequireObjectCoercible(this));
      var numTimes = ES.ToInteger(times);
      if (numTimes < 0 || numTimes >= stringMaxLength) {
        throw new RangeError('repeat count must be less than infinity and not overflow maximum string size');
      }
      return stringRepeat(thisStr, numTimes);
    },

    startsWith: function startsWith(searchString) {
      var S = ES.ToString(ES.RequireObjectCoercible(this));
      if (ES.IsRegExp(searchString)) {
        throw new TypeError('Cannot call method "startsWith" with a regex');
      }
      var searchStr = ES.ToString(searchString);
      var position;
      if (arguments.length > 1) {
        position = arguments[1];
      }
      var start = _max(ES.ToInteger(position), 0);
      return _strSlice(S, start, start + searchStr.length) === searchStr;
    },

    endsWith: function endsWith(searchString) {
      var S = ES.ToString(ES.RequireObjectCoercible(this));
      if (ES.IsRegExp(searchString)) {
        throw new TypeError('Cannot call method "endsWith" with a regex');
      }
      var searchStr = ES.ToString(searchString);
      var len = S.length;
      var endPosition;
      if (arguments.length > 1) {
        endPosition = arguments[1];
      }
      var pos = typeof endPosition === 'undefined' ? len : ES.ToInteger(endPosition);
      var end = _min(_max(pos, 0), len);
      return _strSlice(S, end - searchStr.length, end) === searchStr;
    },

    includes: function includes(searchString) {
      if (ES.IsRegExp(searchString)) {
        throw new TypeError('"includes" does not accept a RegExp');
      }
      var searchStr = ES.ToString(searchString);
      var position;
      if (arguments.length > 1) {
        position = arguments[1];
      }
      // Somehow this trick makes method 100% compat with the spec.
      return _indexOf(this, searchStr, position) !== -1;
    },

    codePointAt: function codePointAt(pos) {
      var thisStr = ES.ToString(ES.RequireObjectCoercible(this));
      var position = ES.ToInteger(pos);
      var length = thisStr.length;
      if (position >= 0 && position < length) {
        var first = thisStr.charCodeAt(position);
        var isEnd = position + 1 === length;
        if (first < 0xD800 || first > 0xDBFF || isEnd) { return first; }
        var second = thisStr.charCodeAt(position + 1);
        if (second < 0xDC00 || second > 0xDFFF) { return first; }
        return ((first - 0xD800) * 1024) + (second - 0xDC00) + 0x10000;
      }
    }
  };
  if (String.prototype.includes && 'a'.includes('a', Infinity) !== false) {
    overrideNative(String.prototype, 'includes', StringPrototypeShims.includes);
  }

  if (String.prototype.startsWith && String.prototype.endsWith) {
    var startsWithRejectsRegex = throwsError(function () {
      /* throws if spec-compliant */
      '/a/'.startsWith(/a/);
    });
    var startsWithHandlesInfinity = valueOrFalseIfThrows(function () {
      return 'abc'.startsWith('a', Infinity) === false;
    });
    if (!startsWithRejectsRegex || !startsWithHandlesInfinity) {
      // Firefox (< 37?) and IE 11 TP have a noncompliant startsWith implementation
      overrideNative(String.prototype, 'startsWith', StringPrototypeShims.startsWith);
      overrideNative(String.prototype, 'endsWith', StringPrototypeShims.endsWith);
    }
  }
  if (hasSymbols) {
    var startsWithSupportsSymbolMatch = valueOrFalseIfThrows(function () {
      var re = /a/;
      re[Symbol.match] = false;
      return '/a/'.startsWith(re);
    });
    if (!startsWithSupportsSymbolMatch) {
      overrideNative(String.prototype, 'startsWith', StringPrototypeShims.startsWith);
    }
    var endsWithSupportsSymbolMatch = valueOrFalseIfThrows(function () {
      var re = /a/;
      re[Symbol.match] = false;
      return '/a/'.endsWith(re);
    });
    if (!endsWithSupportsSymbolMatch) {
      overrideNative(String.prototype, 'endsWith', StringPrototypeShims.endsWith);
    }
    var includesSupportsSymbolMatch = valueOrFalseIfThrows(function () {
      var re = /a/;
      re[Symbol.match] = false;
      return '/a/'.includes(re);
    });
    if (!includesSupportsSymbolMatch) {
      overrideNative(String.prototype, 'includes', StringPrototypeShims.includes);
    }
  }

  defineProperties(String.prototype, StringPrototypeShims);

  // whitespace from: http://es5.github.io/#x15.5.4.20
  // implementation from https://github.com/es-shims/es5-shim/blob/v3.4.0/es5-shim.js#L1304-L1324
  var ws = [
    '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003',
    '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028',
    '\u2029\uFEFF'
  ].join('');
  var trimRegexp = new RegExp('(^[' + ws + ']+)|([' + ws + ']+$)', 'g');
  var trimShim = function trim() {
    return ES.ToString(ES.RequireObjectCoercible(this)).replace(trimRegexp, '');
  };
  var nonWS = ['\u0085', '\u200b', '\ufffe'].join('');
  var nonWSregex = new RegExp('[' + nonWS + ']', 'g');
  var isBadHexRegex = /^[\-+]0x[0-9a-f]+$/i;
  var hasStringTrimBug = nonWS.trim().length !== nonWS.length;
  defineProperty(String.prototype, 'trim', trimShim, hasStringTrimBug);

  // Given an argument x, it will return an IteratorResult object,
  // with value set to x and done to false.
  // Given no arguments, it will return an iterator completion object.
  var iteratorResult = function (x) {
    return { value: x, done: arguments.length === 0 };
  };

  // see http://www.ecma-international.org/ecma-262/6.0/#sec-string.prototype-@@iterator
  var StringIterator = function (s) {
    ES.RequireObjectCoercible(s);
    this._s = ES.ToString(s);
    this._i = 0;
  };
  StringIterator.prototype.next = function () {
    var s = this._s;
    var i = this._i;
    if (typeof s === 'undefined' || i >= s.length) {
      this._s = void 0;
      return iteratorResult();
    }
    var first = s.charCodeAt(i);
    var second, len;
    if (first < 0xD800 || first > 0xDBFF || (i + 1) === s.length) {
      len = 1;
    } else {
      second = s.charCodeAt(i + 1);
      len = (second < 0xDC00 || second > 0xDFFF) ? 1 : 2;
    }
    this._i = i + len;
    return iteratorResult(s.substr(i, len));
  };
  addIterator(StringIterator.prototype);
  addIterator(String.prototype, function () {
    return new StringIterator(this);
  });

  var ArrayShims = {
    from: function from(items) {
      var C = this;
      var mapFn;
      if (arguments.length > 1) {
        mapFn = arguments[1];
      }
      var mapping, T;
      if (typeof mapFn === 'undefined') {
        mapping = false;
      } else {
        if (!ES.IsCallable(mapFn)) {
          throw new TypeError('Array.from: when provided, the second argument must be a function');
        }
        if (arguments.length > 2) {
          T = arguments[2];
        }
        mapping = true;
      }

      // Note that that Arrays will use ArrayIterator:
      // https://bugs.ecmascript.org/show_bug.cgi?id=2416
      var usingIterator = typeof (isArguments(items) || ES.GetMethod(items, $iterator$)) !== 'undefined';

      var length, result, i;
      if (usingIterator) {
        result = ES.IsConstructor(C) ? Object(new C()) : [];
        var iterator = ES.GetIterator(items);
        var next, nextValue;

        i = 0;
        while (true) {
          next = ES.IteratorStep(iterator);
          if (next === false) {
            break;
          }
          nextValue = next.value;
          try {
            if (mapping) {
              nextValue = typeof T === 'undefined' ? mapFn(nextValue, i) : _call(mapFn, T, nextValue, i);
            }
            result[i] = nextValue;
          } catch (e) {
            ES.IteratorClose(iterator, true);
            throw e;
          }
          i += 1;
        }
        length = i;
      } else {
        var arrayLike = ES.ToObject(items);
        length = ES.ToLength(arrayLike.length);
        result = ES.IsConstructor(C) ? Object(new C(length)) : new Array(length);
        var value;
        for (i = 0; i < length; ++i) {
          value = arrayLike[i];
          if (mapping) {
            value = typeof T === 'undefined' ? mapFn(value, i) : _call(mapFn, T, value, i);
          }
          createDataPropertyOrThrow(result, i, value);
        }
      }

      result.length = length;
      return result;
    },

    of: function of() {
      var len = arguments.length;
      var C = this;
      var A = isArray(C) || !ES.IsCallable(C) ? new Array(len) : ES.Construct(C, [len]);
      for (var k = 0; k < len; ++k) {
        createDataPropertyOrThrow(A, k, arguments[k]);
      }
      A.length = len;
      return A;
    }
  };
  defineProperties(Array, ArrayShims);
  addDefaultSpecies(Array);

  // Our ArrayIterator is private; see
  // https://github.com/paulmillr/es6-shim/issues/252
  ArrayIterator = function (array, kind) {
    this.i = 0;
    this.array = array;
    this.kind = kind;
  };

  defineProperties(ArrayIterator.prototype, {
    next: function () {
      var i = this.i;
      var array = this.array;
      if (!(this instanceof ArrayIterator)) {
        throw new TypeError('Not an ArrayIterator');
      }
      if (typeof array !== 'undefined') {
        var len = ES.ToLength(array.length);
        for (; i < len; i++) {
          var kind = this.kind;
          var retval;
          if (kind === 'key') {
            retval = i;
          } else if (kind === 'value') {
            retval = array[i];
          } else if (kind === 'entry') {
            retval = [i, array[i]];
          }
          this.i = i + 1;
          return iteratorResult(retval);
        }
      }
      this.array = void 0;
      return iteratorResult();
    }
  });
  addIterator(ArrayIterator.prototype);

/*
  var orderKeys = function orderKeys(a, b) {
    var aNumeric = String(ES.ToInteger(a)) === a;
    var bNumeric = String(ES.ToInteger(b)) === b;
    if (aNumeric && bNumeric) {
      return b - a;
    } else if (aNumeric && !bNumeric) {
      return -1;
    } else if (!aNumeric && bNumeric) {
      return 1;
    } else {
      return a.localeCompare(b);
    }
  };

  var getAllKeys = function getAllKeys(object) {
    var ownKeys = [];
    var keys = [];

    for (var key in object) {
      _push(_hasOwnProperty(object, key) ? ownKeys : keys, key);
    }
    _sort(ownKeys, orderKeys);
    _sort(keys, orderKeys);

    return _concat(ownKeys, keys);
  };
  */

  // note: this is positioned here because it depends on ArrayIterator
  var arrayOfSupportsSubclassing = Array.of === ArrayShims.of || (function () {
    // Detects a bug in Webkit nightly r181886
    var Foo = function Foo(len) { this.length = len; };
    Foo.prototype = [];
    var fooArr = Array.of.apply(Foo, [1, 2]);
    return fooArr instanceof Foo && fooArr.length === 2;
  }());
  if (!arrayOfSupportsSubclassing) {
    overrideNative(Array, 'of', ArrayShims.of);
  }

  var ArrayPrototypeShims = {
    copyWithin: function copyWithin(target, start) {
      var o = ES.ToObject(this);
      var len = ES.ToLength(o.length);
      var relativeTarget = ES.ToInteger(target);
      var relativeStart = ES.ToInteger(start);
      var to = relativeTarget < 0 ? _max(len + relativeTarget, 0) : _min(relativeTarget, len);
      var from = relativeStart < 0 ? _max(len + relativeStart, 0) : _min(relativeStart, len);
      var end;
      if (arguments.length > 2) {
        end = arguments[2];
      }
      var relativeEnd = typeof end === 'undefined' ? len : ES.ToInteger(end);
      var finalItem = relativeEnd < 0 ? _max(len + relativeEnd, 0) : _min(relativeEnd, len);
      var count = _min(finalItem - from, len - to);
      var direction = 1;
      if (from < to && to < (from + count)) {
        direction = -1;
        from += count - 1;
        to += count - 1;
      }
      while (count > 0) {
        if (from in o) {
          o[to] = o[from];
        } else {
          delete o[to];
        }
        from += direction;
        to += direction;
        count -= 1;
      }
      return o;
    },

    fill: function fill(value) {
      var start;
      if (arguments.length > 1) {
        start = arguments[1];
      }
      var end;
      if (arguments.length > 2) {
        end = arguments[2];
      }
      var O = ES.ToObject(this);
      var len = ES.ToLength(O.length);
      start = ES.ToInteger(typeof start === 'undefined' ? 0 : start);
      end = ES.ToInteger(typeof end === 'undefined' ? len : end);

      var relativeStart = start < 0 ? _max(len + start, 0) : _min(start, len);
      var relativeEnd = end < 0 ? len + end : end;

      for (var i = relativeStart; i < len && i < relativeEnd; ++i) {
        O[i] = value;
      }
      return O;
    },

    find: function find(predicate) {
      var list = ES.ToObject(this);
      var length = ES.ToLength(list.length);
      if (!ES.IsCallable(predicate)) {
        throw new TypeError('Array#find: predicate must be a function');
      }
      var thisArg = arguments.length > 1 ? arguments[1] : null;
      for (var i = 0, value; i < length; i++) {
        value = list[i];
        if (thisArg) {
          if (_call(predicate, thisArg, value, i, list)) {
            return value;
          }
        } else if (predicate(value, i, list)) {
          return value;
        }
      }
    },

    findIndex: function findIndex(predicate) {
      var list = ES.ToObject(this);
      var length = ES.ToLength(list.length);
      if (!ES.IsCallable(predicate)) {
        throw new TypeError('Array#findIndex: predicate must be a function');
      }
      var thisArg = arguments.length > 1 ? arguments[1] : null;
      for (var i = 0; i < length; i++) {
        if (thisArg) {
          if (_call(predicate, thisArg, list[i], i, list)) {
            return i;
          }
        } else if (predicate(list[i], i, list)) {
          return i;
        }
      }
      return -1;
    },

    keys: function keys() {
      return new ArrayIterator(this, 'key');
    },

    values: function values() {
      return new ArrayIterator(this, 'value');
    },

    entries: function entries() {
      return new ArrayIterator(this, 'entry');
    }
  };
  // Safari 7.1 defines Array#keys and Array#entries natively,
  // but the resulting ArrayIterator objects don't have a "next" method.
  if (Array.prototype.keys && !ES.IsCallable([1].keys().next)) {
    delete Array.prototype.keys;
  }
  if (Array.prototype.entries && !ES.IsCallable([1].entries().next)) {
    delete Array.prototype.entries;
  }

  // Chrome 38 defines Array#keys and Array#entries, and Array#@@iterator, but not Array#values
  if (Array.prototype.keys && Array.prototype.entries && !Array.prototype.values && Array.prototype[$iterator$]) {
    defineProperties(Array.prototype, {
      values: Array.prototype[$iterator$]
    });
    if (Type.symbol(Symbol.unscopables)) {
      Array.prototype[Symbol.unscopables].values = true;
    }
  }
  // Chrome 40 defines Array#values with the incorrect name, although Array#{keys,entries} have the correct name
  if (functionsHaveNames && Array.prototype.values && Array.prototype.values.name !== 'values') {
    var originalArrayPrototypeValues = Array.prototype.values;
    overrideNative(Array.prototype, 'values', function values() { return ES.Call(originalArrayPrototypeValues, this, arguments); });
    defineProperty(Array.prototype, $iterator$, Array.prototype.values, true);
  }
  defineProperties(Array.prototype, ArrayPrototypeShims);

  if (1 / [true].indexOf(true, -0) < 0) {
    // indexOf when given a position arg of -0 should return +0.
    // https://github.com/tc39/ecma262/pull/316
    defineProperty(Array.prototype, 'indexOf', function indexOf(searchElement) {
      var value = _arrayIndexOfApply(this, arguments);
      if (value === 0 && (1 / value) < 0) {
        return 0;
      }
      return value;
    }, true);
  }

  addIterator(Array.prototype, function () { return this.values(); });
  // Chrome defines keys/values/entries on Array, but doesn't give us
  // any way to identify its iterator.  So add our own shimmed field.
  if (Object.getPrototypeOf) {
    addIterator(Object.getPrototypeOf([].values()));
  }

  // note: this is positioned here because it relies on Array#entries
  var arrayFromSwallowsNegativeLengths = (function () {
    // Detects a Firefox bug in v32
    // https://bugzilla.mozilla.org/show_bug.cgi?id=1063993
    return valueOrFalseIfThrows(function () {
      return Array.from({ length: -1 }).length === 0;
    });
  }());
  var arrayFromHandlesIterables = (function () {
    // Detects a bug in Webkit nightly r181886
    var arr = Array.from([0].entries());
    return arr.length === 1 && isArray(arr[0]) && arr[0][0] === 0 && arr[0][1] === 0;
  }());
  if (!arrayFromSwallowsNegativeLengths || !arrayFromHandlesIterables) {
    overrideNative(Array, 'from', ArrayShims.from);
  }
  var arrayFromHandlesUndefinedMapFunction = (function () {
    // Microsoft Edge v0.11 throws if the mapFn argument is *provided* but undefined,
    // but the spec doesn't care if it's provided or not - undefined doesn't throw.
    return valueOrFalseIfThrows(function () {
      return Array.from([0], void 0);
    });
  }());
  if (!arrayFromHandlesUndefinedMapFunction) {
    var origArrayFrom = Array.from;
    overrideNative(Array, 'from', function from(items) {
      if (arguments.length > 1 && typeof arguments[1] !== 'undefined') {
        return ES.Call(origArrayFrom, this, arguments);
      } else {
        return _call(origArrayFrom, this, items);
      }
    });
  }

  var int32sAsOne = -(Math.pow(2, 32) - 1);
  var toLengthsCorrectly = function (method, reversed) {
    var obj = { length: int32sAsOne };
    obj[reversed ? (obj.length >>> 0) - 1 : 0] = true;
    return valueOrFalseIfThrows(function () {
      _call(method, obj, function () {
        // note: in nonconforming browsers, this will be called
        // -1 >>> 0 times, which is 4294967295, so the throw matters.
        throw new RangeError('should not reach here');
      }, []);
      return true;
    });
  };
  if (!toLengthsCorrectly(Array.prototype.forEach)) {
    var originalForEach = Array.prototype.forEach;
    overrideNative(Array.prototype, 'forEach', function forEach(callbackFn) {
      return ES.Call(originalForEach, this.length >= 0 ? this : [], arguments);
    }, true);
  }
  if (!toLengthsCorrectly(Array.prototype.map)) {
    var originalMap = Array.prototype.map;
    overrideNative(Array.prototype, 'map', function map(callbackFn) {
      return ES.Call(originalMap, this.length >= 0 ? this : [], arguments);
    }, true);
  }
  if (!toLengthsCorrectly(Array.prototype.filter)) {
    var originalFilter = Array.prototype.filter;
    overrideNative(Array.prototype, 'filter', function filter(callbackFn) {
      return ES.Call(originalFilter, this.length >= 0 ? this : [], arguments);
    }, true);
  }
  if (!toLengthsCorrectly(Array.prototype.some)) {
    var originalSome = Array.prototype.some;
    overrideNative(Array.prototype, 'some', function some(callbackFn) {
      return ES.Call(originalSome, this.length >= 0 ? this : [], arguments);
    }, true);
  }
  if (!toLengthsCorrectly(Array.prototype.every)) {
    var originalEvery = Array.prototype.every;
    overrideNative(Array.prototype, 'every', function every(callbackFn) {
      return ES.Call(originalEvery, this.length >= 0 ? this : [], arguments);
    }, true);
  }
  if (!toLengthsCorrectly(Array.prototype.reduce)) {
    var originalReduce = Array.prototype.reduce;
    overrideNative(Array.prototype, 'reduce', function reduce(callbackFn) {
      return ES.Call(originalReduce, this.length >= 0 ? this : [], arguments);
    }, true);
  }
  if (!toLengthsCorrectly(Array.prototype.reduceRight, true)) {
    var originalReduceRight = Array.prototype.reduceRight;
    overrideNative(Array.prototype, 'reduceRight', function reduceRight(callbackFn) {
      return ES.Call(originalReduceRight, this.length >= 0 ? this : [], arguments);
    }, true);
  }

  var lacksOctalSupport = Number('0o10') !== 8;
  var lacksBinarySupport = Number('0b10') !== 2;
  var trimsNonWhitespace = _some(nonWS, function (c) {
    return Number(c + 0 + c) === 0;
  });
  if (lacksOctalSupport || lacksBinarySupport || trimsNonWhitespace) {
    var OrigNumber = Number;
    var binaryRegex = /^0b[01]+$/i;
    var octalRegex = /^0o[0-7]+$/i;
    // Note that in IE 8, RegExp.prototype.test doesn't seem to exist: ie, "test" is an own property of regexes. wtf.
    var isBinary = binaryRegex.test.bind(binaryRegex);
    var isOctal = octalRegex.test.bind(octalRegex);
    var toPrimitive = function (O) { // need to replace this with `es-to-primitive/es6`
      var result;
      if (typeof O.valueOf === 'function') {
        result = O.valueOf();
        if (Type.primitive(result)) {
          return result;
        }
      }
      if (typeof O.toString === 'function') {
        result = O.toString();
        if (Type.primitive(result)) {
          return result;
        }
      }
      throw new TypeError('No default value');
    };
    var hasNonWS = nonWSregex.test.bind(nonWSregex);
    var isBadHex = isBadHexRegex.test.bind(isBadHexRegex);
    var NumberShim = (function () {
      // this is wrapped in an IIFE because of IE 6-8's wacky scoping issues with named function expressions.
      var NumberShim = function Number(value) {
        var primValue;
        if (arguments.length > 0) {
          primValue = Type.primitive(value) ? value : toPrimitive(value, 'number');
        } else {
          primValue = 0;
        }
        if (typeof primValue === 'string') {
          primValue = ES.Call(trimShim, primValue);
          if (isBinary(primValue)) {
            primValue = parseInt(_strSlice(primValue, 2), 2);
          } else if (isOctal(primValue)) {
            primValue = parseInt(_strSlice(primValue, 2), 8);
          } else if (hasNonWS(primValue) || isBadHex(primValue)) {
            primValue = NaN;
          }
        }
        var receiver = this;
        var valueOfSucceeds = valueOrFalseIfThrows(function () {
          OrigNumber.prototype.valueOf.call(receiver);
          return true;
        });
        if (receiver instanceof NumberShim && !valueOfSucceeds) {
          return new OrigNumber(primValue);
        }
        /* jshint newcap: false */
        return OrigNumber(primValue);
        /* jshint newcap: true */
      };
      return NumberShim;
    }());
    wrapConstructor(OrigNumber, NumberShim, {});
    // this is necessary for ES3 browsers, where these properties are non-enumerable.
    defineProperties(NumberShim, {
      NaN: OrigNumber.NaN,
      MAX_VALUE: OrigNumber.MAX_VALUE,
      MIN_VALUE: OrigNumber.MIN_VALUE,
      NEGATIVE_INFINITY: OrigNumber.NEGATIVE_INFINITY,
      POSITIVE_INFINITY: OrigNumber.POSITIVE_INFINITY
    });
    /* globals Number: true */
    /* eslint-disable no-undef */
    /* jshint -W020 */
    Number = NumberShim;
    Value.redefine(globals, 'Number', NumberShim);
    /* jshint +W020 */
    /* eslint-enable no-undef */
    /* globals Number: false */
  }

  var maxSafeInteger = Math.pow(2, 53) - 1;
  defineProperties(Number, {
    MAX_SAFE_INTEGER: maxSafeInteger,
    MIN_SAFE_INTEGER: -maxSafeInteger,
    EPSILON: 2.220446049250313e-16,

    parseInt: globals.parseInt,
    parseFloat: globals.parseFloat,

    isFinite: numberIsFinite,

    isInteger: function isInteger(value) {
      return numberIsFinite(value) && ES.ToInteger(value) === value;
    },

    isSafeInteger: function isSafeInteger(value) {
      return Number.isInteger(value) && _abs(value) <= Number.MAX_SAFE_INTEGER;
    },

    isNaN: numberIsNaN
  });
  // Firefox 37 has a conforming Number.parseInt, but it's not === to the global parseInt (fixed in v40)
  defineProperty(Number, 'parseInt', globals.parseInt, Number.parseInt !== globals.parseInt);

  // Work around bugs in Array#find and Array#findIndex -- early
  // implementations skipped holes in sparse arrays. (Note that the
  // implementations of find/findIndex indirectly use shimmed
  // methods of Number, so this test has to happen down here.)
  /*jshint elision: true */
  /* eslint-disable no-sparse-arrays */
  if (![, 1].find(function (item, idx) { return idx === 0; })) {
    overrideNative(Array.prototype, 'find', ArrayPrototypeShims.find);
  }
  if ([, 1].findIndex(function (item, idx) { return idx === 0; }) !== 0) {
    overrideNative(Array.prototype, 'findIndex', ArrayPrototypeShims.findIndex);
  }
  /* eslint-enable no-sparse-arrays */
  /*jshint elision: false */

  var isEnumerableOn = Function.bind.call(Function.bind, Object.prototype.propertyIsEnumerable);
  var ensureEnumerable = function ensureEnumerable(obj, prop) {
    if (supportsDescriptors && isEnumerableOn(obj, prop)) {
      Object.defineProperty(obj, prop, { enumerable: false });
    }
  };
  var sliceArgs = function sliceArgs() {
    // per https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments
    // and https://gist.github.com/WebReflection/4327762cb87a8c634a29
    var initial = Number(this);
    var len = arguments.length;
    var desiredArgCount = len - initial;
    var args = new Array(desiredArgCount < 0 ? 0 : desiredArgCount);
    for (var i = initial; i < len; ++i) {
      args[i - initial] = arguments[i];
    }
    return args;
  };
  var assignTo = function assignTo(source) {
    return function assignToSource(target, key) {
      target[key] = source[key];
      return target;
    };
  };
  var assignReducer = function (target, source) {
    var sourceKeys = keys(Object(source));
    var symbols;
    if (ES.IsCallable(Object.getOwnPropertySymbols)) {
      symbols = _filter(Object.getOwnPropertySymbols(Object(source)), isEnumerableOn(source));
    }
    return _reduce(_concat(sourceKeys, symbols || []), assignTo(source), target);
  };

  var ObjectShims = {
    // 19.1.3.1
    assign: function (target, source) {
      var to = ES.ToObject(target, 'Cannot convert undefined or null to object');
      return _reduce(ES.Call(sliceArgs, 1, arguments), assignReducer, to);
    },

    // Added in WebKit in https://bugs.webkit.org/show_bug.cgi?id=143865
    is: function is(a, b) {
      return ES.SameValue(a, b);
    }
  };
  var assignHasPendingExceptions = Object.assign && Object.preventExtensions && (function () {
    // Firefox 37 still has "pending exception" logic in its Object.assign implementation,
    // which is 72% slower than our shim, and Firefox 40's native implementation.
    var thrower = Object.preventExtensions({ 1: 2 });
    try {
      Object.assign(thrower, 'xy');
    } catch (e) {
      return thrower[1] === 'y';
    }
  }());
  if (assignHasPendingExceptions) {
    overrideNative(Object, 'assign', ObjectShims.assign);
  }
  defineProperties(Object, ObjectShims);

  if (supportsDescriptors) {
    var ES5ObjectShims = {
      // 19.1.3.9
      // shim from https://gist.github.com/WebReflection/5593554
      setPrototypeOf: (function (Object, magic) {
        var set;

        var checkArgs = function (O, proto) {
          if (!ES.TypeIsObject(O)) {
            throw new TypeError('cannot set prototype on a non-object');
          }
          if (!(proto === null || ES.TypeIsObject(proto))) {
            throw new TypeError('can only set prototype to an object or null' + proto);
          }
        };

        var setPrototypeOf = function (O, proto) {
          checkArgs(O, proto);
          _call(set, O, proto);
          return O;
        };

        try {
          // this works already in Firefox and Safari
          set = Object.getOwnPropertyDescriptor(Object.prototype, magic).set;
          _call(set, {}, null);
        } catch (e) {
          if (Object.prototype !== {}[magic]) {
            // IE < 11 cannot be shimmed
            return;
          }
          // probably Chrome or some old Mobile stock browser
          set = function (proto) {
            this[magic] = proto;
          };
          // please note that this will **not** work
          // in those browsers that do not inherit
          // __proto__ by mistake from Object.prototype
          // in these cases we should probably throw an error
          // or at least be informed about the issue
          setPrototypeOf.polyfill = setPrototypeOf(
            setPrototypeOf({}, null),
            Object.prototype
          ) instanceof Object;
          // setPrototypeOf.polyfill === true means it works as meant
          // setPrototypeOf.polyfill === false means it's not 100% reliable
          // setPrototypeOf.polyfill === undefined
          // or
          // setPrototypeOf.polyfill ==  null means it's not a polyfill
          // which means it works as expected
          // we can even delete Object.prototype.__proto__;
        }
        return setPrototypeOf;
      }(Object, '__proto__'))
    };

    defineProperties(Object, ES5ObjectShims);
  }

  // Workaround bug in Opera 12 where setPrototypeOf(x, null) doesn't work,
  // but Object.create(null) does.
  if (Object.setPrototypeOf && Object.getPrototypeOf &&
      Object.getPrototypeOf(Object.setPrototypeOf({}, null)) !== null &&
      Object.getPrototypeOf(Object.create(null)) === null) {
    (function () {
      var FAKENULL = Object.create(null);
      var gpo = Object.getPrototypeOf;
      var spo = Object.setPrototypeOf;
      Object.getPrototypeOf = function (o) {
        var result = gpo(o);
        return result === FAKENULL ? null : result;
      };
      Object.setPrototypeOf = function (o, p) {
        var proto = p === null ? FAKENULL : p;
        return spo(o, proto);
      };
      Object.setPrototypeOf.polyfill = false;
    }());
  }

  var objectKeysAcceptsPrimitives = !throwsError(function () { Object.keys('foo'); });
  if (!objectKeysAcceptsPrimitives) {
    var originalObjectKeys = Object.keys;
    overrideNative(Object, 'keys', function keys(value) {
      return originalObjectKeys(ES.ToObject(value));
    });
    keys = Object.keys;
  }
  var objectKeysRejectsRegex = throwsError(function () { Object.keys(/a/g); });
  if (objectKeysRejectsRegex) {
    var regexRejectingObjectKeys = Object.keys;
    overrideNative(Object, 'keys', function keys(value) {
      if (Type.regex(value)) {
        var regexKeys = [];
        for (var k in value) {
          if (_hasOwnProperty(value, k)) {
            _push(regexKeys, k);
          }
        }
        return regexKeys;
      }
      return regexRejectingObjectKeys(value);
    });
    keys = Object.keys;
  }

  if (Object.getOwnPropertyNames) {
    var objectGOPNAcceptsPrimitives = !throwsError(function () { Object.getOwnPropertyNames('foo'); });
    if (!objectGOPNAcceptsPrimitives) {
      var cachedWindowNames = typeof window === 'object' ? Object.getOwnPropertyNames(window) : [];
      var originalObjectGetOwnPropertyNames = Object.getOwnPropertyNames;
      overrideNative(Object, 'getOwnPropertyNames', function getOwnPropertyNames(value) {
        var val = ES.ToObject(value);
        if (_toString(val) === '[object Window]') {
          try {
            return originalObjectGetOwnPropertyNames(val);
          } catch (e) {
            // IE bug where layout engine calls userland gOPN for cross-domain `window` objects
            return _concat([], cachedWindowNames);
          }
        }
        return originalObjectGetOwnPropertyNames(val);
      });
    }
  }
  if (Object.getOwnPropertyDescriptor) {
    var objectGOPDAcceptsPrimitives = !throwsError(function () { Object.getOwnPropertyDescriptor('foo', 'bar'); });
    if (!objectGOPDAcceptsPrimitives) {
      var originalObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      overrideNative(Object, 'getOwnPropertyDescriptor', function getOwnPropertyDescriptor(value, property) {
        return originalObjectGetOwnPropertyDescriptor(ES.ToObject(value), property);
      });
    }
  }
  if (Object.seal) {
    var objectSealAcceptsPrimitives = !throwsError(function () { Object.seal('foo'); });
    if (!objectSealAcceptsPrimitives) {
      var originalObjectSeal = Object.seal;
      overrideNative(Object, 'seal', function seal(value) {
        if (!ES.TypeIsObject(value)) { return value; }
        return originalObjectSeal(value);
      });
    }
  }
  if (Object.isSealed) {
    var objectIsSealedAcceptsPrimitives = !throwsError(function () { Object.isSealed('foo'); });
    if (!objectIsSealedAcceptsPrimitives) {
      var originalObjectIsSealed = Object.isSealed;
      overrideNative(Object, 'isSealed', function isSealed(value) {
        if (!ES.TypeIsObject(value)) { return true; }
        return originalObjectIsSealed(value);
      });
    }
  }
  if (Object.freeze) {
    var objectFreezeAcceptsPrimitives = !throwsError(function () { Object.freeze('foo'); });
    if (!objectFreezeAcceptsPrimitives) {
      var originalObjectFreeze = Object.freeze;
      overrideNative(Object, 'freeze', function freeze(value) {
        if (!ES.TypeIsObject(value)) { return value; }
        return originalObjectFreeze(value);
      });
    }
  }
  if (Object.isFrozen) {
    var objectIsFrozenAcceptsPrimitives = !throwsError(function () { Object.isFrozen('foo'); });
    if (!objectIsFrozenAcceptsPrimitives) {
      var originalObjectIsFrozen = Object.isFrozen;
      overrideNative(Object, 'isFrozen', function isFrozen(value) {
        if (!ES.TypeIsObject(value)) { return true; }
        return originalObjectIsFrozen(value);
      });
    }
  }
  if (Object.preventExtensions) {
    var objectPreventExtensionsAcceptsPrimitives = !throwsError(function () { Object.preventExtensions('foo'); });
    if (!objectPreventExtensionsAcceptsPrimitives) {
      var originalObjectPreventExtensions = Object.preventExtensions;
      overrideNative(Object, 'preventExtensions', function preventExtensions(value) {
        if (!ES.TypeIsObject(value)) { return value; }
        return originalObjectPreventExtensions(value);
      });
    }
  }
  if (Object.isExtensible) {
    var objectIsExtensibleAcceptsPrimitives = !throwsError(function () { Object.isExtensible('foo'); });
    if (!objectIsExtensibleAcceptsPrimitives) {
      var originalObjectIsExtensible = Object.isExtensible;
      overrideNative(Object, 'isExtensible', function isExtensible(value) {
        if (!ES.TypeIsObject(value)) { return false; }
        return originalObjectIsExtensible(value);
      });
    }
  }
  if (Object.getPrototypeOf) {
    var objectGetProtoAcceptsPrimitives = !throwsError(function () { Object.getPrototypeOf('foo'); });
    if (!objectGetProtoAcceptsPrimitives) {
      var originalGetProto = Object.getPrototypeOf;
      overrideNative(Object, 'getPrototypeOf', function getPrototypeOf(value) {
        return originalGetProto(ES.ToObject(value));
      });
    }
  }

  var hasFlags = supportsDescriptors && (function () {
    var desc = Object.getOwnPropertyDescriptor(RegExp.prototype, 'flags');
    return desc && ES.IsCallable(desc.get);
  }());
  if (supportsDescriptors && !hasFlags) {
    var regExpFlagsGetter = function flags() {
      if (!ES.TypeIsObject(this)) {
        throw new TypeError('Method called on incompatible type: must be an object.');
      }
      var result = '';
      if (this.global) {
        result += 'g';
      }
      if (this.ignoreCase) {
        result += 'i';
      }
      if (this.multiline) {
        result += 'm';
      }
      if (this.unicode) {
        result += 'u';
      }
      if (this.sticky) {
        result += 'y';
      }
      return result;
    };

    Value.getter(RegExp.prototype, 'flags', regExpFlagsGetter);
  }

  var regExpSupportsFlagsWithRegex = supportsDescriptors && valueOrFalseIfThrows(function () {
    return String(new RegExp(/a/g, 'i')) === '/a/i';
  });
  var regExpNeedsToSupportSymbolMatch = hasSymbols && supportsDescriptors && (function () {
    // Edge 0.12 supports flags fully, but does not support Symbol.match
    var regex = /./;
    regex[Symbol.match] = false;
    return RegExp(regex) === regex;
  }());

  var regexToStringIsGeneric = valueOrFalseIfThrows(function () {
    return RegExp.prototype.toString.call({ source: 'abc' }) === '/abc/';
  });
  var regexToStringSupportsGenericFlags = regexToStringIsGeneric && valueOrFalseIfThrows(function () {
    return RegExp.prototype.toString.call({ source: 'a', flags: 'b' }) === '/a/b';
  });
  if (!regexToStringIsGeneric || !regexToStringSupportsGenericFlags) {
    var origRegExpToString = RegExp.prototype.toString;
    defineProperty(RegExp.prototype, 'toString', function toString() {
      var R = ES.RequireObjectCoercible(this);
      if (Type.regex(R)) {
        return _call(origRegExpToString, R);
      }
      var pattern = $String(R.source);
      var flags = $String(R.flags);
      return '/' + pattern + '/' + flags;
    }, true);
    Value.preserveToString(RegExp.prototype.toString, origRegExpToString);
  }

  if (supportsDescriptors && (!regExpSupportsFlagsWithRegex || regExpNeedsToSupportSymbolMatch)) {
    var flagsGetter = Object.getOwnPropertyDescriptor(RegExp.prototype, 'flags').get;
    var sourceDesc = Object.getOwnPropertyDescriptor(RegExp.prototype, 'source') || {};
    var legacySourceGetter = function () { return this.source; }; // prior to it being a getter, it's own + nonconfigurable
    var sourceGetter = ES.IsCallable(sourceDesc.get) ? sourceDesc.get : legacySourceGetter;

    var OrigRegExp = RegExp;
    var RegExpShim = (function () {
      return function RegExp(pattern, flags) {
        var patternIsRegExp = ES.IsRegExp(pattern);
        var calledWithNew = this instanceof RegExp;
        if (!calledWithNew && patternIsRegExp && typeof flags === 'undefined' && pattern.constructor === RegExp) {
          return pattern;
        }

        var P = pattern;
        var F = flags;
        if (Type.regex(pattern)) {
          P = ES.Call(sourceGetter, pattern);
          F = typeof flags === 'undefined' ? ES.Call(flagsGetter, pattern) : flags;
          return new RegExp(P, F);
        } else if (patternIsRegExp) {
          P = pattern.source;
          F = typeof flags === 'undefined' ? pattern.flags : flags;
        }
        return new OrigRegExp(pattern, flags);
      };
    }());
    wrapConstructor(OrigRegExp, RegExpShim, {
      $input: true // Chrome < v39 & Opera < 26 have a nonstandard "$input" property
    });
    /* globals RegExp: true */
    /* eslint-disable no-undef */
    /* jshint -W020 */
    RegExp = RegExpShim;
    Value.redefine(globals, 'RegExp', RegExpShim);
    /* jshint +W020 */
    /* eslint-enable no-undef */
    /* globals RegExp: false */
  }

  if (supportsDescriptors) {
    var regexGlobals = {
      input: '$_',
      lastMatch: '$&',
      lastParen: '$+',
      leftContext: '$`',
      rightContext: '$\''
    };
    _forEach(keys(regexGlobals), function (prop) {
      if (prop in RegExp && !(regexGlobals[prop] in RegExp)) {
        Value.getter(RegExp, regexGlobals[prop], function get() {
          return RegExp[prop];
        });
      }
    });
  }
  addDefaultSpecies(RegExp);

  var inverseEpsilon = 1 / Number.EPSILON;
  var roundTiesToEven = function roundTiesToEven(n) {
    // Even though this reduces down to `return n`, it takes advantage of built-in rounding.
    return (n + inverseEpsilon) - inverseEpsilon;
  };
  var BINARY_32_EPSILON = Math.pow(2, -23);
  var BINARY_32_MAX_VALUE = Math.pow(2, 127) * (2 - BINARY_32_EPSILON);
  var BINARY_32_MIN_VALUE = Math.pow(2, -126);
  var E = Math.E;
  var LOG2E = Math.LOG2E;
  var LOG10E = Math.LOG10E;
  var numberCLZ = Number.prototype.clz;
  delete Number.prototype.clz; // Safari 8 has Number#clz

  var MathShims = {
    acosh: function acosh(value) {
      var x = Number(value);
      if (numberIsNaN(x) || value < 1) { return NaN; }
      if (x === 1) { return 0; }
      if (x === Infinity) { return x; }
      return _log(x / E + _sqrt(x + 1) * _sqrt(x - 1) / E) + 1;
    },

    asinh: function asinh(value) {
      var x = Number(value);
      if (x === 0 || !globalIsFinite(x)) {
        return x;
      }
      return x < 0 ? -asinh(-x) : _log(x + _sqrt(x * x + 1));
    },

    atanh: function atanh(value) {
      var x = Number(value);
      if (numberIsNaN(x) || x < -1 || x > 1) {
        return NaN;
      }
      if (x === -1) { return -Infinity; }
      if (x === 1) { return Infinity; }
      if (x === 0) { return x; }
      return 0.5 * _log((1 + x) / (1 - x));
    },

    cbrt: function cbrt(value) {
      var x = Number(value);
      if (x === 0) { return x; }
      var negate = x < 0;
      var result;
      if (negate) { x = -x; }
      if (x === Infinity) {
        result = Infinity;
      } else {
        result = _exp(_log(x) / 3);
        // from http://en.wikipedia.org/wiki/Cube_root#Numerical_methods
        result = (x / (result * result) + (2 * result)) / 3;
      }
      return negate ? -result : result;
    },

    clz32: function clz32(value) {
      // See https://bugs.ecmascript.org/show_bug.cgi?id=2465
      var x = Number(value);
      var number = ES.ToUint32(x);
      if (number === 0) {
        return 32;
      }
      return numberCLZ ? ES.Call(numberCLZ, number) : 31 - _floor(_log(number + 0.5) * LOG2E);
    },

    cosh: function cosh(value) {
      var x = Number(value);
      if (x === 0) { return 1; } // +0 or -0
      if (numberIsNaN(x)) { return NaN; }
      if (!globalIsFinite(x)) { return Infinity; }
      if (x < 0) { x = -x; }
      if (x > 21) { return _exp(x) / 2; }
      return (_exp(x) + _exp(-x)) / 2;
    },

    expm1: function expm1(value) {
      var x = Number(value);
      if (x === -Infinity) { return -1; }
      if (!globalIsFinite(x) || x === 0) { return x; }
      if (_abs(x) > 0.5) {
        return _exp(x) - 1;
      }
      // A more precise approximation using Taylor series expansion
      // from https://github.com/paulmillr/es6-shim/issues/314#issuecomment-70293986
      var t = x;
      var sum = 0;
      var n = 1;
      while (sum + t !== sum) {
        sum += t;
        n += 1;
        t *= x / n;
      }
      return sum;
    },

    hypot: function hypot(x, y) {
      var result = 0;
      var largest = 0;
      for (var i = 0; i < arguments.length; ++i) {
        var value = _abs(Number(arguments[i]));
        if (largest < value) {
          result *= (largest / value) * (largest / value);
          result += 1;
          largest = value;
        } else {
          result += value > 0 ? (value / largest) * (value / largest) : value;
        }
      }
      return largest === Infinity ? Infinity : largest * _sqrt(result);
    },

    log2: function log2(value) {
      return _log(value) * LOG2E;
    },

    log10: function log10(value) {
      return _log(value) * LOG10E;
    },

    log1p: function log1p(value) {
      var x = Number(value);
      if (x < -1 || numberIsNaN(x)) { return NaN; }
      if (x === 0 || x === Infinity) { return x; }
      if (x === -1) { return -Infinity; }

      return (1 + x) - 1 === 0 ? x : x * (_log(1 + x) / ((1 + x) - 1));
    },

    sign: _sign,

    sinh: function sinh(value) {
      var x = Number(value);
      if (!globalIsFinite(x) || x === 0) { return x; }

      if (_abs(x) < 1) {
        return (Math.expm1(x) - Math.expm1(-x)) / 2;
      }
      return (_exp(x - 1) - _exp(-x - 1)) * E / 2;
    },

    tanh: function tanh(value) {
      var x = Number(value);
      if (numberIsNaN(x) || x === 0) { return x; }
      // can exit early at +-20 as JS loses precision for true value at this integer
      if (x >= 20) { return 1; }
      if (x <= -20) { return -1; }

      return (Math.expm1(x) - Math.expm1(-x)) / (_exp(x) + _exp(-x));
    },

    trunc: function trunc(value) {
      var x = Number(value);
      return x < 0 ? -_floor(-x) : _floor(x);
    },

    imul: function imul(x, y) {
      // taken from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul
      var a = ES.ToUint32(x);
      var b = ES.ToUint32(y);
      var ah = (a >>> 16) & 0xffff;
      var al = a & 0xffff;
      var bh = (b >>> 16) & 0xffff;
      var bl = b & 0xffff;
      // the shift by 0 fixes the sign on the high part
      // the final |0 converts the unsigned value into a signed value
      return (al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0;
    },

    fround: function fround(x) {
      var v = Number(x);
      if (v === 0 || v === Infinity || v === -Infinity || numberIsNaN(v)) {
        return v;
      }
      var sign = _sign(v);
      var abs = _abs(v);
      if (abs < BINARY_32_MIN_VALUE) {
        return sign * roundTiesToEven(abs / BINARY_32_MIN_VALUE / BINARY_32_EPSILON) * BINARY_32_MIN_VALUE * BINARY_32_EPSILON;
      }
      // Veltkamp's splitting (?)
      var a = (1 + BINARY_32_EPSILON / Number.EPSILON) * abs;
      var result = a - (a - abs);
      if (result > BINARY_32_MAX_VALUE || numberIsNaN(result)) {
        return sign * Infinity;
      }
      return sign * result;
    }
  };
  defineProperties(Math, MathShims);
  // IE 11 TP has an imprecise log1p: reports Math.log1p(-1e-17) as 0
  defineProperty(Math, 'log1p', MathShims.log1p, Math.log1p(-1e-17) !== -1e-17);
  // IE 11 TP has an imprecise asinh: reports Math.asinh(-1e7) as not exactly equal to -Math.asinh(1e7)
  defineProperty(Math, 'asinh', MathShims.asinh, Math.asinh(-1e7) !== -Math.asinh(1e7));
  // Chrome 40 has an imprecise Math.tanh with very small numbers
  defineProperty(Math, 'tanh', MathShims.tanh, Math.tanh(-2e-17) !== -2e-17);
  // Chrome 40 loses Math.acosh precision with high numbers
  defineProperty(Math, 'acosh', MathShims.acosh, Math.acosh(Number.MAX_VALUE) === Infinity);
  // Firefox 38 on Windows
  defineProperty(Math, 'cbrt', MathShims.cbrt, Math.abs(1 - Math.cbrt(1e-300) / 1e-100) / Number.EPSILON > 8);
  // node 0.11 has an imprecise Math.sinh with very small numbers
  defineProperty(Math, 'sinh', MathShims.sinh, Math.sinh(-2e-17) !== -2e-17);
  // FF 35 on Linux reports 22025.465794806725 for Math.expm1(10)
  var expm1OfTen = Math.expm1(10);
  defineProperty(Math, 'expm1', MathShims.expm1, expm1OfTen > 22025.465794806719 || expm1OfTen < 22025.4657948067165168);

  var origMathRound = Math.round;
  // breaks in e.g. Safari 8, Internet Explorer 11, Opera 12
  var roundHandlesBoundaryConditions = Math.round(0.5 - Number.EPSILON / 4) === 0 && Math.round(-0.5 + Number.EPSILON / 3.99) === 1;

  // When engines use Math.floor(x + 0.5) internally, Math.round can be buggy for large integers.
  // This behavior should be governed by "round to nearest, ties to even mode"
  // see http://www.ecma-international.org/ecma-262/6.0/#sec-terms-and-definitions-number-type
  // These are the boundary cases where it breaks.
  var smallestPositiveNumberWhereRoundBreaks = inverseEpsilon + 1;
  var largestPositiveNumberWhereRoundBreaks = 2 * inverseEpsilon - 1;
  var roundDoesNotIncreaseIntegers = [smallestPositiveNumberWhereRoundBreaks, largestPositiveNumberWhereRoundBreaks].every(function (num) {
    return Math.round(num) === num;
  });
  defineProperty(Math, 'round', function round(x) {
    var floor = _floor(x);
    var ceil = floor === -1 ? -0 : floor + 1;
    return x - floor < 0.5 ? floor : ceil;
  }, !roundHandlesBoundaryConditions || !roundDoesNotIncreaseIntegers);
  Value.preserveToString(Math.round, origMathRound);

  var origImul = Math.imul;
  if (Math.imul(0xffffffff, 5) !== -5) {
    // Safari 6.1, at least, reports "0" for this value
    Math.imul = MathShims.imul;
    Value.preserveToString(Math.imul, origImul);
  }
  if (Math.imul.length !== 2) {
    // Safari 8.0.4 has a length of 1
    // fixed in https://bugs.webkit.org/show_bug.cgi?id=143658
    overrideNative(Math, 'imul', function imul(x, y) {
      return ES.Call(origImul, Math, arguments);
    });
  }

  // Promises
  // Simplest possible implementation; use a 3rd-party library if you
  // want the best possible speed and/or long stack traces.
  var PromiseShim = (function () {
    var setTimeout = globals.setTimeout;
    // some environments don't have setTimeout - no way to shim here.
    if (typeof setTimeout !== 'function' && typeof setTimeout !== 'object') { return; }

    ES.IsPromise = function (promise) {
      if (!ES.TypeIsObject(promise)) {
        return false;
      }
      if (typeof promise._promise === 'undefined') {
        return false; // uninitialized, or missing our hidden field.
      }
      return true;
    };

    // "PromiseCapability" in the spec is what most promise implementations
    // call a "deferred".
    var PromiseCapability = function (C) {
      if (!ES.IsConstructor(C)) {
        throw new TypeError('Bad promise constructor');
      }
      var capability = this;
      var resolver = function (resolve, reject) {
        if (capability.resolve !== void 0 || capability.reject !== void 0) {
          throw new TypeError('Bad Promise implementation!');
        }
        capability.resolve = resolve;
        capability.reject = reject;
      };
      // Initialize fields to inform optimizers about the object shape.
      capability.resolve = void 0;
      capability.reject = void 0;
      capability.promise = new C(resolver);
      if (!(ES.IsCallable(capability.resolve) && ES.IsCallable(capability.reject))) {
        throw new TypeError('Bad promise constructor');
      }
    };

    // find an appropriate setImmediate-alike
    var makeZeroTimeout;
    /*global window */
    if (typeof window !== 'undefined' && ES.IsCallable(window.postMessage)) {
      makeZeroTimeout = function () {
        // from http://dbaron.org/log/20100309-faster-timeouts
        var timeouts = [];
        var messageName = 'zero-timeout-message';
        var setZeroTimeout = function (fn) {
          _push(timeouts, fn);
          window.postMessage(messageName, '*');
        };
        var handleMessage = function (event) {
          if (event.source === window && event.data === messageName) {
            event.stopPropagation();
            if (timeouts.length === 0) { return; }
            var fn = _shift(timeouts);
            fn();
          }
        };
        window.addEventListener('message', handleMessage, true);
        return setZeroTimeout;
      };
    }
    var makePromiseAsap = function () {
      // An efficient task-scheduler based on a pre-existing Promise
      // implementation, which we can use even if we override the
      // global Promise below (in order to workaround bugs)
      // https://github.com/Raynos/observ-hash/issues/2#issuecomment-35857671
      var P = globals.Promise;
      var pr = P && P.resolve && P.resolve();
      return pr && function (task) {
        return pr.then(task);
      };
    };
    /*global process */
    /* jscs:disable disallowMultiLineTernary */
    var enqueue = ES.IsCallable(globals.setImmediate) ?
      globals.setImmediate :
      typeof process === 'object' && process.nextTick ? process.nextTick :
      makePromiseAsap() ||
      (ES.IsCallable(makeZeroTimeout) ? makeZeroTimeout() :
      function (task) { setTimeout(task, 0); }); // fallback
    /* jscs:enable disallowMultiLineTernary */

    // Constants for Promise implementation
    var PROMISE_IDENTITY = function (x) { return x; };
    var PROMISE_THROWER = function (e) { throw e; };
    var PROMISE_PENDING = 0;
    var PROMISE_FULFILLED = 1;
    var PROMISE_REJECTED = 2;
    // We store fulfill/reject handlers and capabilities in a single array.
    var PROMISE_FULFILL_OFFSET = 0;
    var PROMISE_REJECT_OFFSET = 1;
    var PROMISE_CAPABILITY_OFFSET = 2;
    // This is used in an optimization for chaining promises via then.
    var PROMISE_FAKE_CAPABILITY = {};

    var enqueuePromiseReactionJob = function (handler, capability, argument) {
      enqueue(function () {
        promiseReactionJob(handler, capability, argument);
      });
    };

    var promiseReactionJob = function (handler, promiseCapability, argument) {
      var handlerResult, f;
      if (promiseCapability === PROMISE_FAKE_CAPABILITY) {
        // Fast case, when we don't actually need to chain through to a
        // (real) promiseCapability.
        return handler(argument);
      }
      try {
        handlerResult = handler(argument);
        f = promiseCapability.resolve;
      } catch (e) {
        handlerResult = e;
        f = promiseCapability.reject;
      }
      f(handlerResult);
    };

    var fulfillPromise = function (promise, value) {
      var _promise = promise._promise;
      var length = _promise.reactionLength;
      if (length > 0) {
        enqueuePromiseReactionJob(
          _promise.fulfillReactionHandler0,
          _promise.reactionCapability0,
          value
        );
        _promise.fulfillReactionHandler0 = void 0;
        _promise.rejectReactions0 = void 0;
        _promise.reactionCapability0 = void 0;
        if (length > 1) {
          for (var i = 1, idx = 0; i < length; i++, idx += 3) {
            enqueuePromiseReactionJob(
              _promise[idx + PROMISE_FULFILL_OFFSET],
              _promise[idx + PROMISE_CAPABILITY_OFFSET],
              value
            );
            promise[idx + PROMISE_FULFILL_OFFSET] = void 0;
            promise[idx + PROMISE_REJECT_OFFSET] = void 0;
            promise[idx + PROMISE_CAPABILITY_OFFSET] = void 0;
          }
        }
      }
      _promise.result = value;
      _promise.state = PROMISE_FULFILLED;
      _promise.reactionLength = 0;
    };

    var rejectPromise = function (promise, reason) {
      var _promise = promise._promise;
      var length = _promise.reactionLength;
      if (length > 0) {
        enqueuePromiseReactionJob(
          _promise.rejectReactionHandler0,
          _promise.reactionCapability0,
          reason
        );
        _promise.fulfillReactionHandler0 = void 0;
        _promise.rejectReactions0 = void 0;
        _promise.reactionCapability0 = void 0;
        if (length > 1) {
          for (var i = 1, idx = 0; i < length; i++, idx += 3) {
            enqueuePromiseReactionJob(
              _promise[idx + PROMISE_REJECT_OFFSET],
              _promise[idx + PROMISE_CAPABILITY_OFFSET],
              reason
            );
            promise[idx + PROMISE_FULFILL_OFFSET] = void 0;
            promise[idx + PROMISE_REJECT_OFFSET] = void 0;
            promise[idx + PROMISE_CAPABILITY_OFFSET] = void 0;
          }
        }
      }
      _promise.result = reason;
      _promise.state = PROMISE_REJECTED;
      _promise.reactionLength = 0;
    };

    var createResolvingFunctions = function (promise) {
      var alreadyResolved = false;
      var resolve = function (resolution) {
        var then;
        if (alreadyResolved) { return; }
        alreadyResolved = true;
        if (resolution === promise) {
          return rejectPromise(promise, new TypeError('Self resolution'));
        }
        if (!ES.TypeIsObject(resolution)) {
          return fulfillPromise(promise, resolution);
        }
        try {
          then = resolution.then;
        } catch (e) {
          return rejectPromise(promise, e);
        }
        if (!ES.IsCallable(then)) {
          return fulfillPromise(promise, resolution);
        }
        enqueue(function () {
          promiseResolveThenableJob(promise, resolution, then);
        });
      };
      var reject = function (reason) {
        if (alreadyResolved) { return; }
        alreadyResolved = true;
        return rejectPromise(promise, reason);
      };
      return { resolve: resolve, reject: reject };
    };

    var optimizedThen = function (then, thenable, resolve, reject) {
      // Optimization: since we discard the result, we can pass our
      // own then implementation a special hint to let it know it
      // doesn't have to create it.  (The PROMISE_FAKE_CAPABILITY
      // object is local to this implementation and unforgeable outside.)
      if (then === Promise$prototype$then) {
        _call(then, thenable, resolve, reject, PROMISE_FAKE_CAPABILITY);
      } else {
        _call(then, thenable, resolve, reject);
      }
    };
    var promiseResolveThenableJob = function (promise, thenable, then) {
      var resolvingFunctions = createResolvingFunctions(promise);
      var resolve = resolvingFunctions.resolve;
      var reject = resolvingFunctions.reject;
      try {
        optimizedThen(then, thenable, resolve, reject);
      } catch (e) {
        reject(e);
      }
    };

    var Promise$prototype, Promise$prototype$then;
    var Promise = (function () {
      var PromiseShim = function Promise(resolver) {
        if (!(this instanceof PromiseShim)) {
          throw new TypeError('Constructor Promise requires "new"');
        }
        if (this && this._promise) {
          throw new TypeError('Bad construction');
        }
        // see https://bugs.ecmascript.org/show_bug.cgi?id=2482
        if (!ES.IsCallable(resolver)) {
          throw new TypeError('not a valid resolver');
        }
        var promise = emulateES6construct(this, PromiseShim, Promise$prototype, {
          _promise: {
            result: void 0,
            state: PROMISE_PENDING,
            // The first member of the "reactions" array is inlined here,
            // since most promises only have one reaction.
            // We've also exploded the 'reaction' object to inline the
            // "handler" and "capability" fields, since both fulfill and
            // reject reactions share the same capability.
            reactionLength: 0,
            fulfillReactionHandler0: void 0,
            rejectReactionHandler0: void 0,
            reactionCapability0: void 0
          }
        });
        var resolvingFunctions = createResolvingFunctions(promise);
        var reject = resolvingFunctions.reject;
        try {
          resolver(resolvingFunctions.resolve, reject);
        } catch (e) {
          reject(e);
        }
        return promise;
      };
      return PromiseShim;
    }());
    Promise$prototype = Promise.prototype;

    var _promiseAllResolver = function (index, values, capability, remaining) {
      var alreadyCalled = false;
      return function (x) {
        if (alreadyCalled) { return; }
        alreadyCalled = true;
        values[index] = x;
        if ((--remaining.count) === 0) {
          var resolve = capability.resolve;
          resolve(values); // call w/ this===undefined
        }
      };
    };

    var performPromiseAll = function (iteratorRecord, C, resultCapability) {
      var it = iteratorRecord.iterator;
      var values = [];
      var remaining = { count: 1 };
      var next, nextValue;
      var index = 0;
      while (true) {
        try {
          next = ES.IteratorStep(it);
          if (next === false) {
            iteratorRecord.done = true;
            break;
          }
          nextValue = next.value;
        } catch (e) {
          iteratorRecord.done = true;
          throw e;
        }
        values[index] = void 0;
        var nextPromise = C.resolve(nextValue);
        var resolveElement = _promiseAllResolver(
          index, values, resultCapability, remaining
        );
        remaining.count += 1;
        optimizedThen(nextPromise.then, nextPromise, resolveElement, resultCapability.reject);
        index += 1;
      }
      if ((--remaining.count) === 0) {
        var resolve = resultCapability.resolve;
        resolve(values); // call w/ this===undefined
      }
      return resultCapability.promise;
    };

    var performPromiseRace = function (iteratorRecord, C, resultCapability) {
      var it = iteratorRecord.iterator;
      var next, nextValue, nextPromise;
      while (true) {
        try {
          next = ES.IteratorStep(it);
          if (next === false) {
            // NOTE: If iterable has no items, resulting promise will never
            // resolve; see:
            // https://github.com/domenic/promises-unwrapping/issues/75
            // https://bugs.ecmascript.org/show_bug.cgi?id=2515
            iteratorRecord.done = true;
            break;
          }
          nextValue = next.value;
        } catch (e) {
          iteratorRecord.done = true;
          throw e;
        }
        nextPromise = C.resolve(nextValue);
        optimizedThen(nextPromise.then, nextPromise, resultCapability.resolve, resultCapability.reject);
      }
      return resultCapability.promise;
    };

    defineProperties(Promise, {
      all: function all(iterable) {
        var C = this;
        if (!ES.TypeIsObject(C)) {
          throw new TypeError('Promise is not object');
        }
        var capability = new PromiseCapability(C);
        var iterator, iteratorRecord;
        try {
          iterator = ES.GetIterator(iterable);
          iteratorRecord = { iterator: iterator, done: false };
          return performPromiseAll(iteratorRecord, C, capability);
        } catch (e) {
          var exception = e;
          if (iteratorRecord && !iteratorRecord.done) {
            try {
              ES.IteratorClose(iterator, true);
            } catch (ee) {
              exception = ee;
            }
          }
          var reject = capability.reject;
          reject(exception);
          return capability.promise;
        }
      },

      race: function race(iterable) {
        var C = this;
        if (!ES.TypeIsObject(C)) {
          throw new TypeError('Promise is not object');
        }
        var capability = new PromiseCapability(C);
        var iterator, iteratorRecord;
        try {
          iterator = ES.GetIterator(iterable);
          iteratorRecord = { iterator: iterator, done: false };
          return performPromiseRace(iteratorRecord, C, capability);
        } catch (e) {
          var exception = e;
          if (iteratorRecord && !iteratorRecord.done) {
            try {
              ES.IteratorClose(iterator, true);
            } catch (ee) {
              exception = ee;
            }
          }
          var reject = capability.reject;
          reject(exception);
          return capability.promise;
        }
      },

      reject: function reject(reason) {
        var C = this;
        if (!ES.TypeIsObject(C)) {
          throw new TypeError('Bad promise constructor');
        }
        var capability = new PromiseCapability(C);
        var rejectFunc = capability.reject;
        rejectFunc(reason); // call with this===undefined
        return capability.promise;
      },

      resolve: function resolve(v) {
        // See https://esdiscuss.org/topic/fixing-promise-resolve for spec
        var C = this;
        if (!ES.TypeIsObject(C)) {
          throw new TypeError('Bad promise constructor');
        }
        if (ES.IsPromise(v)) {
          var constructor = v.constructor;
          if (constructor === C) {
            return v;
          }
        }
        var capability = new PromiseCapability(C);
        var resolveFunc = capability.resolve;
        resolveFunc(v); // call with this===undefined
        return capability.promise;
      }
    });

    defineProperties(Promise$prototype, {
      'catch': function (onRejected) {
        return this.then(null, onRejected);
      },

      then: function then(onFulfilled, onRejected) {
        var promise = this;
        if (!ES.IsPromise(promise)) { throw new TypeError('not a promise'); }
        var C = ES.SpeciesConstructor(promise, Promise);
        var resultCapability;
        var returnValueIsIgnored = arguments.length > 2 && arguments[2] === PROMISE_FAKE_CAPABILITY;
        if (returnValueIsIgnored && C === Promise) {
          resultCapability = PROMISE_FAKE_CAPABILITY;
        } else {
          resultCapability = new PromiseCapability(C);
        }
        // PerformPromiseThen(promise, onFulfilled, onRejected, resultCapability)
        // Note that we've split the 'reaction' object into its two
        // components, "capabilities" and "handler"
        // "capabilities" is always equal to `resultCapability`
        var fulfillReactionHandler = ES.IsCallable(onFulfilled) ? onFulfilled : PROMISE_IDENTITY;
        var rejectReactionHandler = ES.IsCallable(onRejected) ? onRejected : PROMISE_THROWER;
        var _promise = promise._promise;
        var value;
        if (_promise.state === PROMISE_PENDING) {
          if (_promise.reactionLength === 0) {
            _promise.fulfillReactionHandler0 = fulfillReactionHandler;
            _promise.rejectReactionHandler0 = rejectReactionHandler;
            _promise.reactionCapability0 = resultCapability;
          } else {
            var idx = 3 * (_promise.reactionLength - 1);
            _promise[idx + PROMISE_FULFILL_OFFSET] = fulfillReactionHandler;
            _promise[idx + PROMISE_REJECT_OFFSET] = rejectReactionHandler;
            _promise[idx + PROMISE_CAPABILITY_OFFSET] = resultCapability;
          }
          _promise.reactionLength += 1;
        } else if (_promise.state === PROMISE_FULFILLED) {
          value = _promise.result;
          enqueuePromiseReactionJob(
            fulfillReactionHandler, resultCapability, value
          );
        } else if (_promise.state === PROMISE_REJECTED) {
          value = _promise.result;
          enqueuePromiseReactionJob(
            rejectReactionHandler, resultCapability, value
          );
        } else {
          throw new TypeError('unexpected Promise state');
        }
        return resultCapability.promise;
      }
    });
    // This helps the optimizer by ensuring that methods which take
    // capabilities aren't polymorphic.
    PROMISE_FAKE_CAPABILITY = new PromiseCapability(Promise);
    Promise$prototype$then = Promise$prototype.then;

    return Promise;
  }());

  // Chrome's native Promise has extra methods that it shouldn't have. Let's remove them.
  if (globals.Promise) {
    delete globals.Promise.accept;
    delete globals.Promise.defer;
    delete globals.Promise.prototype.chain;
  }

  if (typeof PromiseShim === 'function') {
    // export the Promise constructor.
    defineProperties(globals, { Promise: PromiseShim });
    // In Chrome 33 (and thereabouts) Promise is defined, but the
    // implementation is buggy in a number of ways.  Let's check subclassing
    // support to see if we have a buggy implementation.
    var promiseSupportsSubclassing = supportsSubclassing(globals.Promise, function (S) {
      return S.resolve(42).then(function () {}) instanceof S;
    });
    var promiseIgnoresNonFunctionThenCallbacks = !throwsError(function () { globals.Promise.reject(42).then(null, 5).then(null, noop); });
    var promiseRequiresObjectContext = throwsError(function () { globals.Promise.call(3, noop); });
    // Promise.resolve() was errata'ed late in the ES6 process.
    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1170742
    //      https://code.google.com/p/v8/issues/detail?id=4161
    // It serves as a proxy for a number of other bugs in early Promise
    // implementations.
    var promiseResolveBroken = (function (Promise) {
      var p = Promise.resolve(5);
      p.constructor = {};
      var p2 = Promise.resolve(p);
      try {
        p2.then(null, noop).then(null, noop); // avoid "uncaught rejection" warnings in console
      } catch (e) {
        return true; // v8 native Promises break here https://code.google.com/p/chromium/issues/detail?id=575314
      }
      return p === p2; // This *should* be false!
    }(globals.Promise));

    // Chrome 46 (probably older too) does not retrieve a thenable's .then synchronously
    var getsThenSynchronously = supportsDescriptors && (function () {
      var count = 0;
      var thenable = Object.defineProperty({}, 'then', { get: function () { count += 1; } });
      Promise.resolve(thenable);
      return count === 1;
    }());

    var BadResolverPromise = function BadResolverPromise(executor) {
      var p = new Promise(executor);
      executor(3, function () {});
      this.then = p.then;
      this.constructor = BadResolverPromise;
    };
    BadResolverPromise.prototype = Promise.prototype;
    BadResolverPromise.all = Promise.all;
    // Chrome Canary 49 (probably older too) has some implementation bugs
    var hasBadResolverPromise = valueOrFalseIfThrows(function () {
      return !!BadResolverPromise.all([1, 2]);
    });

    if (!promiseSupportsSubclassing || !promiseIgnoresNonFunctionThenCallbacks ||
        !promiseRequiresObjectContext || promiseResolveBroken ||
        !getsThenSynchronously || hasBadResolverPromise) {
      /* globals Promise: true */
      /* eslint-disable no-undef */
      /* jshint -W020 */
      Promise = PromiseShim;
      /* jshint +W020 */
      /* eslint-enable no-undef */
      /* globals Promise: false */
      overrideNative(globals, 'Promise', PromiseShim);
    }
    if (Promise.all.length !== 1) {
      var origAll = Promise.all;
      overrideNative(Promise, 'all', function all(iterable) {
        return ES.Call(origAll, this, arguments);
      });
    }
    if (Promise.race.length !== 1) {
      var origRace = Promise.race;
      overrideNative(Promise, 'race', function race(iterable) {
        return ES.Call(origRace, this, arguments);
      });
    }
    if (Promise.resolve.length !== 1) {
      var origResolve = Promise.resolve;
      overrideNative(Promise, 'resolve', function resolve(x) {
        return ES.Call(origResolve, this, arguments);
      });
    }
    if (Promise.reject.length !== 1) {
      var origReject = Promise.reject;
      overrideNative(Promise, 'reject', function reject(r) {
        return ES.Call(origReject, this, arguments);
      });
    }
    ensureEnumerable(Promise, 'all');
    ensureEnumerable(Promise, 'race');
    ensureEnumerable(Promise, 'resolve');
    ensureEnumerable(Promise, 'reject');
    addDefaultSpecies(Promise);
  }

  // Map and Set require a true ES5 environment
  // Their fast path also requires that the environment preserve
  // property insertion order, which is not guaranteed by the spec.
  var testOrder = function (a) {
    var b = keys(_reduce(a, function (o, k) {
      o[k] = true;
      return o;
    }, {}));
    return a.join(':') === b.join(':');
  };
  var preservesInsertionOrder = testOrder(['z', 'a', 'bb']);
  // some engines (eg, Chrome) only preserve insertion order for string keys
  var preservesNumericInsertionOrder = testOrder(['z', 1, 'a', '3', 2]);

  if (supportsDescriptors) {

    var fastkey = function fastkey(key) {
      if (!preservesInsertionOrder) {
        return null;
      }
      if (typeof key === 'undefined' || key === null) {
        return '^' + ES.ToString(key);
      } else if (typeof key === 'string') {
        return '$' + key;
      } else if (typeof key === 'number') {
        // note that -0 will get coerced to "0" when used as a property key
        if (!preservesNumericInsertionOrder) {
          return 'n' + key;
        }
        return key;
      } else if (typeof key === 'boolean') {
        return 'b' + key;
      }
      return null;
    };

    var emptyObject = function emptyObject() {
      // accomodate some older not-quite-ES5 browsers
      return Object.create ? Object.create(null) : {};
    };

    var addIterableToMap = function addIterableToMap(MapConstructor, map, iterable) {
      if (isArray(iterable) || Type.string(iterable)) {
        _forEach(iterable, function (entry) {
          if (!ES.TypeIsObject(entry)) {
            throw new TypeError('Iterator value ' + entry + ' is not an entry object');
          }
          map.set(entry[0], entry[1]);
        });
      } else if (iterable instanceof MapConstructor) {
        _call(MapConstructor.prototype.forEach, iterable, function (value, key) {
          map.set(key, value);
        });
      } else {
        var iter, adder;
        if (iterable !== null && typeof iterable !== 'undefined') {
          adder = map.set;
          if (!ES.IsCallable(adder)) { throw new TypeError('bad map'); }
          iter = ES.GetIterator(iterable);
        }
        if (typeof iter !== 'undefined') {
          while (true) {
            var next = ES.IteratorStep(iter);
            if (next === false) { break; }
            var nextItem = next.value;
            try {
              if (!ES.TypeIsObject(nextItem)) {
                throw new TypeError('Iterator value ' + nextItem + ' is not an entry object');
              }
              _call(adder, map, nextItem[0], nextItem[1]);
            } catch (e) {
              ES.IteratorClose(iter, true);
              throw e;
            }
          }
        }
      }
    };
    var addIterableToSet = function addIterableToSet(SetConstructor, set, iterable) {
      if (isArray(iterable) || Type.string(iterable)) {
        _forEach(iterable, function (value) {
          set.add(value);
        });
      } else if (iterable instanceof SetConstructor) {
        _call(SetConstructor.prototype.forEach, iterable, function (value) {
          set.add(value);
        });
      } else {
        var iter, adder;
        if (iterable !== null && typeof iterable !== 'undefined') {
          adder = set.add;
          if (!ES.IsCallable(adder)) { throw new TypeError('bad set'); }
          iter = ES.GetIterator(iterable);
        }
        if (typeof iter !== 'undefined') {
          while (true) {
            var next = ES.IteratorStep(iter);
            if (next === false) { break; }
            var nextValue = next.value;
            try {
              _call(adder, set, nextValue);
            } catch (e) {
              ES.IteratorClose(iter, true);
              throw e;
            }
          }
        }
      }
    };

    var collectionShims = {
      Map: (function () {

        var empty = {};

        var MapEntry = function MapEntry(key, value) {
          this.key = key;
          this.value = value;
          this.next = null;
          this.prev = null;
        };

        MapEntry.prototype.isRemoved = function isRemoved() {
          return this.key === empty;
        };

        var isMap = function isMap(map) {
          return !!map._es6map;
        };

        var requireMapSlot = function requireMapSlot(map, method) {
          if (!ES.TypeIsObject(map) || !isMap(map)) {
            throw new TypeError('Method Map.prototype.' + method + ' called on incompatible receiver ' + ES.ToString(map));
          }
        };

        var MapIterator = function MapIterator(map, kind) {
          requireMapSlot(map, '[[MapIterator]]');
          this.head = map._head;
          this.i = this.head;
          this.kind = kind;
        };

        MapIterator.prototype = {
          next: function next() {
            var i = this.i;
            var kind = this.kind;
            var head = this.head;
            if (typeof this.i === 'undefined') {
              return iteratorResult();
            }
            while (i.isRemoved() && i !== head) {
              // back up off of removed entries
              i = i.prev;
            }
            // advance to next unreturned element.
            var result;
            while (i.next !== head) {
              i = i.next;
              if (!i.isRemoved()) {
                if (kind === 'key') {
                  result = i.key;
                } else if (kind === 'value') {
                  result = i.value;
                } else {
                  result = [i.key, i.value];
                }
                this.i = i;
                return iteratorResult(result);
              }
            }
            // once the iterator is done, it is done forever.
            this.i = void 0;
            return iteratorResult();
          }
        };
        addIterator(MapIterator.prototype);

        var Map$prototype;
        var MapShim = function Map() {
          if (!(this instanceof Map)) {
            throw new TypeError('Constructor Map requires "new"');
          }
          if (this && this._es6map) {
            throw new TypeError('Bad construction');
          }
          var map = emulateES6construct(this, Map, Map$prototype, {
            _es6map: true,
            _head: null,
            _storage: emptyObject(),
            _size: 0
          });

          var head = new MapEntry(null, null);
          // circular doubly-linked list.
          head.next = head.prev = head;
          map._head = head;

          // Optionally initialize map from iterable
          if (arguments.length > 0) {
            addIterableToMap(Map, map, arguments[0]);
          }
          return map;
        };
        Map$prototype = MapShim.prototype;

        Value.getter(Map$prototype, 'size', function () {
          if (typeof this._size === 'undefined') {
            throw new TypeError('size method called on incompatible Map');
          }
          return this._size;
        });

        defineProperties(Map$prototype, {
          get: function get(key) {
            requireMapSlot(this, 'get');
            var fkey = fastkey(key);
            if (fkey !== null) {
              // fast O(1) path
              var entry = this._storage[fkey];
              if (entry) {
                return entry.value;
              } else {
                return;
              }
            }
            var head = this._head;
            var i = head;
            while ((i = i.next) !== head) {
              if (ES.SameValueZero(i.key, key)) {
                return i.value;
              }
            }
          },

          has: function has(key) {
            requireMapSlot(this, 'has');
            var fkey = fastkey(key);
            if (fkey !== null) {
              // fast O(1) path
              return typeof this._storage[fkey] !== 'undefined';
            }
            var head = this._head;
            var i = head;
            while ((i = i.next) !== head) {
              if (ES.SameValueZero(i.key, key)) {
                return true;
              }
            }
            return false;
          },

          set: function set(key, value) {
            requireMapSlot(this, 'set');
            var head = this._head;
            var i = head;
            var entry;
            var fkey = fastkey(key);
            if (fkey !== null) {
              // fast O(1) path
              if (typeof this._storage[fkey] !== 'undefined') {
                this._storage[fkey].value = value;
                return this;
              } else {
                entry = this._storage[fkey] = new MapEntry(key, value);
                i = head.prev;
                // fall through
              }
            }
            while ((i = i.next) !== head) {
              if (ES.SameValueZero(i.key, key)) {
                i.value = value;
                return this;
              }
            }
            entry = entry || new MapEntry(key, value);
            if (ES.SameValue(-0, key)) {
              entry.key = +0; // coerce -0 to +0 in entry
            }
            entry.next = this._head;
            entry.prev = this._head.prev;
            entry.prev.next = entry;
            entry.next.prev = entry;
            this._size += 1;
            return this;
          },

          'delete': function (key) {
            requireMapSlot(this, 'delete');
            var head = this._head;
            var i = head;
            var fkey = fastkey(key);
            if (fkey !== null) {
              // fast O(1) path
              if (typeof this._storage[fkey] === 'undefined') {
                return false;
              }
              i = this._storage[fkey].prev;
              delete this._storage[fkey];
              // fall through
            }
            while ((i = i.next) !== head) {
              if (ES.SameValueZero(i.key, key)) {
                i.key = i.value = empty;
                i.prev.next = i.next;
                i.next.prev = i.prev;
                this._size -= 1;
                return true;
              }
            }
            return false;
          },

          clear: function clear() {
            requireMapSlot(this, 'clear');
            this._size = 0;
            this._storage = emptyObject();
            var head = this._head;
            var i = head;
            var p = i.next;
            while ((i = p) !== head) {
              i.key = i.value = empty;
              p = i.next;
              i.next = i.prev = head;
            }
            head.next = head.prev = head;
          },

          keys: function keys() {
            requireMapSlot(this, 'keys');
            return new MapIterator(this, 'key');
          },

          values: function values() {
            requireMapSlot(this, 'values');
            return new MapIterator(this, 'value');
          },

          entries: function entries() {
            requireMapSlot(this, 'entries');
            return new MapIterator(this, 'key+value');
          },

          forEach: function forEach(callback) {
            requireMapSlot(this, 'forEach');
            var context = arguments.length > 1 ? arguments[1] : null;
            var it = this.entries();
            for (var entry = it.next(); !entry.done; entry = it.next()) {
              if (context) {
                _call(callback, context, entry.value[1], entry.value[0], this);
              } else {
                callback(entry.value[1], entry.value[0], this);
              }
            }
          }
        });
        addIterator(Map$prototype, Map$prototype.entries);

        return MapShim;
      }()),

      Set: (function () {
        var isSet = function isSet(set) {
          return set._es6set && typeof set._storage !== 'undefined';
        };
        var requireSetSlot = function requireSetSlot(set, method) {
          if (!ES.TypeIsObject(set) || !isSet(set)) {
            // https://github.com/paulmillr/es6-shim/issues/176
            throw new TypeError('Set.prototype.' + method + ' called on incompatible receiver ' + ES.ToString(set));
          }
        };

        // Creating a Map is expensive.  To speed up the common case of
        // Sets containing only string or numeric keys, we use an object
        // as backing storage and lazily create a full Map only when
        // required.
        var Set$prototype;
        var SetShim = function Set() {
          if (!(this instanceof Set)) {
            throw new TypeError('Constructor Set requires "new"');
          }
          if (this && this._es6set) {
            throw new TypeError('Bad construction');
          }
          var set = emulateES6construct(this, Set, Set$prototype, {
            _es6set: true,
            '[[SetData]]': null,
            _storage: emptyObject()
          });
          if (!set._es6set) {
            throw new TypeError('bad set');
          }

          // Optionally initialize Set from iterable
          if (arguments.length > 0) {
            addIterableToSet(Set, set, arguments[0]);
          }
          return set;
        };
        Set$prototype = SetShim.prototype;

        var decodeKey = function (key) {
          var k = key;
          if (k === '^null') {
            return null;
          } else if (k === '^undefined') {
            return void 0;
          } else {
            var first = k.charAt(0);
            if (first === '$') {
              return _strSlice(k, 1);
            } else if (first === 'n') {
              return +_strSlice(k, 1);
            } else if (first === 'b') {
              return k === 'btrue';
            }
          }
          return +k;
        };
        // Switch from the object backing storage to a full Map.
        var ensureMap = function ensureMap(set) {
          if (!set['[[SetData]]']) {
            var m = set['[[SetData]]'] = new collectionShims.Map();
            _forEach(keys(set._storage), function (key) {
              var k = decodeKey(key);
              m.set(k, k);
            });
            set['[[SetData]]'] = m;
          }
          set._storage = null; // free old backing storage
        };

        Value.getter(SetShim.prototype, 'size', function () {
          requireSetSlot(this, 'size');
          if (this._storage) {
            return keys(this._storage).length;
          }
          ensureMap(this);
          return this['[[SetData]]'].size;
        });

        defineProperties(SetShim.prototype, {
          has: function has(key) {
            requireSetSlot(this, 'has');
            var fkey;
            if (this._storage && (fkey = fastkey(key)) !== null) {
              return !!this._storage[fkey];
            }
            ensureMap(this);
            return this['[[SetData]]'].has(key);
          },

          add: function add(key) {
            requireSetSlot(this, 'add');
            var fkey;
            if (this._storage && (fkey = fastkey(key)) !== null) {
              this._storage[fkey] = true;
              return this;
            }
            ensureMap(this);
            this['[[SetData]]'].set(key, key);
            return this;
          },

          'delete': function (key) {
            requireSetSlot(this, 'delete');
            var fkey;
            if (this._storage && (fkey = fastkey(key)) !== null) {
              var hasFKey = _hasOwnProperty(this._storage, fkey);
              return (delete this._storage[fkey]) && hasFKey;
            }
            ensureMap(this);
            return this['[[SetData]]']['delete'](key);
          },

          clear: function clear() {
            requireSetSlot(this, 'clear');
            if (this._storage) {
              this._storage = emptyObject();
            }
            if (this['[[SetData]]']) {
              this['[[SetData]]'].clear();
            }
          },

          values: function values() {
            requireSetSlot(this, 'values');
            ensureMap(this);
            return this['[[SetData]]'].values();
          },

          entries: function entries() {
            requireSetSlot(this, 'entries');
            ensureMap(this);
            return this['[[SetData]]'].entries();
          },

          forEach: function forEach(callback) {
            requireSetSlot(this, 'forEach');
            var context = arguments.length > 1 ? arguments[1] : null;
            var entireSet = this;
            ensureMap(entireSet);
            this['[[SetData]]'].forEach(function (value, key) {
              if (context) {
                _call(callback, context, key, key, entireSet);
              } else {
                callback(key, key, entireSet);
              }
            });
          }
        });
        defineProperty(SetShim.prototype, 'keys', SetShim.prototype.values, true);
        addIterator(SetShim.prototype, SetShim.prototype.values);

        return SetShim;
      }())
    };

    if (globals.Map || globals.Set) {
      // Safari 8, for example, doesn't accept an iterable.
      var mapAcceptsArguments = valueOrFalseIfThrows(function () { return new Map([[1, 2]]).get(1) === 2; });
      if (!mapAcceptsArguments) {
        var OrigMapNoArgs = globals.Map;
        globals.Map = function Map() {
          if (!(this instanceof Map)) {
            throw new TypeError('Constructor Map requires "new"');
          }
          var m = new OrigMapNoArgs();
          if (arguments.length > 0) {
            addIterableToMap(Map, m, arguments[0]);
          }
          delete m.constructor;
          Object.setPrototypeOf(m, globals.Map.prototype);
          return m;
        };
        globals.Map.prototype = create(OrigMapNoArgs.prototype);
        defineProperty(globals.Map.prototype, 'constructor', globals.Map, true);
        Value.preserveToString(globals.Map, OrigMapNoArgs);
      }
      var testMap = new Map();
      var mapUsesSameValueZero = (function () {
        // Chrome 38-42, node 0.11/0.12, iojs 1/2 also have a bug when the Map has a size > 4
        var m = new Map([[1, 0], [2, 0], [3, 0], [4, 0]]);
        m.set(-0, m);
        return m.get(0) === m && m.get(-0) === m && m.has(0) && m.has(-0);
      }());
      var mapSupportsChaining = testMap.set(1, 2) === testMap;
      if (!mapUsesSameValueZero || !mapSupportsChaining) {
        var origMapSet = Map.prototype.set;
        overrideNative(Map.prototype, 'set', function set(k, v) {
          _call(origMapSet, this, k === 0 ? 0 : k, v);
          return this;
        });
      }
      if (!mapUsesSameValueZero) {
        var origMapGet = Map.prototype.get;
        var origMapHas = Map.prototype.has;
        defineProperties(Map.prototype, {
          get: function get(k) {
            return _call(origMapGet, this, k === 0 ? 0 : k);
          },
          has: function has(k) {
            return _call(origMapHas, this, k === 0 ? 0 : k);
          }
        }, true);
        Value.preserveToString(Map.prototype.get, origMapGet);
        Value.preserveToString(Map.prototype.has, origMapHas);
      }
      var testSet = new Set();
      var setUsesSameValueZero = (function (s) {
        s['delete'](0);
        s.add(-0);
        return !s.has(0);
      }(testSet));
      var setSupportsChaining = testSet.add(1) === testSet;
      if (!setUsesSameValueZero || !setSupportsChaining) {
        var origSetAdd = Set.prototype.add;
        Set.prototype.add = function add(v) {
          _call(origSetAdd, this, v === 0 ? 0 : v);
          return this;
        };
        Value.preserveToString(Set.prototype.add, origSetAdd);
      }
      if (!setUsesSameValueZero) {
        var origSetHas = Set.prototype.has;
        Set.prototype.has = function has(v) {
          return _call(origSetHas, this, v === 0 ? 0 : v);
        };
        Value.preserveToString(Set.prototype.has, origSetHas);
        var origSetDel = Set.prototype['delete'];
        Set.prototype['delete'] = function SetDelete(v) {
          return _call(origSetDel, this, v === 0 ? 0 : v);
        };
        Value.preserveToString(Set.prototype['delete'], origSetDel);
      }
      var mapSupportsSubclassing = supportsSubclassing(globals.Map, function (M) {
        var m = new M([]);
        // Firefox 32 is ok with the instantiating the subclass but will
        // throw when the map is used.
        m.set(42, 42);
        return m instanceof M;
      });
      var mapFailsToSupportSubclassing = Object.setPrototypeOf && !mapSupportsSubclassing; // without Object.setPrototypeOf, subclassing is not possible
      var mapRequiresNew = (function () {
        try {
          return !(globals.Map() instanceof globals.Map);
        } catch (e) {
          return e instanceof TypeError;
        }
      }());
      if (globals.Map.length !== 0 || mapFailsToSupportSubclassing || !mapRequiresNew) {
        var OrigMap = globals.Map;
        globals.Map = function Map() {
          if (!(this instanceof Map)) {
            throw new TypeError('Constructor Map requires "new"');
          }
          var m = new OrigMap();
          if (arguments.length > 0) {
            addIterableToMap(Map, m, arguments[0]);
          }
          delete m.constructor;
          Object.setPrototypeOf(m, Map.prototype);
          return m;
        };
        globals.Map.prototype = OrigMap.prototype;
        defineProperty(globals.Map.prototype, 'constructor', globals.Map, true);
        Value.preserveToString(globals.Map, OrigMap);
      }
      var setSupportsSubclassing = supportsSubclassing(globals.Set, function (S) {
        var s = new S([]);
        s.add(42, 42);
        return s instanceof S;
      });
      var setFailsToSupportSubclassing = Object.setPrototypeOf && !setSupportsSubclassing; // without Object.setPrototypeOf, subclassing is not possible
      var setRequiresNew = (function () {
        try {
          return !(globals.Set() instanceof globals.Set);
        } catch (e) {
          return e instanceof TypeError;
        }
      }());
      if (globals.Set.length !== 0 || setFailsToSupportSubclassing || !setRequiresNew) {
        var OrigSet = globals.Set;
        globals.Set = function Set() {
          if (!(this instanceof Set)) {
            throw new TypeError('Constructor Set requires "new"');
          }
          var s = new OrigSet();
          if (arguments.length > 0) {
            addIterableToSet(Set, s, arguments[0]);
          }
          delete s.constructor;
          Object.setPrototypeOf(s, Set.prototype);
          return s;
        };
        globals.Set.prototype = OrigSet.prototype;
        defineProperty(globals.Set.prototype, 'constructor', globals.Set, true);
        Value.preserveToString(globals.Set, OrigSet);
      }
      var newMap = new globals.Map();
      var mapIterationThrowsStopIterator = !valueOrFalseIfThrows(function () {
        return newMap.keys().next().done;
      });
      /*
        - In Firefox < 23, Map#size is a function.
        - In all current Firefox, Set#entries/keys/values & Map#clear do not exist
        - https://bugzilla.mozilla.org/show_bug.cgi?id=869996
        - In Firefox 24, Map and Set do not implement forEach
        - In Firefox 25 at least, Map and Set are callable without "new"
      */
      if (
        typeof globals.Map.prototype.clear !== 'function' ||
        new globals.Set().size !== 0 ||
        newMap.size !== 0 ||
        typeof globals.Map.prototype.keys !== 'function' ||
        typeof globals.Set.prototype.keys !== 'function' ||
        typeof globals.Map.prototype.forEach !== 'function' ||
        typeof globals.Set.prototype.forEach !== 'function' ||
        isCallableWithoutNew(globals.Map) ||
        isCallableWithoutNew(globals.Set) ||
        typeof newMap.keys().next !== 'function' || // Safari 8
        mapIterationThrowsStopIterator || // Firefox 25
        !mapSupportsSubclassing
      ) {
        defineProperties(globals, {
          Map: collectionShims.Map,
          Set: collectionShims.Set
        }, true);
      }

      if (globals.Set.prototype.keys !== globals.Set.prototype.values) {
        // Fixed in WebKit with https://bugs.webkit.org/show_bug.cgi?id=144190
        defineProperty(globals.Set.prototype, 'keys', globals.Set.prototype.values, true);
      }

      // Shim incomplete iterator implementations.
      addIterator(Object.getPrototypeOf((new globals.Map()).keys()));
      addIterator(Object.getPrototypeOf((new globals.Set()).keys()));

      if (functionsHaveNames && globals.Set.prototype.has.name !== 'has') {
        // Microsoft Edge v0.11.10074.0 is missing a name on Set#has
        var anonymousSetHas = globals.Set.prototype.has;
        overrideNative(globals.Set.prototype, 'has', function has(key) {
          return _call(anonymousSetHas, this, key);
        });
      }
    }
    defineProperties(globals, collectionShims);
    addDefaultSpecies(globals.Map);
    addDefaultSpecies(globals.Set);
  }

  var throwUnlessTargetIsObject = function throwUnlessTargetIsObject(target) {
    if (!ES.TypeIsObject(target)) {
      throw new TypeError('target must be an object');
    }
  };

  // Some Reflect methods are basically the same as
  // those on the Object global, except that a TypeError is thrown if
  // target isn't an object. As well as returning a boolean indicating
  // the success of the operation.
  var ReflectShims = {
    // Apply method in a functional form.
    apply: function apply() {
      return ES.Call(ES.Call, null, arguments);
    },

    // New operator in a functional form.
    construct: function construct(constructor, args) {
      if (!ES.IsConstructor(constructor)) {
        throw new TypeError('First argument must be a constructor.');
      }
      var newTarget = arguments.length > 2 ? arguments[2] : constructor;
      if (!ES.IsConstructor(newTarget)) {
        throw new TypeError('new.target must be a constructor.');
      }
      return ES.Construct(constructor, args, newTarget, 'internal');
    },

    // When deleting a non-existent or configurable property,
    // true is returned.
    // When attempting to delete a non-configurable property,
    // it will return false.
    deleteProperty: function deleteProperty(target, key) {
      throwUnlessTargetIsObject(target);
      if (supportsDescriptors) {
        var desc = Object.getOwnPropertyDescriptor(target, key);

        if (desc && !desc.configurable) {
          return false;
        }
      }

      // Will return true.
      return delete target[key];
    },

    has: function has(target, key) {
      throwUnlessTargetIsObject(target);
      return key in target;
    }
  };

  if (Object.getOwnPropertyNames) {
    Object.assign(ReflectShims, {
      // Basically the result of calling the internal [[OwnPropertyKeys]].
      // Concatenating propertyNames and propertySymbols should do the trick.
      // This should continue to work together with a Symbol shim
      // which overrides Object.getOwnPropertyNames and implements
      // Object.getOwnPropertySymbols.
      ownKeys: function ownKeys(target) {
        throwUnlessTargetIsObject(target);
        var keys = Object.getOwnPropertyNames(target);

        if (ES.IsCallable(Object.getOwnPropertySymbols)) {
          _pushApply(keys, Object.getOwnPropertySymbols(target));
        }

        return keys;
      }
    });
  }

  var callAndCatchException = function ConvertExceptionToBoolean(func) {
    return !throwsError(func);
  };

  if (Object.preventExtensions) {
    Object.assign(ReflectShims, {
      isExtensible: function isExtensible(target) {
        throwUnlessTargetIsObject(target);
        return Object.isExtensible(target);
      },
      preventExtensions: function preventExtensions(target) {
        throwUnlessTargetIsObject(target);
        return callAndCatchException(function () {
          Object.preventExtensions(target);
        });
      }
    });
  }

  if (supportsDescriptors) {
    var internalGet = function get(target, key, receiver) {
      var desc = Object.getOwnPropertyDescriptor(target, key);

      if (!desc) {
        var parent = Object.getPrototypeOf(target);

        if (parent === null) {
          return void 0;
        }

        return internalGet(parent, key, receiver);
      }

      if ('value' in desc) {
        return desc.value;
      }

      if (desc.get) {
        return ES.Call(desc.get, receiver);
      }

      return void 0;
    };

    var internalSet = function set(target, key, value, receiver) {
      var desc = Object.getOwnPropertyDescriptor(target, key);

      if (!desc) {
        var parent = Object.getPrototypeOf(target);

        if (parent !== null) {
          return internalSet(parent, key, value, receiver);
        }

        desc = {
          value: void 0,
          writable: true,
          enumerable: true,
          configurable: true
        };
      }

      if ('value' in desc) {
        if (!desc.writable) {
          return false;
        }

        if (!ES.TypeIsObject(receiver)) {
          return false;
        }

        var existingDesc = Object.getOwnPropertyDescriptor(receiver, key);

        if (existingDesc) {
          return Reflect.defineProperty(receiver, key, {
            value: value
          });
        } else {
          return Reflect.defineProperty(receiver, key, {
            value: value,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }

      if (desc.set) {
        _call(desc.set, receiver, value);
        return true;
      }

      return false;
    };

    Object.assign(ReflectShims, {
      defineProperty: function defineProperty(target, propertyKey, attributes) {
        throwUnlessTargetIsObject(target);
        return callAndCatchException(function () {
          Object.defineProperty(target, propertyKey, attributes);
        });
      },

      getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
        throwUnlessTargetIsObject(target);
        return Object.getOwnPropertyDescriptor(target, propertyKey);
      },

      // Syntax in a functional form.
      get: function get(target, key) {
        throwUnlessTargetIsObject(target);
        var receiver = arguments.length > 2 ? arguments[2] : target;

        return internalGet(target, key, receiver);
      },

      set: function set(target, key, value) {
        throwUnlessTargetIsObject(target);
        var receiver = arguments.length > 3 ? arguments[3] : target;

        return internalSet(target, key, value, receiver);
      }
    });
  }

  if (Object.getPrototypeOf) {
    var objectDotGetPrototypeOf = Object.getPrototypeOf;
    ReflectShims.getPrototypeOf = function getPrototypeOf(target) {
      throwUnlessTargetIsObject(target);
      return objectDotGetPrototypeOf(target);
    };
  }

  if (Object.setPrototypeOf && ReflectShims.getPrototypeOf) {
    var willCreateCircularPrototype = function (object, lastProto) {
      var proto = lastProto;
      while (proto) {
        if (object === proto) {
          return true;
        }
        proto = ReflectShims.getPrototypeOf(proto);
      }
      return false;
    };

    Object.assign(ReflectShims, {
      // Sets the prototype of the given object.
      // Returns true on success, otherwise false.
      setPrototypeOf: function setPrototypeOf(object, proto) {
        throwUnlessTargetIsObject(object);
        if (proto !== null && !ES.TypeIsObject(proto)) {
          throw new TypeError('proto must be an object or null');
        }

        // If they already are the same, we're done.
        if (proto === Reflect.getPrototypeOf(object)) {
          return true;
        }

        // Cannot alter prototype if object not extensible.
        if (Reflect.isExtensible && !Reflect.isExtensible(object)) {
          return false;
        }

        // Ensure that we do not create a circular prototype chain.
        if (willCreateCircularPrototype(object, proto)) {
          return false;
        }

        Object.setPrototypeOf(object, proto);

        return true;
      }
    });
  }
  var defineOrOverrideReflectProperty = function (key, shim) {
    if (!ES.IsCallable(globals.Reflect[key])) {
      defineProperty(globals.Reflect, key, shim);
    } else {
      var acceptsPrimitives = valueOrFalseIfThrows(function () {
        globals.Reflect[key](1);
        globals.Reflect[key](NaN);
        globals.Reflect[key](true);
        return true;
      });
      if (acceptsPrimitives) {
        overrideNative(globals.Reflect, key, shim);
      }
    }
  };
  Object.keys(ReflectShims).forEach(function (key) {
    defineOrOverrideReflectProperty(key, ReflectShims[key]);
  });
  var originalReflectGetProto = globals.Reflect.getPrototypeOf;
  if (functionsHaveNames && originalReflectGetProto && originalReflectGetProto.name !== 'getPrototypeOf') {
    overrideNative(globals.Reflect, 'getPrototypeOf', function getPrototypeOf(target) {
      return _call(originalReflectGetProto, globals.Reflect, target);
    });
  }
  if (globals.Reflect.setPrototypeOf) {
    if (valueOrFalseIfThrows(function () {
      globals.Reflect.setPrototypeOf(1, {});
      return true;
    })) {
      overrideNative(globals.Reflect, 'setPrototypeOf', ReflectShims.setPrototypeOf);
    }
  }
  if (globals.Reflect.defineProperty) {
    if (!valueOrFalseIfThrows(function () {
      var basic = !globals.Reflect.defineProperty(1, 'test', { value: 1 });
      // "extensible" fails on Edge 0.12
      var extensible = typeof Object.preventExtensions !== 'function' || !globals.Reflect.defineProperty(Object.preventExtensions({}), 'test', {});
      return basic && extensible;
    })) {
      overrideNative(globals.Reflect, 'defineProperty', ReflectShims.defineProperty);
    }
  }
  if (globals.Reflect.construct) {
    if (!valueOrFalseIfThrows(function () {
      var F = function F() {};
      return globals.Reflect.construct(function () {}, [], F) instanceof F;
    })) {
      overrideNative(globals.Reflect, 'construct', ReflectShims.construct);
    }
  }

  if (String(new Date(NaN)) !== 'Invalid Date') {
    var dateToString = Date.prototype.toString;
    var shimmedDateToString = function toString() {
      var valueOf = +this;
      if (valueOf !== valueOf) {
        return 'Invalid Date';
      }
      return ES.Call(dateToString, this);
    };
    overrideNative(Date.prototype, 'toString', shimmedDateToString);
  }

  // Annex B HTML methods
  // http://www.ecma-international.org/ecma-262/6.0/#sec-additional-properties-of-the-string.prototype-object
  var stringHTMLshims = {
    anchor: function anchor(name) { return ES.CreateHTML(this, 'a', 'name', name); },
    big: function big() { return ES.CreateHTML(this, 'big', '', ''); },
    blink: function blink() { return ES.CreateHTML(this, 'blink', '', ''); },
    bold: function bold() { return ES.CreateHTML(this, 'b', '', ''); },
    fixed: function fixed() { return ES.CreateHTML(this, 'tt', '', ''); },
    fontcolor: function fontcolor(color) { return ES.CreateHTML(this, 'font', 'color', color); },
    fontsize: function fontsize(size) { return ES.CreateHTML(this, 'font', 'size', size); },
    italics: function italics() { return ES.CreateHTML(this, 'i', '', ''); },
    link: function link(url) { return ES.CreateHTML(this, 'a', 'href', url); },
    small: function small() { return ES.CreateHTML(this, 'small', '', ''); },
    strike: function strike() { return ES.CreateHTML(this, 'strike', '', ''); },
    sub: function sub() { return ES.CreateHTML(this, 'sub', '', ''); },
    sup: function sub() { return ES.CreateHTML(this, 'sup', '', ''); }
  };
  _forEach(Object.keys(stringHTMLshims), function (key) {
    var method = String.prototype[key];
    var shouldOverwrite = false;
    if (ES.IsCallable(method)) {
      var output = _call(method, '', ' " ');
      var quotesCount = _concat([], output.match(/"/g)).length;
      shouldOverwrite = output !== output.toLowerCase() || quotesCount > 2;
    } else {
      shouldOverwrite = true;
    }
    if (shouldOverwrite) {
      overrideNative(String.prototype, key, stringHTMLshims[key]);
    }
  });

  var JSONstringifiesSymbols = (function () {
    // Microsoft Edge v0.12 stringifies Symbols incorrectly
    if (!hasSymbols) { return false; } // Symbols are not supported
    var stringify = typeof JSON === 'object' && typeof JSON.stringify === 'function' ? JSON.stringify : null;
    if (!stringify) { return false; } // JSON.stringify is not supported
    if (typeof stringify(Symbol()) !== 'undefined') { return true; } // Symbols should become `undefined`
    if (stringify([Symbol()]) !== '[null]') { return true; } // Symbols in arrays should become `null`
    var obj = { a: Symbol() };
    obj[Symbol()] = true;
    if (stringify(obj) !== '{}') { return true; } // Symbol-valued keys *and* Symbol-valued properties should be omitted
    return false;
  }());
  var JSONstringifyAcceptsObjectSymbol = valueOrFalseIfThrows(function () {
    // Chrome 45 throws on stringifying object symbols
    if (!hasSymbols) { return true; } // Symbols are not supported
    return JSON.stringify(Object(Symbol())) === '{}' && JSON.stringify([Object(Symbol())]) === '[{}]';
  });
  if (JSONstringifiesSymbols || !JSONstringifyAcceptsObjectSymbol) {
    var origStringify = JSON.stringify;
    overrideNative(JSON, 'stringify', function stringify(value) {
      if (typeof value === 'symbol') { return; }
      var replacer;
      if (arguments.length > 1) {
        replacer = arguments[1];
      }
      var args = [value];
      if (!isArray(replacer)) {
        var replaceFn = ES.IsCallable(replacer) ? replacer : null;
        var wrappedReplacer = function (key, val) {
          var parsedValue = replaceFn ? _call(replaceFn, this, key, val) : val;
          if (typeof parsedValue !== 'symbol') {
            if (Type.symbol(parsedValue)) {
              return assignTo({})(parsedValue);
            } else {
              return parsedValue;
            }
          }
        };
        args.push(wrappedReplacer);
      } else {
        // create wrapped replacer that handles an array replacer?
        args.push(replacer);
      }
      if (arguments.length > 2) {
        args.push(arguments[2]);
      }
      return origStringify.apply(this, args);
    });
  }

  return globals;
}));

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":391}],354:[function(require,module,exports){
"use strict";

var arbitrary = require("./arbitrary.js");
var bless = require("./bless.js");
var generator = require("./generator.js");
var primitive = require("./primitive.js");
var record = require("./record.js");
var recordWithEnv = require("./recordWithEnv.js");
var shrink = require("./shrink.js");
var small = require("./small.js");
var string = require("./string.js");

var api = {
  arbitrary: {
    small: small.arbitrary,
    bless: bless,
    record: recordWithEnv,
    nonshrink: arbitrary.nonshrink,
    pair: arbitrary.pair,
    either: arbitrary.either,
    unit: arbitrary.unit,
    dict: arbitrary.dict,
    json: arbitrary.json,
    nearray: arbitrary.nearray,
    array: arbitrary.array,
    tuple: arbitrary.tuple,
    sum: arbitrary.sum,
    oneof: arbitrary.oneof,
    recursive: arbitrary.recursive,
  },
  generator: {
    small: small.generator,
    record: record.generator,
  },
  shrink: {
    record: record.shrink,
  },
};

// Re-export stuff from internal modules
/* eslint-disable guard-for-in */
var k;
for (k in primitive) {
  api.arbitrary[k] = primitive[k];
}
for (k in string) {
  api.arbitrary[k] = string[k];
}
for (k in shrink) {
  api.shrink[k] = shrink[k];
}
for (k in generator) {
  api.generator[k] = generator[k];
}
module.exports = api;

},{"./arbitrary.js":355,"./bless.js":359,"./generator.js":366,"./primitive.js":370,"./record.js":372,"./recordWithEnv.js":373,"./shrink.js":375,"./small.js":376,"./string.js":377}],355:[function(require,module,exports){
/* @flow weak */
"use strict";

var arbitraryAssert = require("./arbitraryAssert.js");
var arbitraryBless = require("./arbitraryBless.js");
var array = require("./array.js");
var assert = require("assert");
var dict = require("./dict.js");
var generator = require("./generator.js");
var json = require("./json.js");
var pair = require("./pair.js");
var show = require("./show.js");
var shrink = require("./shrink.js");
var utils = require("./utils.js");

/**
  ### Arbitrary combinators
*/

/**
  - `nonshrink(arb: arbitrary a): arbitrary a`

      Non shrinkable version of arbitrary `arb`.
*/
function nonshrink(arb) {
  arb = utils.force(arb);

  return arbitraryBless({
    generator: arb.generator,
    shrink: shrink.noop,
    show: arb.show,
  });
}

/**
  - `unit: arbitrary ()`
*/
var unit = arbitraryBless({
  generator: generator.unit,
  shrink: shrink.noop,
  show: show.def,
});

/**
  - `either(arbA: arbitrary a, arbB : arbitrary b): arbitrary (either a b)`
*/
function either(a, b) {
  a = utils.force(a || json.json);
  b = utils.force(b || json.json);

  arbitraryAssert(a);
  arbitraryAssert(b);

  return arbitraryBless({
    generator: generator.either(a.generator, b.generator),
    shrink: shrink.either(a.shrink, b.shrink),
    show: show.either(a.show, b.show),
  });
}

/**
  - `pair(arbA: arbitrary a, arbB : arbitrary b): arbitrary (pair a b)`

      If not specified `a` and `b` are equal to `value()`.
*/
function pairArb(a, b) {
  return pair.pair(a || json.json, b || json.json);
}

/**
  - `tuple(arbs: (arbitrary a, arbitrary b...)): arbitrary (a, b...)`
*/
function tuple(arbs) {
  arbs = arbs.map(utils.force);
  return arbitraryBless({
    generator: generator.tuple(utils.pluck(arbs, "generator")),
    shrink: shrink.tuple(utils.pluck(arbs, "shrink")),
    show: show.tuple(utils.pluck(arbs, "show")),
  });
}

/**
  - `sum(arbs: (arbitrary a, arbitrary b...)): arbitrary (a | b ...)`
*/
function sum(arbs) {
  arbs = arbs.map(utils.force);
  return arbitraryBless({
    generator: generator.sum(utils.pluck(arbs, "generator")),
    shrink: shrink.sum(utils.pluck(arbs, "shrink")),
    show: show.sum(utils.pluck(arbs, "show")),
  });
}
/**
  - `dict(arb: arbitrary a): arbitrary (dict a)`

      Generates a JavaScript object with properties of type `A`.
*/
function dictArb(arb) {
  return dict.dict(arb || json.json);
}

/**
  - `array(arb: arbitrary a): arbitrary (array a)`
*/
function arrayArb(arb) {
  return array.array(arb || json.json);
}

/**
  - `nearray(arb: arbitrary a): arbitrary (array a)`
*/
function nearrayArb(arb) {
  return array.nearray(arb || json.json);
}

/**
  - `json: arbitrary json`

       JavaScript Objects: boolean, number, string, array of `json` values or object with `json` values.
*/
var jsonArb = json.json;

/**
  - `oneof(gs : array (arbitrary a)...) : arbitrary a`

      Randomly uses one of the given arbitraries.
*/
function oneof() {
  assert(arguments.length !== 0, "oneof: at least one parameter expected");

  // TODO: write this in more functional way
  var generators = [];
  var append = function (a) {
    generators.push(utils.force(a).generator);
  };
  for (var i = 0; i < arguments.length; i++) {
    var arg = arguments[i];
    if (utils.isArray(arg)) {
      arg.forEach(append);
    } else {
      append(arg);
    }
  }

  return arbitraryBless({
    generator: generator.oneof(generators),
    // TODO: make shrink
    shrink: shrink.noop,
    show: show.def,
  });
}

function recursive(arbZ, arbS) {
  var genZ = arbZ.generator;
  var genS = function (recGen) {
    var recArb = arbitraryBless({
      generator: recGen,
      shrink: shrink.noop,
      show: show.def,
    });
    return arbS(recArb).generator;
  };

  var gen = generator.recursive(genZ, genS);
  return arbitraryBless({
    generator: gen,
    shrink: shrink.noop,
    show: show.def,
  });
}

module.exports = {
  nonshrink: nonshrink,
  pair: pairArb,
  either: either,
  unit: unit,
  dict: dictArb,
  json: jsonArb,
  nearray: nearrayArb,
  array: arrayArb,
  tuple: tuple,
  sum: sum,
  oneof: oneof,
  recursive: recursive,
};

},{"./arbitraryAssert.js":356,"./arbitraryBless.js":357,"./array.js":358,"./dict.js":360,"./generator.js":366,"./json.js":367,"./pair.js":369,"./show.js":374,"./shrink.js":375,"./utils.js":381,"assert":54}],356:[function(require,module,exports){
"use strict";

var assert = require("assert");

function arbitraryAssert(arb) {
  assert(arb !== undefined && arb !== null && typeof arb === "object", "arb should be an object");
  assert(typeof arb.generator === "function" && typeof arb.generator.map === "function",
    "arb.generator should be a function");
  assert(typeof arb.shrink === "function" && typeof arb.shrink.smap === "function",
    "arb.shrink should be a function");
  assert(typeof arb.show === "function", "arb.show should be a function");
  assert(typeof arb.smap === "function", "arb.smap should be a function");
}

module.exports = arbitraryAssert;

},{"assert":54}],357:[function(require,module,exports){
"use strict";

var show = require("./show.js");

/**
  ### Arbitrary data
*/

// Blessing: i.e adding prototype
/* eslint-disable no-use-before-define */
function arbitraryProtoSMap(f, g, newShow) {
  /* jshint validthis:true */
  var arb = this; // eslint-disable-line no-invalid-this
  return arbitraryBless({
    generator: arb.generator.map(f),
    shrink: arb.shrink.smap(f, g),
    show: newShow || show.def,
  });
}
/* eslint-enable no-use-before-define */

/**
  - `.smap(f: a -> b, g: b -> a, newShow: (b -> string)?): arbitrary b`

      Transform `arbitrary a` into `arbitrary b`. For example:

      `g` should be a [right inverse](http://en.wikipedia.org/wiki/Surjective_function#Surjections_as_right_invertible_functions) of `f`, but doesn't need to be complete inverse.
      i.e. i.e. `f` doesn't need to be invertible, only surjective.

      ```js
      var positiveIntegersArb = nat.smap(
        function (x) { return x + 1; },
        function (x) { return x - 1; });
      ```

      ```js
      var setNatArb =  jsc.array(jsc.nat).smap(_.uniq, _.identity);
      ```

      Right inverse means that *f(g(y)) = y* for all *y* in *Y*. Here *Y* is a type of **arrays of unique natural numbers**. For them
      ```js
      _.uniq(_.identity(y)) = _.uniq(y) = y
      ```

      Opposite: *g(f(x))* for all *x* in *X*, doesn't need to hold. *X* is **arrays of natural numbers**:
      ```js
      _.identity(_uniq([0, 0])) = [0]] != [0, 0]
      ```

      We need an inverse for shrinking, and there right inverse is enough. We can always *pull back* `smap`ped value and shrink the preimage, and *map* or *push forward* shrinked preimages again.
*/
function arbitraryBless(arb) {
  arb.smap = arbitraryProtoSMap;
  return arb;
}

module.exports = arbitraryBless;

},{"./show.js":374}],358:[function(require,module,exports){
"use strict";

var arbitraryAssert = require("./arbitraryAssert.js");
var arbitraryBless = require("./arbitraryBless.js");
var generator = require("./generator.js");
var show = require("./show.js");
var shrink = require("./shrink.js");
var utils = require("./utils.js");

function makeArray(flavour) {
  return function arrayImpl(arb) {
    arb = utils.force(arb);

    arbitraryAssert(arb);

    return arbitraryBless({
      generator: generator[flavour](arb.generator),
      shrink: shrink[flavour](arb.shrink),
      show: show.array(arb.show),
    });
  };
}

var array = makeArray("array");
var nearray = makeArray("nearray");

module.exports = {
  array: array,
  nearray: nearray,
};

},{"./arbitraryAssert.js":356,"./arbitraryBless.js":357,"./generator.js":366,"./show.js":374,"./shrink.js":375,"./utils.js":381}],359:[function(require,module,exports){
"use strict";

var assert = require("assert");

var arbitraryBless = require("./arbitraryBless.js");
var generator = require("./generator.js");
var show = require("./show.js");
var shrink = require("./shrink.js");

/**
  - `bless(arb: {...}): arbitrary a`

    Bless almost arbitrary structure to be proper arbitrary. *Note*: this function mutates argument.

    #### Example:

    ```js
    var arbTokens = jsc.bless({
      generator: function () {
        switch (jsc.random(0, 2)) {
          case 0: return "foo";
          case 1: return "bar";
          case 2: return "quux";
        }
      }
    });
    ```
*/
function bless(arb) {
  assert(arb !== null && typeof arb === "object", "bless: arb should be an object");
  assert(typeof arb.generator === "function", "bless: arb.generator should be a function");

  // default shrink
  if (typeof arb.shrink !== "function") {
    arb.shrink = shrink.noop;
  }

  // default show
  if (typeof arb.show !== "function") {
    arb.show = show.def;
  }

  generator.bless(arb.generator);
  shrink.bless(arb.shrink);

  arbitraryBless(arb);
  return arb;
}

module.exports = bless;

},{"./arbitraryBless.js":357,"./generator.js":366,"./show.js":374,"./shrink.js":375,"assert":54}],360:[function(require,module,exports){
/* @flow weak */
"use strict";

var arbitraryAssert = require("./arbitraryAssert.js");
var array = require("./array.js");
var pair = require("./pair.js");
var string = require("./string.js");
var utils = require("./utils.js");

function makeMapShow(elShow) {
  return function (m) {
    return "{" + Object.keys(m).map(function (k) {
      return k + ": " + elShow(m[k]);
    }).join(", ") + "}";
  };
}

function dict(arb) {
  arb = utils.force(arb);
  arbitraryAssert(arb);

  var pairArbitrary = pair.pair(string.string, arb);
  var arrayArbitrary = array.array(pairArbitrary);

  return arrayArbitrary.smap(utils.pairArrayToDict, utils.dictToPairArray, makeMapShow(arb.show));
}

module.exports = {
  dict: dict,
};

},{"./arbitraryAssert.js":356,"./array.js":358,"./pair.js":369,"./string.js":377,"./utils.js":381}],361:[function(require,module,exports){
"use strict";

var assert = require("assert");

/**
  ### either
*/

function Left(value) {
  this.value = value;
}

function Right(value) {
  this.value = value;
}

/**
  - `either.left(value: a): either a b`
*/
function left(value) {
  return new Left(value);
}

/**
  - `either.right(value: b): either a b`
*/
function right(value) {
  return new Right(value);
}

/**
  - `either.either(l: a -> x, r: b -> x): x`
*/
Left.prototype.either = function lefteither(l) {
  return l(this.value);
};

Right.prototype.either = function righteither(l, r) {
  return r(this.value);
};

/**
  - `either.isEqual(other: either a b): bool`

      TODO: add `eq` optional parameter
*/
Left.prototype.isEqual = function leftIsEqual(other) {
  assert(other instanceof Left || other instanceof Right, "isEqual: `other` parameter should be either");
  return other instanceof Left && this.value === other.value;
};

Right.prototype.isEqual = function rightIsEqual(other) {
  assert(other instanceof Left || other instanceof Right, "isEqual: `other` parameter should be either");
  return other instanceof Right && this.value === other.value;
};

/**
  - `either.bimap(f: a -> c, g: b -> d): either c d`

      ```js
      either.bimap(compose(f, g), compose(h, i)) â‰¡ either.bimap(g, i).bimap(f, h);
      ```

*/
Left.prototype.bimap = function leftBimap(f) {
  return new Left(f(this.value));
};

Right.prototype.bimap = function rightBimap(f, g) {
  return new Right(g(this.value));
};

/**
  - `either.first(f: a -> c): either c b`

      ```js
      either.first(f) â‰¡ either.bimap(f, utils.identity)
      ```
*/
Left.prototype.first = function leftFirst(f) {
  return new Left(f(this.value));
};

Right.prototype.first = function rightFirst() {
  return this;
};

/**
  - `either.second(g: b -> d): either a d`

      ```js
      either.second(g) === either.bimap(utils.identity, g)
      ```
*/
Left.prototype.second = function leftSecond() {
  return this;
};

Right.prototype.second = function rightSecond(g) {
  return new Right(g(this.value));
};

module.exports = {
  left: left,
  right: right,
};

},{"assert":54}],362:[function(require,module,exports){
/* @flow weak */
"use strict";

var arbitrary = require("./arbitrary.js");
var fn = require("./fn.js");
var primitive = require("./primitive.js");
var small = require("./small.js");
var string = require("./string.js");
var utils = require("./utils.js");

var environment = utils.merge(primitive, string, {
  pair: arbitrary.pair,
  unit: arbitrary.unit,
  either: arbitrary.either,
  dict: arbitrary.dict,
  array: arbitrary.array,
  nearray: arbitrary.nearray,
  json: arbitrary.json,
  fn: fn.fn,
  fun: fn.fn,
  nonshrink: arbitrary.nonshrink,
  small: small.arbitrary,
});

module.exports = environment;

},{"./arbitrary.js":355,"./fn.js":364,"./primitive.js":370,"./small.js":376,"./string.js":377,"./utils.js":381}],363:[function(require,module,exports){
/* @flow weak */
"use strict";

var utils = require("./utils.js");

/*
  #### FMap (eq : a -> a -> bool) : FMap a

  Finite map, with any object a key.

  Short summary of member functions:

  - FMap.insert (key : a) (value : any) : void
  - FMap.get (key : a) : any
  - FMap.contains (key : a) : obool
*/
function FMap(eq) {
  this.eq = eq || utils.isEqual;
  this.data = [];
}

FMap.prototype.contains = function FMapContains(key) {
  for (var i = 0; i < this.data.length; i++) {
    if (this.eq(this.data[i][0], key)) {
      return true;
    }
  }

  return false;
};

FMap.prototype.insert = function FMapInsert(key, value) {
  for (var i = 0; i < this.data.length; i++) {
    if (this.eq(this.data[i][0], key)) {
      this.data[i] = [key, value];
      return;
    }
  }

  this.data.push([key, value]);
};

FMap.prototype.get = function FMapGet(key) { // eslint-disable-line consistent-return
  for (var i = 0; i < this.data.length; i++) {
    if (this.eq(this.data[i][0], key)) {
      return this.data[i][1];
    }
  }
};

module.exports = FMap;

},{"./utils.js":381}],364:[function(require,module,exports){
/* @flow weak */
"use strict";

var arbitraryBless = require("./arbitraryBless.js");
var generator = require("./generator.js");
var FMap = require("./finitemap.js");
var json = require("./json.js");
var shrink = require("./shrink.js");
var utils = require("./utils.js");

/**
  ### Arbitrary functions

  - `fn(arb: arbitrary a): arbitrary (b -> a)`
  - `fun(arb: arbitrary a): arbitrary (b -> a)`
*/

function fn(arb) {
  arb = utils.force(arb || json.json);

  return arbitraryBless({
    generator: generator.bless(function (size) {
      var m = new FMap();

      var f = function (arg) {
        if (!m.contains(arg)) {
          var value = arb.generator(size);
          m.insert(arg, value);
        }

        return m.get(arg);
      };

      f.internalMap = m;
      return f;
    }),

    shrink: shrink.noop,
    show: function (f) {
      return "[" + f.internalMap.data.map(function (item) {
        return "" + item[0] + ": " + arb.show(item[1]);
      }).join(", ") + "]";
    },
  });
}

module.exports = {
  fn: fn,
  fun: fn,
};

},{"./arbitraryBless.js":357,"./finitemap.js":363,"./generator.js":366,"./json.js":367,"./shrink.js":375,"./utils.js":381}],365:[function(require,module,exports){
/* @flow weak */
"use strict";

var trampa = require("trampa");

/**
  #### isPromise p : bool

  Optimistic duck-type check for promises.
  Returns `true` if p is an object with `.then` function property.
*/
function isPromise(p) {
  /* eslint-disable no-new-object */
  return new Object(p) === p && typeof p.then === "function";
  /* eslint-enable non-new-object */
}

/**
  #### map (Functor f) => (p : f a) (g : a -> b) : f b

  This is functor map, known as `map` or `fmap`.
  Essentially `f(p)`. If `p` is promise, returns new promise.
  Using `map` makes code look very much [CPS-style](http://en.wikipedia.org/wiki/Continuation-passing_style).
*/
function map(p, g) {
  if (isPromise(p)) {
    return p.then(function (x) {
      return map(x, g);
    });
  } else if (trampa.isTrampoline(p)) {
    return p.jump(function (x) {
      return map(x, g);
    });
  } else {
    return g(p);
  }
}

/**
  #### bind (Functor f) => (k : a -> f b) (xs : a) (h : b -> f c) -> f c

  This is almost monadic bind.
*/
function bind(f, xs, h) {
  var r;
  var exc;
  try {
    r = f.apply(undefined, xs);
  } catch (e) {
    r = false;
    exc = e;
  }

  if (isPromise(r)) {
    return r.then(
      h,
      function (e) {
        // exc is always unset here
        return h(false, e);
      }
    );
  } else {
    return h(r, exc);
  }
}

// recursively unwrap trampoline and promises
function run(x) {
  if (isPromise(x)) {
    return x.then(run);
  } else if (trampa.isTrampoline(x)) {
    return run(x.run());
  } else {
    return x;
  }
}

function pure(x) {
  if (isPromise(x)) {
    return x;
  } else {
    return trampa.wrap(x);
  }
}

module.exports = {
  isPromise: isPromise,
  map: map,
  pure: pure,
  bind: bind,
  run: run,
};

},{"trampa":395}],366:[function(require,module,exports){
/* @flow weak */
"use strict";

var assert = require("assert");
var either = require("./either.js");
var random = require("./random.js");
var sum = require("./sum.js");
var utils = require("./utils.js");

/**
  ### Generator functions

  A generator function, `generator a`, is a function `(size: nat) -> a`, which generates a value of given size.

  Generator combinators are auto-curried:

  ```js
  var xs = jsc.generator.array(jsc.nat.generator, 1); // â‰¡
  var ys = jsc.generator.array(jsc.nat.generator)(1);
  ```

  In purely functional approach `generator a` would be explicitly stateful computation:
  `(size: nat, rng: randomstate) -> (a, randomstate)`.
  *JSVerify* uses an implicit random number generator state,
  but the value generation is deterministic (tests reproduceable),
  if the primitives from *random* module are used.
*/

// Blessing: i.e adding prototype
/* eslint-disable no-use-before-define */
function generatorProtoMap(f) {
  /* jshint validthis:true */
  var generator = this; // eslint-disable-line no-invalid-this
  generatorAssert(generator);
  return generatorBless(function (size) {
    return f(generator(size));
  });
}

function generatorProtoFlatMap(f) {
  /* jshint validthis:true */
  var generator = this; // eslint-disable-line no-invalid-this
  generatorAssert(generator);
  return generatorBless(function (size) {
    return f(generator(size))(size);
  });
}
/* eslint-enable no-use-before-define */

function generatorAssert(generator) {
  assert(typeof generator === "function", "generator should be a function");
  assert(generator.map === generatorProtoMap, "generator.map should be a function");
  assert(generator.flatmap === generatorProtoFlatMap, "generator.flatmap should be a function");
  assert(generator.flatMap === generatorProtoFlatMap, "generator.flatMap should be a function");
}

/**
  - `generator.bless(f: nat -> a): generator a`

      Bless function with `.map` and `.flatmap` properties.

  - `.map(f: a -> b): generator b`

      Map `generator a` into `generator b`. For example:

      ```js
      positiveIntegersGenerator = nat.generator.map(
        function (x) { return x + 1; });
      ```

  - `.flatmap(f: a -> generator b): generator b`

      Monadic bind for generators. Also `flatMap` version is supported.
*/
function generatorBless(generator) {
  generator.map = generatorProtoMap;
  generator.flatmap = generatorProtoFlatMap;
  generator.flatMap = generatorProtoFlatMap;
  return generator;
}

/**
  - `generator.constant(x: a): generator a`
*/
function generateConstant(x) {
  return generatorBless(function () {
    return x;
  });
}

/**
  - `generator.combine(gen: generator a..., f: a... -> b): generator b`
*/
function generatorCombine() {
  var generators = Array.prototype.slice.call(arguments, 0, -1);
  var f = arguments[arguments.length - 1];

  return generatorBless(function (size) {
    var values = generators.map(function (gen) {
      return gen(size);
    });

    return f.apply(undefined, values);
  });
}

/**
  - `generator.oneof(gens: list (generator a)): generator a`
*/
function generateOneof(generators) {
  // TODO: generator
  generators.forEach(function (gen) {
    assert(typeof gen === "function");
  });

  var result = generatorBless(function (size) {
    var idx = random(0, generators.length - 1);
    var gen = generators[idx];
    return gen(size);
  });

  return utils.curried2(result, arguments);
}

// Helper, essentially: log2(size + 1)
function logsize(size) {
  return Math.max(Math.round(Math.log(size + 1) / Math.log(2), 0));
}

/**
  - `generator.recursive(genZ: generator a, genS: generator a -> generator a): generator a`
*/
function generatorRecursive(genZ, genS) {
  return generatorBless(function (size) {
    function rec(n, sizep) {
      if (n <= 0 || random(0, 3) === 0) {
        return genZ(sizep);
      } else {
        return genS(generatorBless(function (sizeq) {
          return rec(n - 1, sizeq);
        }))(sizep);
      }
    }

    return rec(logsize(size), size);
  });
}

/**
  - `generator.pair(genA: generator a, genB: generator b): generator (a, b)`
*/
function generatePair(genA, genB) {
  var result = generatorBless(function (size) {
    return [genA(size), genB(size)];
  });

  return utils.curried3(result, arguments);
}

/**
  - `generator.either(genA: generator a, genB: generator b): generator (either a b)`
*/
function generateEither(genA, genB) {
  var result = generatorBless(function (size) { // eslint-disable-line consistent-return
    var n = random(0, 1);
    switch (n) {
      case 0: return either.left(genA(size));
      case 1: return either.right(genB(size));
      // no default
    }
  });

  return utils.curried3(result, arguments);
}
/**
  - `generator.unit: generator ()`

      `unit` is an empty tuple, i.e. empty array in JavaScript representation. This is useful as a building block.
*/
var generateUnit = generatorBless(function () {
  return [];
});

/**
  - `generator.tuple(gens: (generator a, generator b...)): generator (a, b...)`
*/
function generateTuple(gens) {
  var len = gens.length;
  var result = generatorBless(function (size) {
    var r = [];
    for (var i = 0; i < len; i++) {
      r[i] = gens[i](size);
    }
    return r;
  });

  return utils.curried2(result, arguments);
}

/**
  - `generator.sum(gens: (generator a, generator b...)): generator (a | b...)`
*/
function generateSum(gens) {
  var len = gens.length;
  var result = generatorBless(function (size) {
    var idx = random(0, len - 1);
    return sum.addend(idx, len, gens[idx](size));
  });

  return utils.curried2(result, arguments);
}

/**
   - `generator.array(gen: generator a): generator (array a)`
*/
function generateArray(gen) {
  var result = generatorBless(function (size) {
    var arrsize = random(0, logsize(size));
    var arr = new Array(arrsize);
    for (var i = 0; i < arrsize; i++) {
      arr[i] = gen(size);
    }
    return arr;
  });

  return utils.curried2(result, arguments);
}

/**
   - `generator.nearray(gen: generator a): generator (array a)`
*/
function generateNEArray(gen) {
  var result = generatorBless(function (size) {
    var arrsize = random(1, Math.max(logsize(size), 1));
    var arr = new Array(arrsize);
    for (var i = 0; i < arrsize; i++) {
      arr[i] = gen(size);
    }
    return arr;
  });

  return utils.curried2(result, arguments);
}

/**
  - `generator.dict(gen: generator a): generator (dict a)`
*/
function generateDict(gen) {
  // Circular dependency :(
  var string = require("./string.js");

  var pairGen = generatePair(string.string.generator, gen);
  var arrayGen = generateArray(pairGen);
  var result = arrayGen.map(utils.pairArrayToDict);

  return utils.curried2(result, arguments);
}

function generateJson(size) {
  return require("./json.js").json.generator(size);
}

module.exports = {
  pair: generatePair,
  either: generateEither,
  unit: generateUnit,
  tuple: generateTuple,
  sum: generateSum,
  array: generateArray,
  nearray: generateNEArray,
  dict: generateDict,
  json: generateJson,
  oneof: generateOneof,
  constant: generateConstant,
  bless: generatorBless,
  combine: generatorCombine,
  recursive: generatorRecursive,
};

},{"./either.js":361,"./json.js":367,"./random.js":371,"./string.js":377,"./sum.js":379,"./utils.js":381,"assert":54}],367:[function(require,module,exports){
"use strict";

var assert = require("assert");

var arbitraryBless = require("./arbitraryBless.js");
var generator = require("./generator.js");
var primitive = require("./primitive.js");
var show = require("./show.js");
var shrink = require("./shrink.js");
var string = require("./string.js");
var utils = require("./utils.js");

var generateInteger = primitive.integer.generator;
var generateNumber = primitive.number.generator;
var generateBool = primitive.bool.generator;
var generateString = string.string.generator;

var generateJson = generator.recursive(
  generator.oneof([generateInteger, generateNumber, generateBool, generateString]),
  function (gen) {
    return generator.oneof([generator.array(gen), generator.dict(gen)]);
  });

// Forward declaration
var shrinkDictJson;
var shrinkJson;

function shrinkRecJson(json) {
  if (Array.isArray(json)) {
    return shrink.array(shrinkJson, json);
  } else {
    return shrinkDictJson(json);
  }
}

shrinkJson = shrink.bless(function (json) {
  assert(typeof json !== "function");

  switch (typeof json) {
    case "boolean": return primitive.bool.shrink(json);
    case "number": return primitive.number.shrink(json);
    case "string": return string.string.shrink(json);
    default: return shrinkRecJson(json);
  }
});

shrinkDictJson = (function () {
  var pairShrink = shrink.pair(string.string.shrink, shrinkJson);
  var arrayShrink = shrink.array(pairShrink);

  return arrayShrink.smap(utils.pairArrayToDict, utils.dictToPairArray);
}());

var json = arbitraryBless({
  generator: generateJson,
  shrink: shrinkJson,
  show: show.def,
});

module.exports = {
  json: json,
};

},{"./arbitraryBless.js":357,"./generator.js":366,"./primitive.js":370,"./show.js":374,"./shrink.js":375,"./string.js":377,"./utils.js":381,"assert":54}],368:[function(require,module,exports){
(function (process){
/* @flow weak */
/**
  # JSVerify

  <img src="https://raw.githubusercontent.com/jsverify/jsverify/master/jsverify-300.png" align="right" height="100" />

  > Property based checking. Like QuickCheck.

  [![Build Status](https://secure.travis-ci.org/jsverify/jsverify.svg?branch=master)](http://travis-ci.org/jsverify/jsverify)
  [![NPM version](https://badge.fury.io/js/jsverify.svg)](http://badge.fury.io/js/jsverify)
  [![Dependency Status](https://david-dm.org/jsverify/jsverify.svg)](https://david-dm.org/jsverify/jsverify)
  [![devDependency Status](https://david-dm.org/jsverify/jsverify/dev-status.svg)](https://david-dm.org/jsverify/jsverify#info=devDependencies)
  [![Code Climate](https://img.shields.io/codeclimate/github/jsverify/jsverify.svg)](https://codeclimate.com/github/jsverify/jsverify)

  ## Getting Started

  Install the module with: `npm install jsverify`

  ## Synopsis

  ```js
  var jsc = require("jsverify");

  // forall (f : bool -> bool) (b : bool), f (f (f b)) = f(b).
  var boolFnAppliedThrice =
    jsc.forall("bool -> bool", "bool", function (f, b) {
      return f(f(f(b))) === f(b);
    });

  jsc.assert(boolFnAppliedThrice);
  // OK, passed 100 tests
  ```
*/
"use strict";

/**
  ## Documentation

  ### Usage with [mocha](http://visionmedia.github.io/mocha/)

  Using jsverify with mocha is easy, just define the properties and use `jsverify.assert`.

  Starting from version 0.4.3 you can write your specs without any boilerplate:

  ```js
  describe("sort", function () {
    jsc.property("idempotent", "array nat", function (arr) {
      return _.isEqual(sort(sort(arr)), sort(arr));
    });
  });
  ```

  You can also provide `--jsverifyRngState state` command line argument, to run tests with particular random generator state.

  ```
  $ mocha examples/nat.js

  1) natural numbers are less than 90:
   Error: Failed after 49 tests and 1 shrinks. rngState: 074e9b5f037a8c21d6; Counterexample: 90;

  $ mocha examples/nat.js --grep 'are less than' --jsverifyRngState 074e9b5f037a8c21d6

  1) natural numbers are less than 90:
     Error: Failed after 1 tests and 1 shrinks. rngState: 074e9b5f037a8c21d6; Counterexample: 90;
  ```

  Errorneous case is found with first try.

  ### Usage with [jasmine](http://pivotal.github.io/jasmine/)

  Check [jasmineHelpers.js](helpers/jasmineHelpers.js) and [jasmineHelpers2.js](helpers/jasmineHelpers2.js) for jasmine 1.3 and 2.0 respectively.

  ## API Reference

  > _Testing shows the presence, not the absence of bugs._
  >
  > Edsger W. Dijkstra

  To show that propositions hold, we need to construct proofs.
  There are two extremes: proof by example (unit tests) and formal (machine-checked) proof.
  Property-based testing is somewhere in between.
  We formulate propositions, invariants or other properties we believe to hold, but
  only test it to hold for numerous (randomly generated) values.

  Types and function signatures are written in [Coq](http://coq.inria.fr/)/[Haskell](http://www.haskell.org/haskellwiki/Haskell) influented style:
  C# -style `List<T> filter(List<T> v, Func<T, bool> predicate)` is represented by
  `filter(v: array T, predicate: T -> bool): array T` in our style.

  Methods and objects live in `jsc` object, e.g. `shrink.bless` method is used by
  ```js
  var jsc = require("jsverify");
  var foo = jsc.shrink.bless(...);
  ```

  Methods starting with `.dot` are prototype methods:
  ```js
  var arb = jsc.nat;
  var arb2 = jsc.nat.smap(f, g);
  ```

  `jsverify` can operate with both synchronous and asynchronous-promise properties.
  Generally every property can be wrapped inside [functor](http://learnyouahaskell.com/functors-applicative-functors-and-monoids),
  for now in either identity or promise functor, for synchronous and promise properties respectively.
*/

var assert = require("assert");
var lazyseq = require("lazy-seq");

var api = require("./api.js");
var either = require("./either.js");
var environment = require("./environment.js");
var FMap = require("./finitemap.js");
var fn = require("./fn.js");
var functor = require("./functor.js");
var random = require("./random.js");
var show = require("./show.js");
var shrink = require("./shrink.js");
var suchthat = require("./suchthat.js");
var sum = require("./sum.js");
var typify = require("./typify.js");
var utils = require("./utils.js");

/**
  ### Properties
*/

function shrinkResult(arbs, x, test, size, shrinksN, exc, transform) {
  assert(arbs.length === x.length, "shrinkResult: arbs and x has to be of same size");
  assert(typeof size === "number", "shrinkResult: size should be number");
  assert(typeof shrinksN === "number", "shrinkResult: shrinkN should be number");

  var shrinks = utils.pluck(arbs, "shrink");
  var shows = utils.pluck(arbs, "show");

  var shrinked = shrink.tuple(shrinks, x);

  var shrinkP = lazyseq.fold(shrinked, true, function (y, rest) {
    var t = test(size, y, shrinksN + 1);
    return functor.map(t, function (tprime) {
      return tprime !== true ? tprime : rest();
    });
  });

  return functor.map(shrinkP, function (shrinkPPrime) {
    if (shrinkPPrime === true) {
      var res = {
        counterexample: x,
        counterexamplestr: show.tuple(shows, x),
        shrinks: shrinksN,
        exc: exc,
      };
      return transform(res);
    } else {
      return shrinkPPrime;
    }
  });
}

function isArbitrary(arb) {
  return (typeof arb === "object" || typeof arb === "function") &&
    typeof arb.generator === "function" &&
    typeof arb.shrink === "function" &&
    typeof arb.show === "function";
}

/**
  - `forall(arbs: arbitrary a ..., userenv: (map arbitrary)?, prop : a -> property): property`

      Property constructor
*/
function forall() {
  var args = Array.prototype.slice.call(arguments);
  var gens = args.slice(0, -1);
  var property = args[args.length - 1];
  var env;

  var lastgen = gens[gens.length - 1];

  if (!isArbitrary(lastgen) && typeof lastgen !== "string") {
    env = utils.merge(environment, lastgen);
    gens = gens.slice(0, -1);
  } else {
    env = environment;
  }

  assert(gens.length > 0, "forall requires at least single generator");

  // Map typify-dsl to hard generators
  gens = gens.map(function (g) {
    g = typeof g === "string" ? typify.parseTypify(env, g) : g;
    return utils.force(g);
  });

  assert(typeof property === "function", "property should be a function");

  function test(size, x, shrinks) {
    assert(Array.isArray(x), "generators results should be always tuple");

    return functor.bind(property, x, function (r, exc) {
      if (r === true) {
        return true;
      } else if (typeof r === "function") {
        var rRec = r(size);

        return functor.map(rRec, function (rRecPrime) {
          if (rRecPrime === true) {
            return true;
          } else {
            return shrinkResult(gens, x, test, size, shrinks, exc, function (rr) {
              return {
                counterexample: rr.counterexample.concat(rRecPrime.counterexample),
                counterexamplestr: rr.counterexamplestr, // + "; " + rRec.counterexamplestr,
                shrinks: rr.shrinks,
                exc: rr.exc || rRecPrime.exc,
              };
            });
          }
        });
      } else {
        return shrinkResult(gens, x, test, size, shrinks, exc || r, utils.identity);
      }
    });
  }

  return function (size) {
    var x = gens.map(function (arb) { return arb.generator(size); });
    var r = test(size, x, 0);
    return r;
  };
}

function formatFailedCase(r, state, includeStack) {
  var msg = "Failed after " + r.tests + " tests and " + r.shrinks + " shrinks. ";
  msg += "rngState: " + (r.rngState || state) + "; ";
  msg += "Counterexample: " + r.counterexamplestr + "; ";
  if (r.exc) {
    if (r.exc instanceof Error) {
      msg += "Exception: " + r.exc.message;
      if (includeStack) {
        msg += "\nStack trace: " + r.exc.stack;
      }
    } else {
      msg += "Error: " + r.exc;
    }
  }
  return msg;
}

function findRngState(argv) { // eslint-disable-line consistent-return
  for (var i = 0; i < argv.length - 1; i++) {
    if (argv[i] === "--jsverifyRngState") {
      return argv[i + 1];
    }
  }
}

/**
  - `check (prop: property, opts: checkoptions?): result`

      Run random checks for given `prop`. If `prop` is promise based, result is also wrapped in promise.

      Options:
      - `opts.tests` - test count to run, default 100
      - `opts.size`  - maximum size of generated values, default 50
      - `opts.quiet` - do not `console.log`
      - `opts.rngState` - state string for the rng

      The `result` is `true` if check succeeds, otherwise it's an object with various fields:
      - `counterexample` - an input for which property fails.
      - `tests` - number of tests run before failing case is found
      - `shrinks` - number of shrinks performed
      - `exc` - an optional exception thrown by property function
      - `rngState` - random number generator's state before execution of the property
*/
function check(property, opts) {
  opts = opts || {};
  opts.size = opts.size || 50;
  opts.tests = opts.tests || 100;
  opts.quiet = opts.quiet || false;

  assert(typeof property === "function", "property should be a function");

  var state;

  if (opts.rngState) {
    random.setStateString(opts.rngState);
  } else if (typeof process !== "undefined") {
    var argvState = findRngState(process.argv);
    if (argvState) {
      random.setStateString(argvState);
    }
  }

  function loop(i) {
    state = random.currentStateString();
    if (i > opts.tests) {
      return true;
    }

    var size = random(0, opts.size);

    // wrap non-promises in trampoline
    var r = functor.pure(property(size));

    return functor.map(r, function (rPrime) {
      if (rPrime === true) {
        return loop(i + 1);
      } else {
        rPrime.tests = i;
        /* global console */
        if (!opts.quiet) {
          console.error(formatFailedCase(rPrime, state, true), rPrime.counterexample);
        }
        return rPrime;
      }
    });
  }

  return functor.run(functor.map(loop(1), function (r) {
    if (r === true) {
      if (!opts.quiet) { console.info("OK, passed " + opts.tests + " tests"); }
    } else {
      r.rngState = state;
    }

    return r;
  }));
}

/**
  - `assert(prop: property, opts: checkoptions?) : void`

      Same as `check`, but throw exception if property doesn't hold.
*/
function checkThrow(property, opts) {
  opts = opts || {};
  if (opts.quiet === undefined) {
    opts.quiet = true;
  }

  return functor.run(functor.map(check(property, opts), function (r) {
    if (r !== true) {
      if (r.exc instanceof Error) {
        r.exc.message = formatFailedCase(r);
        throw r.exc;
      } else {
        throw new Error(formatFailedCase(r));
      }
    }
  }));
}

/**
   - `property(name: string, ...)`

      Assuming there is globally defined `it`, the same as:

      ```js
      it(name, function () {
        jsc.assert(jsc.forall(...));
      }
      ```

      You can use `property` to write facts too:
      ```js
      jsc.property("+0 === -0", function () {
        return +0 === -0;
      });
      ```
*/
function bddProperty(name) {
  /* global it: true */
  var args = Array.prototype.slice.call(arguments, 1);
  if (args.length === 1) {
    it(name, function () {
      return functor.run(functor.map(args[0](), function (result) { // eslint-disable-line consistent-return
        if (typeof result === "function") {
          return checkThrow(result);
        } else if (result !== true) {
          throw new Error(name + " doesn't hold");
        }
      }));
    });
  } else {
    var prop = forall.apply(undefined, args);
    it(name, function () {
      return checkThrow(prop);
    });
  }
  /* global it: false */
}

/**
  - `compile(desc: string, env: typeEnv?): arbitrary a`

      Compile the type describiption in provided type environment, or default one.
*/
function compile(str, env) {
  env = env ? utils.merge(environment, env) : environment;
  return typify.parseTypify(env, str);
}

/**
  - `sampler(arb: arbitrary a, genSize: nat = 10): (sampleSize: nat?) -> a`

      Create a sampler for a given arbitrary with an optional size. Handy when used in
      a REPL:
      ```
      > jsc = require('jsverify') // or require('./lib/jsverify') w/in the project
      ...
      > jsonSampler = jsc.sampler(jsc.json, 4)
      [Function]
      > jsonSampler()
      0.08467432763427496
      > jsonSampler()
      [ [ [] ] ]
      > jsonSampler()
      ''
      > sampledJson(2)
      [-0.4199344692751765, false]
      ```
*/
function sampler(arb, size) {
  size = typeof size === "number" ? Math.abs(size) : 10;
  return function (count) {
    if (typeof count === "number") {
      var acc = [];
      count = Math.abs(count);
      for (var i = 0; i < count; i++) {
        acc.push(arb.generator(size));
      }
      return acc;
    } else {
      return arb.generator(size);
    }
  };
}

/**
  - `throws(block: () -> a, error: class?, message: string?): bool

    Executes nullary function `block`. Returns `true` if `block` throws. See [assert.throws](https://nodejs.org/api/assert.html#assert_assert_throws_block_error_message)
*/
function throws(block, error, message) {
  assert(error === undefined || typeof error === "function", "throws: error parameter must be a constructor");
  assert(message === undefined || typeof message === "string", "throws: message parameter must be a string");

  try {
    block();
    return false;
  } catch (e) {
    if (error !== undefined) {
      if (e instanceof error) {
        return message === undefined || e.message === message;
      } else {
        return false;
      }
    } else {
      return true;
    }
  }
}

/**
  - `assertForall(arbs: arbitrary a ..., userenv: (map arbitrary)?, prop : a -> property): void`

     Combines 'assert' and 'forall'.
     Constructs a property with forall from arguments, then throws an exception if the property doesn't hold.
     Options for 'assert' cannot be set here - use assert(forall(...)) if you need that.
*/
function assertForall() {
  return checkThrow(forall.apply(null, arguments));
}

/**
  - `checkForall(arbs: arbitrary a ..., userenv: (map arbitrary)?, prop : a -> property): result`

    Combines 'check' and 'forall'.
    Constructs a property with forall from arguments, and returns a value based on if the property holds or not.
    See 'check' for description of return value.

    Options for 'check' cannot be set here - use check(forall(...)) if you need that.
*/
function checkForall() {
  return check(forall.apply(null, arguments));
}

/**
  ### Types

  - `generator a` is a function `(size: nat) -> a`.
  - `show` is a function `a -> string`.
  - `shrink` is a function `a -> [a]`, returning *smaller* values.
  - `arbitrary a` is a triple of generator, shrink and show functions.
      - `{ generator: nat -> a, shrink : a -> array a, show: a -> string }`

  ### Blessing

  We chose to respresent generators and shrinks by functions, yet we would
  like to have additional methods on them. Thus we *bless* objects with
  additional properties.

  Usually you don't need to bless anything explicitly, as all combinators
  return blessed values.

  See [perldoc for bless](http://perldoc.perl.org/functions/bless.html).
*/

/// include ./typify.js
/// include ./arbitraryBless.js
/// include ./bless.js
/// include ./primitive.js
/// include ./arbitrary.js
/// include ./recordWithEnv.js
/// include ./record.js
/// include ./string.js
/// include ./fn.js
/// include ./small.js
/// include ./generator.js
/// include ./shrink.js
/// include ./show.js
/// include ./random.js
/// include ./either.js
/// include ./utils.js

// Export
var jsc = {
  forall: forall,
  check: check,
  assert: checkThrow,
  assertForall: assertForall,
  checkForall: checkForall,
  property: bddProperty,
  sampler: sampler,
  throws: throws,

  // generators
  fn: fn.fn,
  fun: fn.fn,
  suchthat: suchthat.suchthat,

  // either
  left: either.left,
  right: either.right,

  // sum
  addend: sum.addend,

  // compile
  compile: compile,

  generator: api.generator,
  shrink: api.shrink,

  // internal utility lib
  random: random,

  show: show,
  utils: utils,
  _: {
    FMap: FMap,
  },
};

/* primitives */
/* eslint-disable guard-for-in */
for (var k in api.arbitrary) {
  jsc[k] = api.arbitrary[k];
}
/* eslint-enable guard-for-in */

module.exports = jsc;

/// plain ../FAQ.md
/// plain ../CONTRIBUTING.md
/// plain ../CHANGELOG.md
/// plain ../related-work.md
/// plain ../LICENSE

}).call(this,require('_process'))
},{"./api.js":354,"./either.js":361,"./environment.js":362,"./finitemap.js":363,"./fn.js":364,"./functor.js":365,"./random.js":371,"./show.js":374,"./shrink.js":375,"./suchthat.js":378,"./sum.js":379,"./typify.js":380,"./utils.js":381,"_process":391,"assert":54,"lazy-seq":382}],369:[function(require,module,exports){
"use strict";

var arbitraryAssert = require("./arbitraryAssert.js");
var arbitraryBless = require("./arbitraryBless.js");
var generator = require("./generator.js");
var show = require("./show.js");
var shrink = require("./shrink.js");
var utils = require("./utils.js");

function pair(a, b) {
  a = utils.force(a);
  b = utils.force(b);

  arbitraryAssert(a);
  arbitraryAssert(b);

  return arbitraryBless({
    generator: generator.pair(a.generator, b.generator),
    shrink: shrink.pair(a.shrink, b.shrink),
    show: show.pair(a.show, b.show),
  });
}

module.exports = {
  pair: pair,
};

},{"./arbitraryAssert.js":356,"./arbitraryBless.js":357,"./generator.js":366,"./show.js":374,"./shrink.js":375,"./utils.js":381}],370:[function(require,module,exports){
/* @flow weak */
"use strict";

var arbitraryBless = require("./arbitraryBless");
var assert = require("assert");
var generator = require("./generator.js");
var random = require("./random.js");
var show = require("./show.js");
var shrink = require("./shrink.js");
var utils = require("./utils.js");

/**
  ### Primitive arbitraries
*/

function extendWithDefault(arb) {
  var def = arb();
  arb.generator = def.generator;
  arb.shrink = def.shrink;
  arb.show = def.show;
  arb.smap = def.smap;
}

function numeric(impl) {
  return function (minsize, maxsize) {
    if (arguments.length === 2) {
      var arb = arbitraryBless(impl(maxsize - minsize));
      var to = function to(x) {
        return Math.abs(x) + minsize;
      };
      var from = function from(x) {
        return x - minsize;
      };

      return arb.smap(to, from);
    } else if (arguments.length === 1) {
      return arbitraryBless(impl(minsize /* as maxsize */));
    } else {
      return arbitraryBless(impl());
    }
  };
}

/**
  - `integer: arbitrary integer`
  - `integer(maxsize: nat): arbitrary integer`
  - `integer(minsize: integer, maxsize: integer): arbitrary integer`

      Integers, â„¤
*/
var integer = numeric(function integer(maxsize) {
  return {
    generator: generator.bless(function (size) {
      size = maxsize === undefined ? size : maxsize;
      return random(-size, size);
    }),
    shrink: shrink.bless(function (i) {
      assert(typeof i === "number", "integer.shrink have to be a number");

      i = Math.abs(i);
      if (i === 0) {
        return [];
      } else {
        var arr = [0];
        var j = utils.div2(i);
        var k = Math.max(j, 1);
        while (j < i) {
          arr.push(j);
          arr.push(-j);
          k = Math.max(utils.div2(k), 1);
          j += k;
        }
        return arr;
      }
    }),

    show: show.def,
  };
});

extendWithDefault(integer);

/**
  - `nat: arbitrary nat`
  - `nat(maxsize: nat): arbitrary nat`

      Natural numbers, â„• (0, 1, 2...)
*/
function nat(maxsize) {
  return arbitraryBless({
    generator: generator.bless(function (size) {
      size = maxsize === undefined ? size : maxsize;
      return random(0, size);
    }),
    shrink: shrink.bless(function (i) {
      assert(typeof i === "number", "nat.shrink have to be a number");

      var arr = [];
      var j = utils.div2(i);
      var k = Math.max(j, 1);
      while (j < i) {
        arr.push(j);
        k = Math.max(utils.div2(k), 1);
        j += k;
      }
      return arr;
    }),
    show: show.def,
  });
}

extendWithDefault(nat);

/**
  - `number: arbitrary number`
  - `number(maxsize: number): arbitrary number`
  - `number(min: number, max: number): arbitrary number`

      JavaScript numbers, "doubles", â„. `NaN` and `Infinity` are not included.
*/
var number = numeric(function number(maxsize) {
  return {
    generator: generator.bless(function (size) {
      size = maxsize === undefined ? size : maxsize;
      return random.number(-size, size);
    }),
    shrink: shrink.bless(function (x) {
      assert(typeof x === "number", "number.shrink have to be a number");

      if (Math.abs(x) > 1e-6) {
        return [0, x / 2, -x / 2];
      } else {
        return [];
      }
    }),
    show: show.def,
  };
});

extendWithDefault(number);

/**
  - `uint8: arbitrary nat`
  - `uint16: arbitrary nat`
  - `uint32: arbitrary nat`
*/
var uint8 = nat(0xff);
var uint16 = nat(0xffff);
var uint32 = nat(0xffffffff);

/**
  - `int8: arbitrary integer`
  - `int16: arbitrary integer`
  - `int32: arbitrary integer`
*/
var int8 = integer(-0x80, 0x7f);
var int16 = integer(-0x8000, 0x7fff);
var int32 = integer(-0x80000000, 0x7fffffff);

/**
  - `bool: arbitrary bool`

      Booleans, `true` or `false`.
*/
var bool = arbitraryBless({
  generator: generator.bless(function (/* size */) {
    var i = random(0, 1);
    return i === 1;
  }),

  shrink: shrink.bless(function (b) {
    assert(b === true || b === false, "bool.shrink excepts true or false");
    return b === true ? [false] : [];
  }),
  show: show.def,
});

/**
  - `datetime: arbitrary datetime`

      Random datetime
*/
var datetimeConst = 1416499879495; // arbitrary datetime

function datetime(from, to) {
  var toDate;
  var fromDate;
  var arb;

  if (arguments.length === 2) {
    toDate = function toDateFn(x) {
      return new Date(x);
    };
    fromDate = function fromDateFn(x) {
      return x.getTime();
    };
    from = fromDate(from);
    to = fromDate(to);
    arb = number(from, to);

    return arb.smap(toDate, fromDate);
  } else {
    toDate = function toDateFn(x) {
      return new Date(x * 768000000 + datetimeConst);
    };
    arb = number;

    return arbitraryBless({
      generator: arb.generator.map(toDate),
      shrink: shrink.noop,
      show: show.def,
    });
  }
}

extendWithDefault(datetime);

/**
  - `elements(args: array a): arbitrary a`

      Random element of `args` array.
*/
function elements(args) {
  assert(args.length !== 0, "elements: at least one parameter expected");

  return arbitraryBless({
    generator: generator.bless(function (/* size */) {
      var i = random(0, args.length - 1);
      return args[i];
    }),

    shrink: shrink.bless(function (x) {
      var idx = args.indexOf(x);
      if (idx <= 0) {
        return [];
      } else {
        return args.slice(0, idx);
      }
    }),
    show: show.def,
  });
}

/**
  - `falsy: arbitrary *`

      Generates falsy values: `false`, `null`, `undefined`, `""`, `0`, and `NaN`.
*/
var falsy = elements([false, null, undefined, "", 0, NaN]);
falsy.show = function (v) {
  if (v !== v) {
    return "falsy: NaN";
  } else if (v === "") {
    return "falsy: empty string";
  } else if (v === undefined) {
    return "falsy: undefined";
  } else {
    return "falsy: " + v;
  }
};

/**
  - `constant(x: a): arbitrary a`

      Returns an unshrinkable arbitrary that yields the given object.
*/
function constant(x) {
  return arbitraryBless({
    generator: generator.constant(x),
    shrink: shrink.noop,
    show: show.def,
  });
}

module.exports = {
  integer: integer,
  nat: nat,
  int8: int8,
  int16: int16,
  int32: int32,
  uint8: uint8,
  uint16: uint16,
  uint32: uint32,
  number: number,
  elements: elements,
  bool: bool,
  falsy: falsy,
  constant: constant,
  datetime: datetime,
};

},{"./arbitraryBless":357,"./generator.js":366,"./random.js":371,"./show.js":374,"./shrink.js":375,"./utils.js":381,"assert":54}],371:[function(require,module,exports){
/* @flow weak */
"use strict";

var rc4 = new (require("rc4").RC4small)();

/**
  ### Random functions
*/

/**
  - `random(min: int, max: int): int`

      Returns random int from `[min, max]` range inclusively.

      ```js
      getRandomInt(2, 3) // either 2 or 3
      ```
*/
function randomInteger(min, max) {
  return rc4.random(min, max);
}

/**
  - `random.number(min: number, max: number): number`

      Returns random number from `[min, max)` range.
*/
function randomNumber(min, max) {
  return rc4.randomFloat() * (max - min) + min;
}

randomInteger.integer = randomInteger;
randomInteger.number = randomNumber;

randomInteger.currentStateString = rc4.currentStateString.bind(rc4);
randomInteger.setStateString = rc4.setStateString.bind(rc4);

module.exports = randomInteger;

},{"rc4":392}],372:[function(require,module,exports){
"use strict";

var arbitraryBless = require("./arbitraryBless.js");
var generator = require("./generator.js");
var utils = require("./utils.js");
var shrink = require("./shrink.js");

/**
  - `generator.record(gen: { key: generator a... }): generator { key: a... }`
*/
function generatorRecord(spec) {
  var keys = Object.keys(spec);
  var result = generator.bless(function (size) {
    var res = {};
    keys.forEach(function (k) {
      res[k] = spec[k](size);
    });
    return res;
  });

  return utils.curried2(result, arguments);
}

/**
  - `shrink.record(shrs: { key: shrink a... }): shrink { key: a... }`
*/
function shrinkRecord(shrinksRecord) {
  var keys = Object.keys(shrinksRecord);
  var shrinks = keys.map(function (k) { return shrinksRecord[k]; });

  var result = shrink.bless(function (rec) {
    var values = keys.map(function (k) { return rec[k]; });
    var shrinked = shrink.tuple(shrinks, values);

    return shrinked.map(function (s) {
      var res = {};
      keys.forEach(function (k, i) {
        res[k] = s[i];
      });
      return res;
    });
  });

  return utils.curried2(result, arguments);
}

function arbitraryRecord(spec) {
  var generatorSpec = {};
  var shrinkSpec = {};
  var showSpec = {};

  Object.keys(spec).forEach(function (k) {
    var arb = utils.force(spec[k]);
    generatorSpec[k] = arb.generator;
    shrinkSpec[k] = arb.shrink;
    showSpec[k] = arb.show;
  });

  return arbitraryBless({
    generator: generatorRecord(generatorSpec),
    shrink: shrinkRecord(shrinkSpec),
    show: function (m) {
      return "{" + Object.keys(m).map(function (k) {
        return k + ": " + showSpec[k](m[k]);
      }).join(", ") + "}";
    },
  });
}

module.exports = {
  generator: generatorRecord,
  arbitrary: arbitraryRecord,
  shrink: shrinkRecord,
};

},{"./arbitraryBless.js":357,"./generator.js":366,"./shrink.js":375,"./utils.js":381}],373:[function(require,module,exports){
"use strict";

var environment = require("./environment.js");
var record = require("./record.js");
var typify = require("./typify.js");
var utils = require("./utils.js");

/**
  ### Arbitrary records

  - `record(spec: { key: arbitrary a... }, userenv: env?): arbitrary { key: a... }`

      Generates a javascript object with given record spec.
*/
function recordWithEnv(spec, userenv) {
  var env = userenv ? utils.merge(environment, userenv) : environment;

  var parsedSpec = {};
  Object.keys(spec).forEach(function (k) {
    var arb = spec[k];
    parsedSpec[k] = typeof arb === "string" ? typify.parseTypify(env, arb) : arb;
  });

  return record.arbitrary(parsedSpec);
}

module.exports = recordWithEnv;

},{"./environment.js":362,"./record.js":372,"./typify.js":380,"./utils.js":381}],374:[function(require,module,exports){

/* @flow weak */
"use strict";

/**
  ### Show functions
*/

var utils = require("./utils.js");

/**
  - `show.def(x : a): string`

      Currently implemented as `JSON.stringify`.
*/
function showDef(obj) {
  return JSON.stringify(obj);
}

/**
  - `show.pair(showA: a -> string, showB: b -> string, x: (a, b)): string`
*/
function showPair(showA, showB) {
  var result = function (p) {
    return "(" + showA(p[0]) + ", " + showB(p[1]) + ")";
  };

  return utils.curried3(result, arguments);
}

/**
  - `show.either(showA: a -> string, showB: b -> string, e: either a b): string`
*/
function showEither(showA, showB) {
  function showLeft(value) {
    return "Left(" + showA(value) + ")";
  }

  function showRight(value) {
    return "Right(" + showB(value) + ")";
  }

  var result = function (e) {
    return e.either(showLeft, showRight);
  };

  return utils.curried3(result, arguments);
}

/**
  - `show.tuple(shrinks: (a -> string, b -> string...), x: (a, b...)): string`
*/
function showTuple(shows) {
  var result = function (objs) {
    var strs = [];
    for (var i = 0; i < shows.length; i++) {
      strs.push(shows[i](objs[i]));
    }
    return strs.join("; ");
  };

  return utils.curried2(result, arguments);
}

/**
  - `show.sum(shrinks: (a -> string, b -> string...), x: (a | b ...)): string`
*/
function showSum(shows) {
  var result = function (sum) {
    return sum.fold(function (idx, n, value) {
      return "Sum(" + idx + "/" + n + ": " + shows[idx](value) + ")";
    });
  };

  return utils.curried2(result, arguments);
}

/**
  - `show.array(shrink: a -> string, x: array a): string`
*/
function showArray(show) {
  var result = function (arr) {
    return "[" + arr.map(show).join(", ") + "]";
  };

  return utils.curried2(result, arguments);
}

module.exports = {
  def: showDef,
  pair: showPair,
  either: showEither,
  tuple: showTuple,
  sum: showSum,
  array: showArray,
};

},{"./utils.js":381}],375:[function(require,module,exports){
/* @flow weak */
"use strict";

var assert = require("assert");
var either = require("./either.js");
var lazyseq = require("lazy-seq");
var sum = require("./sum.js");
var utils = require("./utils.js");

/**
  ### Shrink functions

  A shrink function, `shrink a`, is a function `a -> [a]`, returning an array of *smaller* values.

  Shrink combinators are auto-curried:

  ```js
  var xs = jsc.shrink.array(jsc.nat.shrink, [1]); // â‰¡
  var ys = jsc.shrink.array(jsc.nat.shrink)([1]);
  ```
*/

// Blessing: i.e adding prototype
/* eslint-disable no-use-before-define */
function shrinkProtoIsoMap(f, g) {
  /* jshint validthis:true */
  var shrink = this; // eslint-disable-line no-invalid-this
  return shrinkBless(function (value) {
    return shrink(g(value)).map(f);
  });
}
/* eslint-enable no-use-before-define */

/**
  - `shrink.bless(f: a -> [a]): shrink a`

      Bless function with `.smap` property.

  - `.smap(f: a -> b, g: b -> a): shrink b`

      Transform `shrink a` into `shrink b`. For example:

      ```js
      positiveIntegersShrink = nat.shrink.smap(
        function (x) { return x + 1; },
        function (x) { return x - 1; });
      ```
*/
function shrinkBless(shrink) {
  shrink.smap = shrinkProtoIsoMap;
  return shrink;
}

/**
  - `shrink.noop: shrink a`
*/
var shrinkNoop = shrinkBless(function shrinkNoop() {
  return [];
});

/**
  - `shrink.pair(shrA: shrink a, shrB: shrink b): shrink (a, b)`
*/
function shrinkPair(shrinkA, shrinkB) {
  var result = shrinkBless(function (pair) {
    assert(pair.length === 2, "shrinkPair: pair should be an Array of length 2");

    var a = pair[0];
    var b = pair[1];

    var shrinkedA = shrinkA(a);
    var shrinkedB = shrinkB(b);

    var pairA = shrinkedA.map(function (ap) {
      return [ap, b];
    });

    if (Array.isArray(pairA)) {
      pairA = lazyseq.fromArray(pairA);
    }

    return pairA.append(function () {
      var pairB = shrinkedB.map(function (bp) {
        return [a, bp];
      });
      return pairB;
    });
  });

  return utils.curried3(result, arguments);
}

/**
  - `shrink.either(shrA: shrink a, shrB: shrink b): shrink (either a b)`
*/
function shrinkEither(shrinkA, shrinkB) {
  function shrinkLeft(value) {
    return shrinkA(value).map(either.left);
  }

  function shrinkRight(value) {
    return shrinkB(value).map(either.right);
  }

  var result = shrinkBless(function (e) {
    return e.either(shrinkLeft, shrinkRight);
  });

  return utils.curried3(result, arguments);
}

// We represent non-empty linked list as
// singl x = [x]
// cons h t = [h, t]
function fromLinkedList(ll) {
  assert(ll.length === 1 || ll.length === 2, "linked list must be either [] or [x, linkedlist]");
  if (ll.length === 1) {
    return [ll[0]];
  } else {
    return [ll[0]].concat(fromLinkedList(ll[1]));
  }
}

function toLinkedList(arr) {
  assert(Array.isArray(arr) && arr.length > 0, "toLinkedList expects non-empty array");
  if (arr.length === 1) {
    return [arr[0]];
  } else {
    return [arr[0], toLinkedList(arr.slice(1))];
  }
}

function toSingleton(x) {
  return [x];
}

// Vec a 1 â†’ a
function fromSingleton(a) {
  return a[0];
}

function flattenShrink(shrinksLL) {
  if (shrinksLL.length === 1) {
    return shrinksLL[0].smap(toSingleton, fromSingleton);
  } else {
    var head = shrinksLL[0];
    var tail = shrinksLL[1];
    return shrinkPair(head, flattenShrink(tail));
  }
}

/**
  - `shrink.tuple(shrs: (shrink a, shrink b...)): shrink (a, b...)`
*/
function shrinkTuple(shrinks) {
  assert(shrinks.length > 0, "shrinkTuple needs > 0 values");
  var shrinksLL = toLinkedList(shrinks);
  var shrink = flattenShrink(shrinksLL);
  var result = shrinkBless(function (tuple) {
    assert(tuple.length === shrinks.length, "shrinkTuple: not-matching params");
    var ll = toLinkedList(tuple);
    return shrink(ll).map(fromLinkedList);
  });

  return utils.curried2(result, arguments);
}

/**
  - `shrink.sum(shrs: (shrink a, shrink b...)): shrink (a | b...)`
*/
function shrinkSum(shrinks) {
  assert(shrinks.length > 0, "shrinkTuple needs > 0 values");
  var result = shrinkBless(function (s) {
    return s.fold(function (idx, len, value) {
      assert(len === shrinks.length, "shrinkSum: not-matching params");
      return shrinks[idx](value).map(function (shrinked) {
        return sum.addend(idx, len, shrinked);
      });
    });
  });

  return utils.curried2(result, arguments);
}

function shrinkArrayWithMinimumSize(size) {
  function shrinkArrayImpl(shrink) {
    var result = shrinkBless(function (arr) {
      assert(Array.isArray(arr), "shrinkArrayImpl() expects array, got: " + arr);
      if (arr.length <= size) {
        return lazyseq.nil;
      } else {
        var x = arr[0];
        var xs = arr.slice(1);

        return lazyseq.cons(xs, lazyseq.nil)
          .append(shrink(x).map(function (xp) { return [xp].concat(xs); }))
          .append(shrinkArrayImpl(shrink, xs).map(function (xsp) { return [x].concat(xsp); }));
      }
    });

    return utils.curried2(result, arguments);
  }

  return shrinkArrayImpl;
}

/**
  - `shrink.array(shr: shrink a): shrink (array a)`
*/
var shrinkArray = shrinkArrayWithMinimumSize(0);

/**
  - `shrink.nearray(shr: shrink a): shrink (nearray a)`
*/
var shrinkNEArray = shrinkArrayWithMinimumSize(1);

module.exports = {
  noop: shrinkNoop,
  pair: shrinkPair,
  either: shrinkEither,
  tuple: shrinkTuple,
  sum: shrinkSum,
  array: shrinkArray,
  nearray: shrinkNEArray,
  bless: shrinkBless,
};

},{"./either.js":361,"./sum.js":379,"./utils.js":381,"assert":54,"lazy-seq":382}],376:[function(require,module,exports){
"use strict";

var generator = require("./generator.js");
var arbitraryBless = require("./arbitraryBless.js");
var arbitraryAssert = require("./arbitraryAssert.js");
var utils = require("./utils.js");

/**
  ### Small arbitraries

  - `generator.small(gen: generator a): generator a`
  - `small(arb: arbitrary a): arbitrary a`

  Create a generator (abitrary) which will generate smaller values, i.e. generator's `size` parameter is decreased logarithmically.

  ```js
  jsc.property("small array of small natural numbers", "small (array nat)", function (arr) {
    return Array.isArray(arr);
  });

  jsc.property("small array of normal natural numbers", "(small array) nat", function (arr) {
    return Array.isArray(arr);
  });
  ```
*/

function smallGenerator(gen) {
  // TODO: assertGenerator(gen)
  return generator.bless(function (size) {
    return gen(utils.ilog2(size));
  });
}

function smallArbitraryImpl(arb) {
  arbitraryAssert(arb);
  return arbitraryBless({
    generator: smallGenerator(arb.generator),
    shrink: arb.shrink,
    show: arb.show,
  });
}

function smallArbitrary(arb) {
  if (typeof arb === "function") {
    return function () {
      var resArb = arb.apply(arb, arguments);
      return smallArbitraryImpl(resArb);
    };
  } else { /* if (typeof arb === "object") */
    return smallArbitraryImpl(arb);
  }
}

module.exports = {
  generator: smallGenerator,
  arbitrary: smallArbitrary,
};

},{"./arbitraryAssert.js":356,"./arbitraryBless.js":357,"./generator.js":366,"./utils.js":381}],377:[function(require,module,exports){
"use strict";

var array = require("./array.js");
var primitive = require("./primitive.js");
var utils = require("./utils.js");

/**
  ### Arbitrary strings
*/

function fromCode(code) {
  return String.fromCharCode(code);
}

function toCode(c) {
  return c.charCodeAt(0);
}

/**
  - `char: arbitrary char` &mdash; Single character
*/
var char = primitive.nat(0xff).smap(fromCode, toCode);

/**
  - `asciichar: arbitrary char` &mdash; Single ascii character (0x20-0x7e inclusive, no DEL)
*/
var asciichar = primitive.integer(0x20, 0x7e).smap(fromCode, toCode);

/**
  - `string: arbitrary string`
*/
var string = array.array(char).smap(utils.charArrayToString, utils.stringToCharArray);

/**
  - `nestring: arbitrary string` &mdash; Generates strings which are not empty.
*/
var nestring = array.nearray(char).smap(utils.charArrayToString, utils.stringToCharArray);

/**
  - `asciistring: arbitrary string`
*/
var asciistring = array.array(asciichar).smap(utils.charArrayToString, utils.stringToCharArray);

/**
  - `asciinestring: arbitrary string`
*/
var asciinestring = array.nearray(asciichar).smap(utils.charArrayToString, utils.stringToCharArray);

module.exports = {
  char: char,
  asciichar: asciichar,
  string: string,
  nestring: nestring,
  asciistring: asciistring,
  asciinestring: asciinestring,
};

},{"./array.js":358,"./primitive.js":370,"./utils.js":381}],378:[function(require,module,exports){
/* @flow weak */
"use strict";

var environment = require("./environment.js");
var typify = require("./typify.js");
var utils = require("./utils.js");
var generator = require("./generator.js");
var shrink = require("./shrink.js");
var arbitraryBless = require("./arbitraryBless.js");

/**
  - `suchthat(arb: arbitrary a, userenv: env?, p : a -> bool): arbitrary a`
      Arbitrary of values that satisfy `p` predicate. It's advised that `p`'s accept rate is high.
*/
function suchthat(arb, userenv, predicate) {
  var env;
  if (arguments.length === 2) {
    predicate = userenv;
    env = environment;
  } else {
    env = utils.merge(environment, userenv);
  }

  arb = typeof arb === "string" ? typify.parseTypify(env, arb) : arb;
  arb = utils.force(arb);

  return arbitraryBless({
    generator: generator.bless(function (size) {
      for (var i = 0; ; i++) {
        // if 5 tries failed, increase size
        if (i > 5) {
          i = 0;
          size += 1;
        }

        var x = arb.generator(size);
        if (predicate(x)) {
          return x;
        }
      }
    }),

    shrink: shrink.bless(function (x) {
      return arb.shrink(x).filter(predicate);
    }),

    show: arb.show,
  });
}

module.exports = {
  suchthat: suchthat,
};

},{"./arbitraryBless.js":357,"./environment.js":362,"./generator.js":366,"./shrink.js":375,"./typify.js":380,"./utils.js":381}],379:[function(require,module,exports){
"use strict";

var assert = require("assert");

/**
  ### sum (n-ary either)

  See: [Wikipedia](https://en.wikipedia.org/wiki/Tagged_union)
*/

function Addend(idx, len, value) {
  assert(len > 0, "Addend: 0 < len"); // empty sum is void - cannot create such
  assert(idx >= 0 && idx < len, "Addend: 0 <= idx < len");
  this.idx = idx;
  this.len = len;
  this.value = value;
}

/**
  - `sum.addend(idx: nat, n: nat, value: a): sum (... a ...)`
*/
function addend(idx, len, value) {
  return new Addend(idx, len, value);
}

/**
  - `.fold(f: (idx: nat, n: nat, value: a) -> b): b`
*/
Addend.prototype.fold = function (f) {
  return f(this.idx, this.len, this.value);
};

module.exports = {
  addend: addend,
};

},{"assert":54}],380:[function(require,module,exports){
/* @flow weak */
"use strict";

/**
  ### DSL for input parameters

  There is a small DSL to help with `forall`. For example the two definitions below are equivalent:
  ```js
  var bool_fn_applied_thrice = jsc.forall("bool -> bool", "bool", check);
  var bool_fn_applied_thrice = jsc.forall(jsc.fn(jsc.bool), jsc.bool, check);
  ```

  The DSL is based on a subset of language recognized by [typify-parser](https://github.com/phadej/typify-parser):
  - *identifiers* are fetched from the predefined environment.
  - *applications* are applied as one could expect: `"array bool"` is evaluated to `jsc.array(jsc.bool)`.
  - *functions* are supported: `"bool -> bool"` is evaluated to `jsc.fn(jsc.bool)`.
  - *square brackets* are treated as a shorthand for the array type: `"[nat]"` is evaluated to `jsc.array(jsc.nat)`.
  - *union*: `"bool | nat"` is evaluated to `jsc.sum([jsc.bool, jsc.nat])`.
      - **Note** `oneof` cannot be shrinked, because the union is untagged, we don't know which shrink to use.
  - *conjunction*: `"bool & nat"` is evaluated to `jsc.tuple(jsc.bool, jsc.nat)`.
  - *anonymous records*: `"{ b: bool; n: nat }"` is evaluated to `jsc.record({ b: jsc.bool, n: jsc.nat })`.
  - *EXPERIMENTAL: recursive types*: `"rec list -> unit | (nat & list)"`.
*/

var arbitrary = require("./arbitrary.js");
var assert = require("assert");
var record = require("./record.js");
var array = require("./array.js");
var fn = require("./fn.js");
var typifyParser = require("typify-parser");
var utils = require("./utils.js");

// Forward declarations
var compileType;
var compileTypeArray;

function compileIdent(env, type) {
  var g = env[type.value];
  if (!g) {
    throw new Error("Unknown arbitrary: " + type.value);
  }
  return g;
}

function compileApplication(env, type) {
  var callee = compileType(env, type.callee);
  var args = compileTypeArray(env, type.args);

  return callee.apply(undefined, args);
}

function compileFunction(env, type) {
  // we don't care about argument type
  var result = compileType(env, type.result);
  return fn.fn(result);
}

function compileBrackets(env, type) {
  var arg = compileType(env, type.arg);
  return array.array(arg);
}

function compileDisjunction(env, type) {
  var args = compileTypeArray(env, type.args);
  return arbitrary.sum(args);
}

function compileConjunction(env, type) {
  var args = compileTypeArray(env, type.args);
  return arbitrary.tuple(args);
}

function compileRecord(env, type) {
  // TODO: use mapValues
  var spec = {};
  Object.keys(type.fields).forEach(function (key) {
    spec[key] = compileType(env, type.fields[key]);
  });
  return record.arbitrary(spec);
}

function compileRecursive(env, type) {
  assert(type.arg.type === "disjunction", "recursive type's argument should be disjunction");

  // bound variable
  var name = type.name;

  var par = utils.partition(type.arg.args, function (t) {
    return typifyParser.freeVars(t).indexOf(name) === -1;
  });

  var terminal = par[0];

  if (terminal.length === 0) {
    throw new Error("Recursive type without non-recursive branch");
  }

  var terminalArb = compileType(env, {
    type: "disjunction",
    args: terminal,
  });

  return arbitrary.recursive(terminalArb, function (arb) {
    var arbEnv = {};
    arbEnv[name] = arb;
    var newEnv = utils.merge(env, arbEnv);
    return compileType(newEnv, type.arg);
  });
}

compileType = function compileTypeFn(env, type) {
  switch (type.type) {
    case "ident": return compileIdent(env, type);
    case "application": return compileApplication(env, type);
    case "function": return compileFunction(env, type);
    case "brackets": return compileBrackets(env, type);
    case "disjunction": return compileDisjunction(env, type);
    case "conjunction": return compileConjunction(env, type);
    case "record": return compileRecord(env, type);
    case "number": return type.value;
    case "recursive": return compileRecursive(env, type);
    default: throw new Error("Unsupported typify ast type: " + type.type);
  }
};

compileTypeArray = function compileTypeArrayFn(env, types) {
  return types.map(function (type) {
    return compileType(env, type);
  });
};

function parseTypify(env, str) {
  var type = typifyParser(str);
  return compileType(env, type);
}

module.exports = {
  parseTypify: parseTypify,
};

},{"./arbitrary.js":355,"./array.js":358,"./fn.js":364,"./record.js":372,"./utils.js":381,"assert":54,"typify-parser":396}],381:[function(require,module,exports){
/* @flow weak */
"use strict";

var isArray = Array.isArray;
function isObject(o) {
  /* eslint-disable no-new-object */
  return new Object(o) === o;
  /* eslint-enable no-new-object */
}

/* undefined-safe isNaN */
function isNaN(n) {
  return typeof n === "number" && n !== n;
}

/**
  ### Utility functions

  Utility functions are exposed (and documented) only to make contributions to jsverify more easy.
  The changes here don't follow semver, i.e. there might be backward-incompatible changes even in patch releases.

  Use [underscore.js](http://underscorejs.org/), [lodash](https://lodash.com/), [ramda](http://ramda.github.io/ramdocs/docs/), [lazy.js](http://danieltao.com/lazy.js/) or some other utility belt.
*/

/* Simple sort */
function sort(arr) {
  var res = arr.slice();
  res.sort();
  return res;
}

/**
  - `utils.isEqual(x: json, y: json): bool`

      Equality test for `json` objects.
*/
function isEqual(a, b) {
  var i;

  if (isNaN(a) && isNaN(b)) {
    return true;
  }

  if (a === b) {
    return true;
  } else if (isArray(a) && isArray(b) && a.length === b.length) {
    for (i = 0; i < a.length; i++) {
      if (!isEqual(a[i], b[i])) {
        return false;
      }
    }
    return true;
  } else if (isObject(a) && isObject(b) && !isArray(a) && !isArray(b)) {
    var akeys = Object.keys(a);
    var bkeys = Object.keys(b);
    if (!isEqual(sort(akeys), sort(bkeys))) {
      return false;
    }

    for (i = 0; i < akeys.length; i++) {
      if (!isEqual(a[akeys[i]], b[akeys[i]])) {
        return false;
      }
    }
    return true;
  }

  return false;
}

/**
  - `utils.isApproxEqual(x: a, y: b, opts: obj): bool`

      Tests whether two objects are approximately and optimistically equal.
      Returns `false` only if they are distinguisable not equal.
      Returns `true` when `x` and `y` are `NaN`.
      This function works with cyclic data.

      Takes optional 'opts' parameter with properties:

      - `fnEqual` - whether all functions are considered equal (default: yes)
      - `depth` - how deep to recurse until treating as equal (default: 5)
*/
function isApproxEqual(x, y, opts) {
  opts = opts || {};
  var fnEqual = opts.fnEqual !== false;
  var depth = opts.depth || 5; // totally arbitrary

  // state contains pairs we checked (or are still checking, but assume equal!)
  var state = [];

  function loop(a, b, n) {
    if (isNaN(a) && isNaN(b)) {
      return true;
    }

    // trivial check
    if (a === b) {
      return true;
    }

    // depth check
    if (n >= depth) {
      return true;
    }

    var i;

    // check if pair already occured
    for (i = 0; i < state.length; i++) {
      if (state[i][0] === a && state[i][1] === b) {
        return true;
      }
    }

    // add to state
    state.push([a, b]);

    if (typeof a === "function" && typeof b === "function") {
      return fnEqual;
    }

    if (isArray(a) && isArray(b) && a.length === b.length) {
      for (i = 0; i < a.length; i++) {
        if (!loop(a[i], b[i], n + 1)) {
          return false;
        }
      }
      return true;
    } else if (isObject(a) && isObject(b) && !isArray(a) && !isArray(b)) {
      var akeys = Object.keys(a);
      var bkeys = Object.keys(b);
      if (!loop(sort(akeys), sort(bkeys), n + 1)) {
        return false;
      }

      for (i = 0; i < akeys.length; i++) {
        if (!loop(a[akeys[i]], b[akeys[i]], n + 1)) {
          return false;
        }
      }
      return true;
    }

    return false;
  }
  return loop(x, y, 0);
}

function identity(x) {
  return x;
}

function pluck(arr, key) {
  return arr.map(function (e) {
    return e[key];
  });
}

/**
  - `utils.force(x: a | () -> a) : a`

      Evaluate `x` as nullary function, if it is one.
*/
function force(arb) {
  return (typeof arb === "function") ? arb() : arb;
}

/**
  - `utils.merge(x... : obj): obj`

    Merge two objects, a bit like `_.extend({}, x, y)`.
*/
function merge() {
  var res = {};

  for (var i = 0; i < arguments.length; i++) {
    var arg = arguments[i];
    var keys = Object.keys(arg);
    for (var j = 0; j < keys.length; j++) {
      var key = keys[j];
      res[key] = arg[key];
    }
  }

  return res;
}

function div2(x) {
  return Math.floor(x / 2);
}

function log2(x) {
  return Math.log(x) / Math.log(2);
}

function ilog2(x) {
  return x <= 0 ? 0 : Math.floor(log2(x));
}

function curriedN(n) {
  var n1 = n - 1;
  return function curriedNInstance(result, args) {
    if (args.length === n) {
      return result(args[n1]);
    } else {
      return result;
    }
  };
}

var curried2 = curriedN(2);
var curried3 = curriedN(3);

function charArrayToString(arr) {
  return arr.join("");
}

function stringToCharArray(str) {
  return str.split("");
}

function pairArrayToDict(arrayOfPairs) {
  var res = {};
  arrayOfPairs.forEach(function (p) {
    res[p[0]] = p[1];
  });
  return res;
}

function dictToPairArray(m) {
  var res = [];
  Object.keys(m).forEach(function (k) {
    res.push([k, m[k]]);
  });
  return res;
}

function partition(arr, pred) {
  var truthy = [];
  var falsy = [];

  for (var i = 0; i < arr.length; i++) {
    var x = arr[i];
    if (pred(x)) {
      truthy.push(x);
    } else {
      falsy.push(x);
    }
  }

  return [truthy, falsy];
}

module.exports = {
  isArray: isArray,
  isObject: isObject,
  isEqual: isEqual,
  isApproxEqual: isApproxEqual,
  identity: identity,
  pluck: pluck,
  force: force,
  merge: merge,
  div2: div2,
  ilog2: ilog2,
  curried2: curried2,
  curried3: curried3,
  charArrayToString: charArrayToString,
  stringToCharArray: stringToCharArray,
  pairArrayToDict: pairArrayToDict,
  dictToPairArray: dictToPairArray,
  partition: partition,
};

},{}],382:[function(require,module,exports){
/**
  # lazy-seq

  > Lazy sequences

  [![Build Status](https://secure.travis-ci.org/phadej/lazy-seq.svg?branch=master)](http://travis-ci.org/phadej/lazy-seq)
  [![NPM version](https://badge.fury.io/js/lazy-seq.svg)](http://badge.fury.io/js/lazy-seq)
  [![Dependency Status](https://david-dm.org/phadej/lazy-seq.svg)](https://david-dm.org/phadej/lazy-seq)
  [![devDependency Status](https://david-dm.org/phadej/lazy-seq/dev-status.svg)](https://david-dm.org/phadej/lazy-seq#info=devDependencies)
  [![Code Climate](https://img.shields.io/codeclimate/github/phadej/lazy-seq.svg)](https://codeclimate.com/github/phadej/lazy-seq)

  ## Lazy?

  The list structure could be defined as

  ```hs
  data Seq a = Nil | Cons a (Seq a)
  ```

  The `Cons` constuctor takes two arguments, so there are four different laziness variants:

  ```hs
  Cons (Strict a) (Strict (Seq a)) -- 1. fully strict
  Cons (Lazy a)   (Strict (Seq a)) -- 2. lazy values
  Cons (Strict a) (Lazy (Seq a))   -- 3. lazy structure
  Cons (Lazy   a) (Lazy (Seq a))   -- 4. fully lazy
  ```

  This module implements the third variant: lazy structure, but strict values.

  ## Example

  ```js
  var ones = lazyseq.cons(1, function () { return ones; });
  console.log(ones === ones.tail()); // true!
  ```

  ## Why?

  This package is originally made to optimise shrink operations in [jsverify](http://jsverify.github.io/), a property-based testing library.

  ## API
*/

"use strict";

var assert = require("assert");

/**
  - *nil : Seq a* &mdash; Empty sequence.

  - *cons : (head : a, tail : Array a | Seq a | () â†’ Array a | () â†’ Seq a) â†’ Seq a* : Cons a value to the front of a sequence (list or thunk).
*/
var nil = {};

/**
  - *.isNil : Boolean* &mdash; Constant time check, whether the sequence is empty.
*/
nil.isNil = true;

/**
  - *.toString : () â†’ String* &mdash; String representation. Doesn't force the tail.
*/
nil.toString = function () {
  return "nil";
};

/**
  - *.length : () â†’ Nat* &mdash; Return the length of the sequene. Forces the structure.
*/
nil.length = function () {
  return 0;
};

/**
  - *.toArray : () â†’ Array a* &mdash; Convert the sequence to JavaScript array.
*/
nil.toArray = function nilToArray() {
  return [];
};

/**
  - *.fold : (z : b, f : (a, () â†’ b) â†’ b) â†’ b* &mdash; Fold from right.

      ```hs
      fold nil x f        = x
      fold (cons h t) x f = f x (fold t x f)
      ```
*/
nil.fold = function nilFold(x /*, f */) {
  return x;
};

/**
  - *.head : () â†’ a* &mdash;  Extract the first element of a sequence, which must be non-empty.
*/
nil.head = function nilHead() {
  throw new Error("nil.head");
};

/**
  - *.tail : () â†’ Seq a* &mdash; Return the tail of the sequence.

      ```hs
      tail nil        = nil
      tail (cons h t) = t
      ```
*/
nil.tail = function nilTail() {
  return nil;
};

/**
  - *.nth : (n : Nat) â†’ a* &mdash; Return nth value of the sequence.
*/
nil.nth = function nilNth(n) {
  assert(typeof n === "number");
  throw new Error("Can't get " + n + "th value of the nil");
};

/**
  - *.take : (n : Nat) â†’ Seq a* &mdash; Take `n` first elements of the sequence.
*/
nil.take = function (n) {
  assert(typeof n === "number");
  return nil;
};

/**
  - *.drop : (n : Nat) â†’ Seq a* &mdash; Drop `n` first elements of the sequence.
*/
nil.drop = function (n) {
  assert(typeof n === "number");
  return nil;
};

/**
  - *.map : (f : a â†’ b) : Seq b* &mdash; The sequence obtained by applying `f` to each element of the original sequence.
*/
nil.map = function (f) {
  assert(typeof f === "function");
  return nil;
};

/**
  - *.append : (ys : Seq a | Array a) : Seq a* &mdash; Append `ys` sequence.
*/
nil.append = function (seq) {
  if (typeof seq === "function") {
    seq = seq();
  }

  if (Array.isArray(seq)) {
    /* eslint-disable no-use-before-define */
    return fromArray(seq);
    /* eslint-enable no-use-before-define */
  } else {
    return seq;
  }
};

/**
  - *.filter : (p : a -> bool) : Seq a* &mdash; filter using `p` predicate.
*/
nil.filter = function () {
  return nil;
};

/**
  - *.every : (p = identity: a -> b) : b | true &mdash; return first falsy value in the sequence, true otherwise. *N.B.* behaves slightly differently from `Array::every`.
*/
nil.every = function () {
  return true;
};

/**
  - *.some : (p = identity: a -> b) : b | false &mdash; return first truthy value in the sequence, false otherwise. *N.B.* behaves slightly differently from `Array::some`.
*/
nil.some = function () {
  return false;
};

/**
  - *.contains : (x : a) : bool &mdash; Returns `true` if `x` is in the sequence.
*/
nil.contains = function () {
  return false;
};

/**
  - *.containsNot : (x : a) : bool &mdash; Returns `true` if `x` is not in the sequence.
*/
nil.containsNot = function () {
  return true;
};

// Default cons values are with strict semantics
function Cons(head, tail) {
  this.headValue = head;
  this.tailValue = tail;
}

Cons.prototype.isNil = false;

Cons.prototype.toString = function () {
  return "Cons(" + this.headValue + ", " + this.tailValue + ")";
};

Cons.prototype.length = function () {
  return 1 + this.tail().length();
};

Cons.prototype.toArray = function () {
  var ptr = this;
  var acc = [];
  while (ptr !== nil) {
    acc.push(ptr.headValue);
    ptr = ptr.tail();
  }
  return acc;
};

Cons.prototype.fold = function consFold(x, f) {
  var self = this;
  return f(this.headValue, function () {
    return self.tail().fold(x, f);
  });
};

Cons.prototype.head = function consHead() {
  return this.headValue;
};

Cons.prototype.tail = function consTail() {
  return this.tailValue;
};

// But when cons is created, it's overloaded with lazy ones

// Force tail to whnf.
function lazyConsForce() {
  /* jshint validthis:true */
  var val = this.tailFn();
  /* eslint-disable no-use-before-define */
  this.tailValue = Array.isArray(val) ? fromArray(val) : val;
  /* eslint-enable no-use-before-define */

  delete this.tail;
  delete this.force;

  return this;
}

function lazyConsTail() {
  /* jshint validthis:true */
  this.force();
  return this.tailValue;
}

function delay(head, tail) {
  assert(typeof tail === "function");

  head.tailFn = tail;
  head.tail = lazyConsTail;

  head.force = lazyConsForce;
  return head;
}

function cons(head, tail) {
  if (typeof tail === "function") {
    return delay(new Cons(head), tail);
  } else if (Array.isArray(tail)) {
    return delay(cons(head), function () {
      /* eslint-disable no-use-before-define */
      return fromArray(tail);
      /* eslint-enable no-use-before-define */
    });
  } else {
    return new Cons(head, tail);
  }
}

// Rest of the functions. They might use cons

Cons.prototype.nth = function consNth(n) {
  assert(typeof n === "number");
  return n === 0 ? this.headValue : this.tail().nth(n - 1);
};

Cons.prototype.take = function consTake(n) {
  assert(typeof n === "number");
  var that = this;
  return n === 0 ? nil : cons(this.headValue, function () {
    return that.tail().take(n - 1);
  });
};

Cons.prototype.drop = function consDrop(n) {
  assert(typeof n === "number");
  return n === 0 ? this : this.tail().drop(n - 1);
};

Cons.prototype.map = function consMap(f) {
  assert(typeof f === "function");
  var that = this;
  return cons(f(that.headValue), function () {
    return that.tail().map(f);
  });
};

Cons.prototype.append = function consAppend(seq) {
  // Short circuit decidable: (++ []) â‰¡ id
  if (seq === nil || (Array.isArray(seq) && seq.length === 0)) {
    return this;
  }
  var that = this;
  return cons(that.headValue, function () {
    return that.tail().append(seq);
  });
};

Cons.prototype.filter = function consFilter(p) {
  assert(typeof p === "function");
  var that = this;
  if (p(that.headValue)) {
    return cons(that.headValue, function () {
      return that.tail().filter(p);
    });
  } else {
    return that.tail().filter(p);
  }
};

Cons.prototype.every = function consEvery(p) {
  p = p || function (x) { return x; };
  assert(typeof p === "function");
  var that = this;
  var pHead = p(that.headValue);
  if (!pHead) {
    return pHead;
  } else {
    return that.tail().every(p);
  }
};

Cons.prototype.some = function consSome(p) {
  p = p || function (x) { return x; };
  assert(typeof p === "function");
  var that = this;
  var pHead = p(that.headValue);
  if (pHead) {
    return pHead;
  } else {
    return that.tail().some(p);
  }
};

Cons.prototype.contains = function consContains(x) {
  var that = this;
  if (x === that.headValue) {
    return true;
  } else {
    return that.tail().contains(x);
  }
};

Cons.prototype.containsNot = function consContainsNot(x) {
  var that = this;
  if (x === that.headValue) {
    return false;
  } else {
    return that.tail().containsNot(x);
  }
};

// Constructors
/**
  - *fromArray: (arr : Array a) â†’ Seq a* &mdash; Convert a JavaScript array into lazy sequence.
*/
function fromArrayIter(arr, n) {
  if (n < arr.length) {
    return cons(arr[n], function () {
      return fromArrayIter(arr, n + 1);
    });
  } else {
    return nil;
  }
}

function fromArray(arr) {
  assert(Array.isArray(arr));
  return fromArrayIter(arr, 0);
}

/**
  - *singleton: (x : a) â†’ Seq a* &mdash; Create a singleton sequence.
*/
function singleton(x) {
  return fromArray([x]);
}

/**
  - *append : (xs... : Array a | Seq a | () â†’ Array a | () â†’ Seq a) â†’ Seq a* : Append one sequence-like to another.
*/
function append() {
  var acc = nil;
  for (var i = 0; i < arguments.length; i++) {
    acc = acc.append(arguments[i]);
  }
  return acc;
}

/**
  - *iterate : (x : a, f : a â†’ a) â†’ Seq a* &mdash; Create an infinite sequence of repeated applications of `f` to `x`: *x, f(x), f(f(x))&hellip;*.
*/
function iterate(x, f) {
  return cons(x, function () {
    return iterate(f(x), f);
  });
}

/**
  - *fold : (seq : Seq a | Array a, z : b, f : (a, () â†’ b) â†’ b) : b* &mdash; polymorphic version of fold. Works with arrays too.
*/
function listFold(list, z, f, n) {
  if (n < list.length) {
    return f(list[n], function () {
      return listFold(list, z, f, n + 1);
    });
  } else {
    return z;
  }
}

function fold(list, z, f) {
  if (Array.isArray(list)) {
    return listFold(list, z, f, 0);
  } else {
    return list.fold(z, f);
  }
}

module.exports = {
  nil: nil,
  cons: cons,
  append: append,
  fromArray: fromArray,
  singleton: singleton,
  iterate: iterate,
  fold: fold,
};

/// plain CHANGELOG.md
/// plain CONTRIBUTING.md

},{"assert":54}],383:[function(require,module,exports){
'use strict';

//---------------------------------------------------------------------
//
// This source file is part of the Meta:Magical project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//---------------------------------------------------------------------

module.exports = function (meta) {
  meta.for(Object).update({
    module: '(built-in)',
    platforms: ['ECMAScript'],
    name: 'Object'
  });

  meta.for(Object.prototype).update({
    module: '(built-in)',
    platforms: ['ECMAScript'],
    name: 'Object.prototype'
  });

  meta.for(Function).update({
    module: '(built-in)',
    platforms: ['ECMAScript'],
    name: 'Function.prototype'
  });

  meta.for(String).update({
    module: '(built-in)',
    platforms: ['ECMAScript'],
    name: 'String'
  });

  meta.for(String.prototype).update({
    module: '(built-in)',
    platforms: ['ECMAScript'],
    name: 'String.prototype'
  });

  meta.for(Number).update({
    module: '(built-in)',
    platforms: ['ECMAScript'],
    name: 'Number'
  });

  meta.for(Number.prototype).update({
    module: '(built-in)',
    platforms: ['ECMAScript'],
    name: 'Number.prototype'
  });

  meta.for(Boolean).update({
    module: '(built-in)',
    platforms: ['ECMAScript'],
    name: 'Boolean'
  });

  meta.for(Boolean.prototype).update({
    module: '(built-in)',
    platforms: ['ECMAScript'],
    name: 'Boolean.prototype'
  });

  meta.for(RegExp).update({
    module: '(built-in)',
    platforms: ['ECMAScript'],
    name: 'RegExp'
  });

  meta.for(RegExp.prototype).update({
    module: '(built-in)',
    platforms: ['ECMAScript'],
    name: 'RegExp.prototype'
  });

  meta.for(Date).update({
    module: '(built-in)',
    platforms: ['ECMAScript'],
    name: 'Date'
  });

  meta.for(Date.prototype).update({
    module: '(built-in)',
    platforms: ['ECMAScript'],
    name: 'Date.prototype'
  });

  meta.for(Array).update({
    module: '(built-in)',
    platforms: ['ECMAScript'],
    name: 'Array'
  });

  meta.for(Array.prototype).update({
    module: '(built-in)',
    platforms: ['ECMAScript'],
    name: 'Array.prototype'
  });
};
},{}],384:[function(require,module,exports){
'use strict';

//---------------------------------------------------------------------
//
// This source file is part of the Meta:Magical project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//---------------------------------------------------------------------

module.exports = function (meta) {
  return require('./built-ins')(meta);
};
},{"./built-ins":383}],385:[function(require,module,exports){
'use strict';

var __metamagical_withMeta = function metamagical_withMeta(object, meta) {
  var parent = Object.getPrototypeOf(object);var oldMeta = object[Symbol.for('@@meta:magical')] || {};if (parent && parent[Symbol.for('@@meta:magical')] === oldMeta) {
    oldMeta = {};
  }Object.keys(meta).forEach(function (key) {
    if (/^~/.test(key)) {
      oldMeta[key.slice(1)] = meta[key];
    } else {
      oldMeta[key] = meta[key];
    }
  });object[Symbol.for('@@meta:magical')] = oldMeta;return object;
},
    _metamagical_withMet;

//---------------------------------------------------------------------
//
// This source file is part of the Meta:Magical project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//---------------------------------------------------------------------

/*~
 * Assertions used by other modules.
 *
 * ---
 * name     : module assertions
 * module   : metamagical-interface/lib/assertions
 * category : Assertions
 * platforms:
 *   - ECMAScript 3
 */
module.exports = __metamagical_withMeta((_metamagical_withMet = {
  assertObject: function assertObject(value) {
    if (Object(value) !== value) {
      var kind = value === null ? 'null' : value === undefined ? 'undefined' : /* otherwise */'a primitive value (' + JSON.stringify(value) + ')';

      throw new TypeError('Meta:Magical can only associate meta-data with objects, but you\'re trying to use ' + kind);
    }
  }
}, __metamagical_withMeta(_metamagical_withMet['assertObject'], {
  'name': 'assertObject',
  'source': 'assertObject(value) {\n    if (Object(value) !== value) {\n      const kind = value === null      ?  \'null\'\n      :            value === undefined ?  \'undefined\'\n      :            /* otherwise */        `a primitive value (${JSON.stringify(value)})`;\n\n      throw new TypeError(`Meta:Magical can only associate meta-data with objects, but you\'re trying to use ${kind}`);\n    }\n  }',
  'signature': 'assertObject(value)',
  'location': {
    'filename': 'src/assertions.js',
    'start': {
      'line': 20,
      'column': 17
    },
    'end': {
      'line': 43,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src/assertions',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'category': 'Assertions',
  'stability': 'stable',
  'throws': {
    'TypeError': 'when the value isn\'t an object.'
  },
  'type': '(Any) => None :: throws TypeError\n \n',
  'documentation': '\nMakes sure that `value` is an object.\n'
}), _metamagical_withMet), {
  'name': 'module assertions',
  'source': '{\n  /*~\n   * Makes sure that `value` is an object.\n   *\n   * ---\n   * category  : Assertions\n   * stability : stable\n   *\n   * throws:\n   *   TypeError: when the value isn\'t an object.\n   *\n   * type: |\n   *   (Any) => None :: throws TypeError\n   */\n  assertObject(value) {\n    if (Object(value) !== value) {\n      const kind = value === null      ?  \'null\'\n      :            value === undefined ?  \'undefined\'\n      :            /* otherwise */        `a primitive value (${JSON.stringify(value)})`;\n\n      throw new TypeError(`Meta:Magical can only associate meta-data with objects, but you\'re trying to use ${kind}`);\n    }\n  }\n}',
  'location': {
    'filename': 'src/assertions.js',
    'start': {
      'line': 20,
      'column': 0
    },
    'end': {
      'line': 43,
      'column': 2
    }
  },
  'module': 'metamagical-interface/lib/assertions',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'isModule': true,
  'category': 'Assertions',
  'platforms': ['ECMAScript 3'],
  'documentation': '\nAssertions used by other modules.\n'
});
},{}],386:[function(require,module,exports){
'use strict';

var __metamagical_withMeta = function metamagical_withMeta(object, meta) {
  var parent = Object.getPrototypeOf(object);var oldMeta = object[Symbol.for('@@meta:magical')] || {};if (parent && parent[Symbol.for('@@meta:magical')] === oldMeta) {
    oldMeta = {};
  }Object.keys(meta).forEach(function (key) {
    if (/^~/.test(key)) {
      oldMeta[key.slice(1)] = meta[key];
    } else {
      oldMeta[key] = meta[key];
    }
  });object[Symbol.for('@@meta:magical')] = oldMeta;return object;
},
    _Refinable$refine,
    _metamagical_withMet;

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

//---------------------------------------------------------------------
//
// This source file is part of the Meta:Magical project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//---------------------------------------------------------------------

// --[ Dependencies ]--------------------------------------------------
var Refinable = require('refinable');
var Maybe = require('data.maybe');
var Stability = require('./stability');

// --[ Helpers ]-------------------------------------------------------
function required(object, name) {
  throw new Error('This ' + object + ' does not define ' + name + '.\n\nYou must refine this object and define the missing property before\nyou can use it. For example:\n\n    const newObject = ' + object + '.refine({ ' + name + ': ... });\n  ');
}

function unique(xs) {
  return [].concat(_toConsumableArray(new Set(xs)));
}

function flatten(xss) {
  return xss.reduce(function (l, r) {
    return l.concat(r);
  }, []);
}

// --[ Base for Fields ]-----------------------------------------------

/*~
 * Provides a base for a Field definition used by Meta:Magical.
 *
 * A field describes how Meta:Magical handles a particular annotation.
 * Annotations are uniquely identified by their names. Fields must at
 * least define the name of the annotation they apply to::
 *
 *     const documentation = Field.refine({ name: 'documentation' });
 *
 *
 * ## Inheritance and Propagation
 *
 * An annotation may be inherited from a parent object, or it may
 * propagate from child objects. Fields control whether any of these
 * apply to a particular annotation by specifying the `allowInheritance`
 * and `allowPropagation` properties::
 *
 *     const a = Field.refine({ name: 'a', allowInheritance: true });
 *     const b = Field.refine({ name: 'b', allowPropagation: true });
 *
 * By default, both of these are false.
 *
 * When a field allows the annotation to be propagated, it also must
 * define how the different values for that annotation defined in its
 * children are merged, by providing a `merge` method. The `merge`
 * method receives an array of all values in the children objects,
 * and returns the new value for that annotation, wrapped in a Maybe::
 *
 *     const Maybe = require('data.maybe');
 *
 *     const authors = Field.refine({
 *       name: 'authors',
 *       allowPropagation: true,
 *       merge(values) {
 *         return Maybe.Just([...new Set(values)])
 *       }
 *     });
 *
 * See the `Interface` object for more information on how it handles
 * propagation and inheritance.
 *
 * ---
 * module   : metamagical-interface/lib/fields
 * category : Describing annotations
 * platforms:
 *   - ECMAScript 5
 *
 * type: |
 *   Field 'a <: Refinable
 */
var Field = __metamagical_withMeta(Refinable.refine((_Refinable$refine = {
  get name() {
    required('Field', 'name');
  },

  get allowInheritance() {
    return false;
  },

  get allowPropagation() {
    return false;
  },

  merge: function merge(values) {
    return Maybe.Just(values);
  }
}, __metamagical_withMeta(Object.getOwnPropertyDescriptor(_Refinable$refine, 'name').get, {
  'name': 'name',
  'source': 'get name() {\n    required(\'Field\', \'name\');\n  }',
  'signature': 'get name()',
  'belongsTo': function belongsTo() {
    return Field;
  },
  'isRequired': true,
  'category': 'State and Configuration',
  'stability': 'stable',
  'type': 'String',
  'documentation': '\nThe name of the annotation this Field describes.\n'
}), __metamagical_withMeta(Object.getOwnPropertyDescriptor(_Refinable$refine, 'allowInheritance').get, {
  'name': 'allowInheritance',
  'source': 'get allowInheritance() {\n    return false;\n  }',
  'signature': 'get allowInheritance()',
  'belongsTo': function belongsTo() {
    return Field;
  },
  'category': 'Inheritance and Propagation',
  'stability': 'stable',
  'type': 'Boolean',
  'documentation': '\nWhether the annotation should be inherited from a parent object\nif not defined directly in the object.\n'
}), __metamagical_withMeta(Object.getOwnPropertyDescriptor(_Refinable$refine, 'allowPropagation').get, {
  'name': 'allowPropagation',
  'source': 'get allowPropagation() {\n    return false;\n  }',
  'signature': 'get allowPropagation()',
  'belongsTo': function belongsTo() {
    return Field;
  },
  'category': 'Inheritance and Propagation',
  'stability': 'stable',
  'type': 'Boolean',
  'documentation': '\nWhether the annotation should be propagated from children obects\nif not defined directly in the object.\n\nNote that you should provide your own merging strategy, through\nthe `merge` method, if your annotation supports propagation.\n'
}), __metamagical_withMeta(_Refinable$refine['merge'], {
  'name': 'merge',
  'source': 'merge(values) {\n    return Maybe.Just(values);\n  }',
  'signature': 'merge(values)',
  'belongsTo': function belongsTo() {
    return Field;
  },
  'category': 'Inheritance and Propagation',
  'stability': 'stable',
  'type': '(Array \'a) => Maybe \'b\n \n',
  'documentation': '\nMerges annotations that have been propagated from children\nobjects.\n'
}), _Refinable$refine)), {
  'name': 'Field',
  'source': 'Refinable.refine({\n  /*~\n   * The name of the annotation this Field describes.\n   *\n   * ---\n   * isRequired : true\n   * category   : State and Configuration\n   * stability  : stable\n   *\n   * type: String\n   */\n  get name() {\n    required(\'Field\', \'name\');\n  },\n\n  /*~\n   * Whether the annotation should be inherited from a parent object\n   * if not defined directly in the object.\n   *\n   * ---\n   * category  : Inheritance and Propagation\n   * stability : stable\n   *\n   * type: Boolean\n   */\n  get allowInheritance() {\n    return false;\n  },\n\n  /*~\n   * Whether the annotation should be propagated from children obects\n   * if not defined directly in the object.\n   *\n   * Note that you should provide your own merging strategy, through\n   * the `merge` method, if your annotation supports propagation.\n   *\n   * ---\n   * category  : Inheritance and Propagation\n   * stability : stable\n   *\n   * type: Boolean\n   */\n  get allowPropagation() {\n    return false;\n  },\n\n  /*~\n   * Merges annotations that have been propagated from children\n   * objects.\n   *\n   * ---\n   * category  : Inheritance and Propagation\n   * stability : stable\n   *\n   * type: |\n   *   (Array \'a) => Maybe \'b\n   */\n  merge(values) {\n    return Maybe.Just(values);\n  }\n})',
  'location': {
    'filename': 'src/fields.js',
    'start': {
      'line': 88,
      'column': 0
    },
    'end': {
      'line': 148,
      'column': 3
    }
  },
  'module': 'metamagical-interface/lib/fields',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'category': 'Describing annotations',
  'platforms': ['ECMAScript 5'],
  'type': 'Field \'a <: Refinable\n',
  'documentation': '\nProvides a base for a Field definition used by Meta:Magical.\n\nA field describes how Meta:Magical handles a particular annotation.\nAnnotations are uniquely identified by their names. Fields must at\nleast define the name of the annotation they apply to:\n\n    const documentation = Field.refine({ name: \'documentation\' });\n\n\n## Inheritance and Propagation\n\nAn annotation may be inherited from a parent object, or it may\npropagate from child objects. Fields control whether any of these\napply to a particular annotation by specifying the `allowInheritance`\nand `allowPropagation` properties:\n\n    const a = Field.refine({ name: \'a\', allowInheritance: true });\n    const b = Field.refine({ name: \'b\', allowPropagation: true });\n\nBy default, both of these are false.\n\nWhen a field allows the annotation to be propagated, it also must\ndefine how the different values for that annotation defined in its\nchildren are merged, by providing a `merge` method. The `merge`\nmethod receives an array of all values in the children objects,\nand returns the new value for that annotation, wrapped in a Maybe:\n\n    const Maybe = require(\'data.maybe\');\n\n    const authors = Field.refine({\n      name: \'authors\',\n      allowPropagation: true,\n      merge(values) {\n        return Maybe.Just([...new Set(values)])\n      }\n    });\n\nSee the `Interface` object for more information on how it handles\npropagation and inheritance.\n',
  'examples': [{
    'name': '',
    'call': __metamagical_withMeta(function () {
      var documentation = Field.refine({ name: 'documentation' });
    }, {
      'source': 'const documentation = Field.refine({ name: \'documentation\' });'
    }),
    'inferred': true
  }, {
    'name': 'Inheritance and Propagation',
    'call': __metamagical_withMeta(function () {
      var a = Field.refine({ name: 'a', allowInheritance: true });var b = Field.refine({ name: 'b', allowPropagation: true });;var Maybe = require('data.maybe');var authors = Field.refine({ name: 'authors', allowPropagation: true, merge: function merge(values) {
          return Maybe.Just([].concat(_toConsumableArray(new Set(values))));
        }
      });
    }, {
      'source': 'const a = Field.refine({ name: \'a\', allowInheritance: true });\nconst b = Field.refine({ name: \'b\', allowPropagation: true });\n;\nconst Maybe = require(\'data.maybe\');\n\nconst authors = Field.refine({\n  name: \'authors\',\n  allowPropagation: true,\n  merge(values) {\n    return Maybe.Just([...new Set(values)])\n  }\n});'
    }),
    'inferred': true
  }]
});

// --[ Built-in Fields ]-----------------------------------------------

/*~
 * This module provides a set of built-in fields that Meta:Magical
 * knows about, as well as a way of defining new fields.
 *
 * ---
 * module   : metamagical-interface/lib/fields
 */
module.exports = __metamagical_withMeta((_metamagical_withMet = {
  Field: Field,
  copyright: Field.refine({
    name: 'copyright',
    allowInheritance: true,
    allowPropagation: false
  }),
  authors: Field.refine({
    name: 'authors',
    allowInheritance: true,
    allowPropagation: true,
    merge: function merge(values) {
      return Maybe.Just(unique(flatten(values)));
    }
  }),
  maintainers: Field.refine({
    name: 'maintainers',
    allowInheritance: true,
    allowPropagation: true,
    merge: function merge(values) {
      return Maybe.Just(unique(flatten(values)));
    }
  }),
  licence: Field.refine({
    name: 'licence',
    allowInheritance: true,
    allowPropagation: false
  }),
  since: Field.refine({
    name: 'since',
    allowInheritance: true,
    allowPropagation: false
  }),
  deprecated: Field.refine({
    name: 'deprecated',
    allowInheritance: true,
    allowPropagation: false
  }),
  repository: Field.refine({
    name: 'repository',
    allowInheritance: true
  }),
  stability: Field.refine({
    name: 'stability',
    allowInheritance: true,
    allowPropagation: true,
    merge: function merge(values) {
      if (values.length === 0) {
        return Maybe.Nothing();
      } else {
        return Maybe.Just(values.reduce(function (l, r) {
          var left = Stability.fromIdentifier(l).index;
          var right = Stability.fromIdentifier(r).index;

          return left < right ? l : /* else */r;
        }));
      }
    }
  }),
  homepage: Field.refine({
    name: 'homepage',
    allowInheritance: true
  }),
  category: Field.refine({
    name: 'category',
    allowInheritance: false,
    allowPropagation: false
  }),
  tags: Field.refine({
    name: 'tags',
    allowInheritance: false,
    allowPropagation: false
  }),
  npmPackage: Field.refine({
    name: 'npmPackage',
    allowInheritance: true,
    allowPropagation: false
  }),
  module: Field.refine({
    name: 'module',
    allowInheritance: true,
    allowPropagation: false
  }),
  isModule: Field.refine({
    name: 'isModule',
    allowInheritance: false,
    allowPropagation: false
  }),
  isRequired: Field.refine({
    name: 'isRequired',
    allowInheritance: false,
    allowPropagation: false
  }),
  belongsTo: Field.refine({
    name: 'belongsTo',
    allowInheritance: false,
    allowPropagation: false
  }),
  name: Field.refine({
    name: 'name',
    allowInheritance: false,
    allowPropagation: false
  }),
  location: Field.refine({
    name: 'location',
    allowInheritance: false,
    allowPropagation: false
  }),
  source: Field.refine({
    name: 'source',
    allowInheritance: false,
    allowPropagation: false
  }),
  documentation: Field.refine({
    name: 'documentation',
    allowInheritance: false,
    allowPropagation: false
  }),
  examples: Field.refine({
    name: 'examples',
    allowInheritance: false,
    allowPropagation: false
  }),
  signature: Field.refine({
    name: 'signature',
    allowInheritance: false,
    allowPropagation: false
  }),
  type: Field.refine({
    name: 'type',
    allowInheritance: false,
    allowPropagation: false
  }),
  throws: Field.refine({
    name: 'throws',
    allowInheritance: false,
    allowPropagation: false
  }),
  parameters: Field.refine({
    name: 'parameters',
    allowInheritance: false,
    allowPropagation: false
  }),
  returns: Field.refine({
    name: 'returns',
    allowInheritance: false,
    allowPropagation: false
  }),
  complexity: Field.refine({
    name: 'complexity',
    allowInheritance: false,
    allowPropagation: false
  }),
  platforms: Field.refine({
    name: 'platforms',
    allowInheritance: true,
    allowPropagation: false
  }),
  portable: Field.refine({
    name: 'portable',
    allowInheritance: true,
    allowPropagation: true,
    merge: function merge(values) {
      if (values.length === 0) {
        return Maybe.Nothing();
      } else {
        return Maybe.Just(values.every(Boolean));
      }
    }
  })
}, __metamagical_withMeta(_metamagical_withMet['copyright'], {
  'name': 'copyright',
  'source': 'Field.refine({\n    name: \'copyright\',\n    allowInheritance: true,\n    allowPropagation: false\n  })',
  'location': {
    'filename': 'src/fields.js',
    'start': {
      'line': 160,
      'column': 17
    },
    'end': {
      'line': 814,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src/fields',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'category': 'Social Metadata',
  'stability': 'stable',
  'type': 'Field String',
  'documentation': '\nProvides copyright information about a particular object.\n\nThis is usually a String in the form of `"(c) 2016 Some Name"`,\nand is commonly just output as-is by the documentation browsers.\n\nCopyright may be inherited from a parent object, but it may not\nbe propagated.\n'
}), __metamagical_withMeta(_metamagical_withMet['authors'], {
  'name': 'authors',
  'source': 'Field.refine({\n    name: \'authors\',\n    allowInheritance: true,\n    allowPropagation: true,\n    merge(values) {\n      return Maybe.Just(unique(flatten(values)));\n    }\n  })',
  'location': {
    'filename': 'src/fields.js',
    'start': {
      'line': 160,
      'column': 17
    },
    'end': {
      'line': 814,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src/fields',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'category': 'Social Metadata',
  'stability': 'experimental',
  'type': 'type Person = {\n  name: String,\n  email?: String,\n  url?: String\n}\nField (Array Person)\n \n',
  'documentation': '\nProvides a list of people who have authored the object.\n\nThis is an array of Person objects, where a Person must\nat least have a `name` field, but may also include\nadditional contact information:\n\n    { name: "Quildreen Motta", email: "queen@robotlolita.me" }\n\nAuthors may be inherited from a parent object or propagated\nfrom children objects. When propagated, only unique *names*\nare kept.\n'
}), __metamagical_withMeta(_metamagical_withMet['maintainers'], {
  'name': 'maintainers',
  'source': 'Field.refine({\n    name: \'maintainers\',\n    allowInheritance: true,\n    allowPropagation: true,\n    merge(values) {\n      return Maybe.Just(unique(flatten(values)));\n    }\n  })',
  'location': {
    'filename': 'src/fields.js',
    'start': {
      'line': 160,
      'column': 17
    },
    'end': {
      'line': 814,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src/fields',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'category': 'Social Metadata',
  'stability': 'experimental',
  'type': 'type Person = {\n  name: String,\n  email?: Email,\n  url?: String\n}\nField (Array Person)\n \n',
  'documentation': '\nProvides a list of people who maintain the object.\n\nThis is an array of Person objects, where a Person must\nat least have a `name` field, but may also include\nadditional contact information:\n\n    { name: "Quildreen Motta", email: "queen@robotlolita.me" }\n\nBecause this field is used to present the people who are in\ncharge of fixing bugs in the object or adding new features to\nit, it\'s strongly recommended to include an `email` for each\nof the people in the list, so people may contact them.\n\nMaintainers may be inherited from a parent object or propagated\nfrom child objects. When propagated, only unique *names*\nare kept.\n'
}), __metamagical_withMeta(_metamagical_withMet['licence'], {
  'name': 'licence',
  'source': 'Field.refine({\n    name: \'licence\',\n    allowInheritance: true,\n    allowPropagation: false\n  })',
  'location': {
    'filename': 'src/fields.js',
    'start': {
      'line': 160,
      'column': 17
    },
    'end': {
      'line': 814,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src/fields',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'category': 'Social Metadata',
  'stability': 'stable',
  'type': 'Field String',
  'documentation': '\nProvides the licence under which the code is released.\n\nThis is ideally a valid [SPDX index](http://spdx.org/licenses/),\nso browsers may link to the full text of the licence.\n\nLicences may be inherited from a parent object, but they may\nnot propagate.\n'
}), __metamagical_withMeta(_metamagical_withMet['since'], {
  'name': 'since',
  'source': 'Field.refine({\n    name: \'since\',\n    allowInheritance: true,\n    allowPropagation: false\n  })',
  'location': {
    'filename': 'src/fields.js',
    'start': {
      'line': 160,
      'column': 17
    },
    'end': {
      'line': 814,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src/fields',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'category': 'Social Metadata',
  'stability': 'stable',
  'type': 'Field String',
  'documentation': '\nProvides the version in which the feature was introduced.\n\nThis is ideally a valid [semantic version](http://semver.org/),\nbut might use another format if your project doesn\'t follow\nsemver.\n\nVersions may be inherited from a parent object, since child\nobjects are assumed to have been introduced at the same time\na parent was, unless otherwise noted. Versions may not be\npropagated.\n'
}), __metamagical_withMeta(_metamagical_withMet['deprecated'], {
  'name': 'deprecated',
  'source': 'Field.refine({\n    name: \'deprecated\',\n    allowInheritance: true,\n    allowPropagation: false\n  })',
  'location': {
    'filename': 'src/fields.js',
    'start': {
      'line': 160,
      'column': 17
    },
    'end': {
      'line': 814,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src/fields',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'category': 'Social Metadata',
  'stability': 'experimental',
  'type': 'type Deprecation = {\n  version: String\n  reason: String\n  replacedBy?: String\n}\n \n',
  'documentation': '\nProvides a deprecation warning for the object.\n\nWhen defined, the `deprecated` annotation must provide the\nversion in which the object was deprecated, the reason for\ndeprecating it, and whether any substitute functionality\nexists.\n\nDeprecated annotations can be inherited from parent objects,\nsince we assume that deprecating an object automatically\ndeprecates all of its children. Deprecated annotations cannot\nbe propagated.\n'
}), __metamagical_withMeta(_metamagical_withMet['repository'], {
  'name': 'repository',
  'source': 'Field.refine({\n    name: \'repository\',\n    allowInheritance: true\n  })',
  'location': {
    'filename': 'src/fields.js',
    'start': {
      'line': 160,
      'column': 17
    },
    'end': {
      'line': 814,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src/fields',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'category': 'Social Metadata',
  'stability': 'stable',
  'type': 'Field String',
  'documentation': '\nProvides the source repository where the object lives in.\n\nThis is the URL of the source repository where the project\nthat provides the object lives in.\n'
}), __metamagical_withMeta(_metamagical_withMet['stability'], {
  'name': 'stability',
  'source': 'Field.refine({\n    name: \'stability\',\n    allowInheritance: true,\n    allowPropagation: true,\n    merge(values) {\n      if (values.length === 0) {\n        return Maybe.Nothing();\n      } else {\n        return Maybe.Just(values.reduce((l, r) => {\n          const left  = Stability.fromIdentifier(l).index;\n          const right = Stability.fromIdentifier(r).index;\n\n          return left < right ?  l\n          :      /* else */      r;\n        }));\n      }\n    }\n  })',
  'location': {
    'filename': 'src/fields.js',
    'start': {
      'line': 160,
      'column': 17
    },
    'end': {
      'line': 814,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src/fields',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'category': 'Social Metadata',
  'stability': 'experimental',
  'type': 'type StabilityId = \'deprecated\'\n                 | \'experimental\'\n                 | \'stable\'\n                 | \'locked\'\nField StabilityId\n \n',
  'documentation': '\nProvides the stability of the object being described.\n\nThe stability must be a valid stability index, as defined in\nthe `Stability` object.\n\nStability can be inherited, and it can be propagated. When\npropagating, the worse stability is kept.\n'
}), __metamagical_withMeta(_metamagical_withMet['homepage'], {
  'name': 'homepage',
  'source': 'Field.refine({\n    name: \'homepage\',\n    allowInheritance: true\n  })',
  'location': {
    'filename': 'src/fields.js',
    'start': {
      'line': 160,
      'column': 17
    },
    'end': {
      'line': 814,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src/fields',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'category': 'Social Metadata',
  'stability': 'stable',
  'type': 'Field String',
  'documentation': '\nProvides an URL for the project website.\n\nHomepages can be inherited, but not propagated.\n'
}), __metamagical_withMeta(_metamagical_withMet['category'], {
  'name': 'category',
  'source': 'Field.refine({\n    name: \'category\',\n    allowInheritance: false,\n    allowPropagation: false\n  })',
  'location': {
    'filename': 'src/fields.js',
    'start': {
      'line': 160,
      'column': 17
    },
    'end': {
      'line': 814,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src/fields',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'category': 'Organisational Metadata',
  'stability': 'stable',
  'type': 'Field String',
  'documentation': '\nProvides a category for the object.\n\nLike in Smalltalk and Swift, objects in Meta:Magical are grouped\nin logical categories to make it easier for people to find the\nfunctionality they\'re looking for. This is particularly important\nwhen your object or module has several properties.\n\nWhile there are no restrictions in what one may use as a category,\nand you should try to provide a grouping that makes sense in your domain,\nthere are a few groups that are considered common:\n\n  - `Constructing`, for methods or functions that construct\n    a particular version of the object.\n  - `Comparing and Testing`, for things like `equals`, `isEmpty`,\n    and other predicates.\n  - `Transforming`, for methods like `map`, where you transform the\n    contents of the object.\n  - `Combining`, for methods like `concat`, where you combine two or more\n    objects into a new one.\n  - `Handling Errors`, for methods that provide a way of handling errors\n    captured by the object, like Promise\'s `catch`.\n\nCategories can be neither inherited or propagated.\n'
}), __metamagical_withMeta(_metamagical_withMet['tags'], {
  'name': 'tags',
  'source': 'Field.refine({\n    name: \'tags\',\n    allowInheritance: false,\n    allowPropagation: false\n  })',
  'location': {
    'filename': 'src/fields.js',
    'start': {
      'line': 160,
      'column': 17
    },
    'end': {
      'line': 814,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src/fields',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'category': 'Organisational Metadata',
  'stability': 'stable',
  'type': 'Field (Array String)',
  'documentation': '\nProvides a set of short terms related to the functionality.\n\nTags help people find functionality when searching for related\nterms. They can be neither inherited nor propagated.\n'
}), __metamagical_withMeta(_metamagical_withMet['npmPackage'], {
  'name': 'npmPackage',
  'source': 'Field.refine({\n    name: \'npmPackage\',\n    allowInheritance: true,\n    allowPropagation: false\n  })',
  'location': {
    'filename': 'src/fields.js',
    'start': {
      'line': 160,
      'column': 17
    },
    'end': {
      'line': 814,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src/fields',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'category': 'Definition Metadata',
  'stability': 'stable',
  'type': 'Field String',
  'documentation': '\nProvides the npm package the object belongs to.\n\nPackages can be inherited, but not propagated.\n'
}), __metamagical_withMeta(_metamagical_withMet['module'], {
  'name': 'module',
  'source': 'Field.refine({\n    name: \'module\',\n    allowInheritance: true,\n    allowPropagation: false\n  })',
  'location': {
    'filename': 'src/fields.js',
    'start': {
      'line': 160,
      'column': 17
    },
    'end': {
      'line': 814,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src/fields',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'category': 'Definition Metadata',
  'stability': 'stable',
  'type': 'Field String',
  'documentation': '\nProvides the module the object belongs to.\n\nThis should be the same module identifier the user can pass to\n`require()`.\n\nModules can be inherited, but not propagated.\n'
}), __metamagical_withMeta(_metamagical_withMet['isModule'], {
  'name': 'isModule',
  'source': 'Field.refine({\n    name: \'isModule\',\n    allowInheritance: false,\n    allowPropagation: false\n  })',
  'location': {
    'filename': 'src/fields.js',
    'start': {
      'line': 160,
      'column': 17
    },
    'end': {
      'line': 814,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src/fields',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'category': 'Definition Metadata',
  'stability': 'stable',
  'type': 'Field Boolean',
  'documentation': '\nTells whether the object is also a module.\n\nWhile ES6 modules are second class, CommonJS modules are first-class,\nand in Node modules may be any object. Browsers need to know whether\na particular object also doubles as a module for display purposes.\n\nThis annotation can neither be inherited nor propagated.\n'
}), __metamagical_withMeta(_metamagical_withMet['isRequired'], {
  'name': 'isRequired',
  'source': 'Field.refine({\n    name: \'isRequired\',\n    allowInheritance: false,\n    allowPropagation: false\n  })',
  'location': {
    'filename': 'src/fields.js',
    'start': {
      'line': 160,
      'column': 17
    },
    'end': {
      'line': 814,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src/fields',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'category': 'Definition Metadata',
  'stability': 'experimental',
  'type': 'Field Boolean',
  'documentation': '\nTells whether the object has an implementation or requires one\nto be provided.\n\nThis is used for getters and methods, so tools can tell users the\nexpectations of an object, and avoid running code that hasn\'t been\ndefined yet.\n\nThis annotation can neither be inherited nor propagated.\n'
}), __metamagical_withMeta(_metamagical_withMet['belongsTo'], {
  'name': 'belongsTo',
  'source': 'Field.refine({\n    name: \'belongsTo\',\n    allowInheritance: false,\n    allowPropagation: false\n  })',
  'location': {
    'filename': 'src/fields.js',
    'start': {
      'line': 160,
      'column': 17
    },
    'end': {
      'line': 814,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src/fields',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'category': 'Definition Metadata',
  'stability': 'stable',
  'type': 'Field (() => Object \'a)',
  'documentation': '\nProvides the object that defines the annotated object.\n\nIn JavaScript we can\'t ask an object where it\'s defined, and\neven if we could this would lead to multiple answers. The `belongsTo`\nannotation provides a canonical answer to this question, and is used\nfor things like methods.\n\nBecause the object containing the annotated object may not\nbe referenceable at the point where the annotated object is created,\nthis annotation requires the object to be provided as a thunk.\n\nbelongsTo may be neither inherited nor propagated.\n'
}), __metamagical_withMeta(_metamagical_withMet['name'], {
  'name': 'name',
  'source': 'Field.refine({\n    name: \'name\',\n    allowInheritance: false,\n    allowPropagation: false\n  })',
  'location': {
    'filename': 'src/fields.js',
    'start': {
      'line': 160,
      'column': 17
    },
    'end': {
      'line': 814,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src/fields',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'category': 'Definition Metadata',
  'stability': 'stable',
  'type': 'Field String',
  'documentation': '\nThe canonical name for the object being annotated.\n\nname may be neither inherited nor propagated.\n'
}), __metamagical_withMeta(_metamagical_withMet['location'], {
  'name': 'location',
  'source': 'Field.refine({\n    name: \'location\',\n    allowInheritance: false,\n    allowPropagation: false\n  })',
  'location': {
    'filename': 'src/fields.js',
    'start': {
      'line': 160,
      'column': 17
    },
    'end': {
      'line': 814,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src/fields',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'category': 'Definition Metadata',
  'stability': 'experimental',
  'type': 'type Position = {\n  line: Number,\n  column: Number\n}\n\nField {\n  filename: String,\n  start?: Position,\n  end?: Position\n}\n \n',
  'documentation': '\nThe place where the object is defined.\n\nlocation can be neither inherited nor propagated.\n'
}), __metamagical_withMeta(_metamagical_withMet['source'], {
  'name': 'source',
  'source': 'Field.refine({\n    name: \'source\',\n    allowInheritance: false,\n    allowPropagation: false\n  })',
  'location': {
    'filename': 'src/fields.js',
    'start': {
      'line': 160,
      'column': 17
    },
    'end': {
      'line': 814,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src/fields',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'category': 'Definition Metadata',
  'stability': 'stable',
  'type': 'Field String',
  'documentation': '\nThe original source code for the annotated object.\n\nsource may be neither inherited nor propagated.\n'
}), __metamagical_withMeta(_metamagical_withMet['documentation'], {
  'name': 'documentation',
  'source': 'Field.refine({\n    name: \'documentation\',\n    allowInheritance: false,\n    allowPropagation: false\n  })',
  'location': {
    'filename': 'src/fields.js',
    'start': {
      'line': 160,
      'column': 17
    },
    'end': {
      'line': 814,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src/fields',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'category': 'Definition Metadata',
  'stability': 'experimental',
  'type': 'Field String',
  'documentation': '\nThe documentation of the annotated object, in Markdown.\n\ndocumentation may be neither inherited nor propagated.\n'
}), __metamagical_withMeta(_metamagical_withMet['examples'], {
  'name': 'examples',
  'source': 'Field.refine({\n    name: \'examples\',\n    allowInheritance: false,\n    allowPropagation: false\n  })',
  'location': {
    'filename': 'src/fields.js',
    'start': {
      'line': 160,
      'column': 17
    },
    'end': {
      'line': 814,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src/fields',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'category': 'Definition Metadata',
  'stability': 'experimental',
  'type': 'type Example = {\n  name: String,\n  call: (() => None),\n  inferred?: Boolean\n}\n\nArray Example\n \n',
  'documentation': '\nAn array of example code for the annotated object.\n\nexamples may be neither inherited nor propagated.\n'
}), __metamagical_withMeta(_metamagical_withMet['signature'], {
  'name': 'signature',
  'source': 'Field.refine({\n    name: \'signature\',\n    allowInheritance: false,\n    allowPropagation: false\n  })',
  'location': {
    'filename': 'src/fields.js',
    'start': {
      'line': 160,
      'column': 17
    },
    'end': {
      'line': 814,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src/fields',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'category': 'Definition Metadata',
  'stability': 'experimental',
  'type': 'Field String',
  'documentation': '\nThe signature of the entity being annotated.\n\nThis is mostly used for functions and methods,\nand should match the way those are defined in the code,\nlike: `doStuff(value, optional = default)`\n\nsignature may be neither inherited nor propagated.\n'
}), __metamagical_withMeta(_metamagical_withMet['type'], {
  'name': 'type',
  'source': 'Field.refine({\n    name: \'type\',\n    allowInheritance: false,\n    allowPropagation: false\n  })',
  'location': {
    'filename': 'src/fields.js',
    'start': {
      'line': 160,
      'column': 17
    },
    'end': {
      'line': 814,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src/fields',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'category': 'Definition Metadata',
  'stability': 'experimental',
  'type': 'Field String',
  'documentation': '\nThe type of the entity being annotated.\n\nCurrently Meta:Magical does nothing with this field, and\nthe value is a String describing a type as described\nin [this document](https://github.com/origamitower/conventions/blob/master/documentation/type-notation.md).\n\ntype may be neither inherited nor propagated.\n'
}), __metamagical_withMeta(_metamagical_withMet['throws'], {
  'name': 'throws',
  'source': 'Field.refine({\n    name: \'throws\',\n    allowInheritance: false,\n    allowPropagation: false\n  })',
  'location': {
    'filename': 'src/fields.js',
    'start': {
      'line': 160,
      'column': 17
    },
    'end': {
      'line': 814,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src/fields',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'category': 'Definition Metadata',
  'stability': 'experimental',
  'type': 'Field (Object String)',
  'documentation': '\nDescribes all errors that may be thrown by the entity being annotated.\n\nThe value is an object where the key is the name of the error\nbeing thrown, and the value is a description of which situations\nlead to that error being thrown.\n\nthrows may be neither inherited nor propagated.\n'
}), __metamagical_withMeta(_metamagical_withMet['parameters'], {
  'name': 'parameters',
  'source': 'Field.refine({\n    name: \'parameters\',\n    allowInheritance: false,\n    allowPropagation: false\n  })',
  'location': {
    'filename': 'src/fields.js',
    'start': {
      'line': 160,
      'column': 17
    },
    'end': {
      'line': 814,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src/fields',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'category': 'Definition Metadata',
  'stability': 'experimental',
  'type': 'Field (Object String)',
  'documentation': '\nDescribes all of the parameters accepted by the entity being annotated.\n\nThe value is an object where the key is the name of the parameter,\nand the value is a short description of what it means and how it\'s\nused.\n\nLonger descriptions are more suited to the documentation metadata.\n\nparameters may be neither inherited nor propagated.\n'
}), __metamagical_withMeta(_metamagical_withMet['returns'], {
  'name': 'returns',
  'source': 'Field.refine({\n    name: \'returns\',\n    allowInheritance: false,\n    allowPropagation: false\n  })',
  'location': {
    'filename': 'src/fields.js',
    'start': {
      'line': 160,
      'column': 17
    },
    'end': {
      'line': 814,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src/fields',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'category': 'Definition Metadata',
  'stability': 'stable',
  'type': 'Field String',
  'documentation': '\nA short summary of what the entity being annotated returns when ran.\n\nreturns may be neither inherited nor propagated.\n'
}), __metamagical_withMeta(_metamagical_withMet['complexity'], {
  'name': 'complexity',
  'source': 'Field.refine({\n    name: \'complexity\',\n    allowInheritance: false,\n    allowPropagation: false\n  })',
  'location': {
    'filename': 'src/fields.js',
    'start': {
      'line': 160,
      'column': 17
    },
    'end': {
      'line': 814,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src/fields',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'category': 'Definition Metadata',
  'stability': 'experimental',
  'type': 'Field String',
  'documentation': '\nA short summary of the algorithmic complexity of the entity being annotated.\n\nThis is meant to provide only the worst case for now.\n\ncomplexity may be neither inherited nor propagated.\n'
}), __metamagical_withMeta(_metamagical_withMet['platforms'], {
  'name': 'platforms',
  'source': 'Field.refine({\n    name: \'platforms\',\n    allowInheritance: true,\n    allowPropagation: false,\n  })',
  'location': {
    'filename': 'src/fields.js',
    'start': {
      'line': 160,
      'column': 17
    },
    'end': {
      'line': 814,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src/fields',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'category': 'Execution Metadata',
  'stability': 'experimental',
  'type': 'Field (Array String)',
  'documentation': '\nA list of platforms that support the entity being annotated.\n\nPlatforms may be inherited, but not propagated.\n'
}), __metamagical_withMeta(_metamagical_withMet['portable'], {
  'name': 'portable',
  'source': 'Field.refine({\n    name: \'portable\',\n    allowInheritance: true,\n    allowPropagation: true,\n    merge(values) {\n      if (values.length === 0) {\n        return Maybe.Nothing();\n      } else {\n        return Maybe.Just(values.every(Boolean));\n      }\n    }\n  })',
  'location': {
    'filename': 'src/fields.js',
    'start': {
      'line': 160,
      'column': 17
    },
    'end': {
      'line': 814,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src/fields',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'category': 'Execution Metadata',
  'stability': 'experimental',
  'type': 'Field Boolean',
  'documentation': '\nWhether the object being annotated is portable or not.\n\nPortability can be inherited. When propagating, an entity is\nconsidered portable if all of its children are also portable.\n'
}), _metamagical_withMet), {
  'name': 'exports',
  'source': '{\n  Field: Field,\n\n  // ---[ Social Metadata ]--------------------------------------------\n\n  /*~\n   * Provides copyright information about a particular object.\n   *\n   * This is usually a String in the form of `"(c) 2016 Some Name"`,\n   * and is commonly just output as-is by the documentation browsers.\n   *\n   * Copyright may be inherited from a parent object, but it may not\n   * be propagated.\n   *\n   * ---\n   * category  : Social Metadata\n   * stability : stable\n   * type: Field String\n   */\n  copyright: Field.refine({\n    name: \'copyright\',\n    allowInheritance: true,\n    allowPropagation: false\n  }),\n\n  /*~\n   * Provides a list of people who have authored the object.\n   *\n   * This is an array of Person objects, where a Person must\n   * at least have a `name` field, but may also include\n   * additional contact information:\n   *\n   *     { name: "Quildreen Motta", email: "queen@robotlolita.me" }\n   *\n   * Authors may be inherited from a parent object or propagated\n   * from children objects. When propagated, only unique *names*\n   * are kept.\n   *\n   * ---\n   * category  : Social Metadata\n   * stability : experimental\n   * type: |\n   *   type Person = {\n   *     name: String,\n   *     email?: String,\n   *     url?: String\n   *   }\n   *   Field (Array Person)\n   */\n  authors: Field.refine({\n    name: \'authors\',\n    allowInheritance: true,\n    allowPropagation: true,\n    merge(values) {\n      return Maybe.Just(unique(flatten(values)));\n    }\n  }),\n\n  /*~\n   * Provides a list of people who maintain the object.\n   *\n   * This is an array of Person objects, where a Person must\n   * at least have a `name` field, but may also include\n   * additional contact information:\n   *\n   *     { name: "Quildreen Motta", email: "queen@robotlolita.me" }\n   *\n   * Because this field is used to present the people who are in\n   * charge of fixing bugs in the object or adding new features to\n   * it, it\'s strongly recommended to include an `email` for each\n   * of the people in the list, so people may contact them.\n   *\n   * Maintainers may be inherited from a parent object or propagated\n   * from child objects. When propagated, only unique *names*\n   * are kept.\n   *\n   * ---\n   * category  : Social Metadata\n   * stability : experimental\n   * type: |\n   *   type Person = {\n   *     name: String,\n   *     email?: Email,\n   *     url?: String\n   *   }\n   *   Field (Array Person)\n   */\n  maintainers: Field.refine({\n    name: \'maintainers\',\n    allowInheritance: true,\n    allowPropagation: true,\n    merge(values) {\n      return Maybe.Just(unique(flatten(values)));\n    }\n  }),\n\n  /*~\n   * Provides the licence under which the code is released.\n   *\n   * This is ideally a valid [SPDX index](http://spdx.org/licenses/),\n   * so browsers may link to the full text of the licence.\n   *\n   * Licences may be inherited from a parent object, but they may\n   * not propagate.\n   *\n   * ---\n   * category  : Social Metadata\n   * stability : stable\n   * type: Field String\n   */\n  licence: Field.refine({\n    name: \'licence\',\n    allowInheritance: true,\n    allowPropagation: false\n  }),\n\n  /*~\n   * Provides the version in which the feature was introduced.\n   *\n   * This is ideally a valid [semantic version](http://semver.org/),\n   * but might use another format if your project doesn\'t follow\n   * semver.\n   *\n   * Versions may be inherited from a parent object, since child\n   * objects are assumed to have been introduced at the same time\n   * a parent was, unless otherwise noted. Versions may not be\n   * propagated.\n   *\n   * ---\n   * category  : Social Metadata\n   * stability : stable\n   * type: Field String\n   */\n  since: Field.refine({\n    name: \'since\',\n    allowInheritance: true,\n    allowPropagation: false\n  }),\n\n  /*~\n   * Provides a deprecation warning for the object.\n   *\n   * When defined, the `deprecated` annotation must provide the\n   * version in which the object was deprecated, the reason for\n   * deprecating it, and whether any substitute functionality\n   * exists.\n   *\n   * Deprecated annotations can be inherited from parent objects,\n   * since we assume that deprecating an object automatically\n   * deprecates all of its children. Deprecated annotations cannot\n   * be propagated.\n   *\n   * ---\n   * category  : Social Metadata\n   * stability : experimental\n   * type: |\n   *   type Deprecation = {\n   *     version: String\n   *     reason: String\n   *     replacedBy?: String\n   *   }\n   */\n  deprecated: Field.refine({\n    name: \'deprecated\',\n    allowInheritance: true,\n    allowPropagation: false\n  }),\n\n  /*~\n   * Provides the source repository where the object lives in.\n   *\n   * This is the URL of the source repository where the project\n   * that provides the object lives in.\n   *\n   * ---\n   * category  : Social Metadata\n   * stability : stable\n   * type: Field String\n   */\n  repository: Field.refine({\n    name: \'repository\',\n    allowInheritance: true\n  }),\n\n  /*~\n   * Provides the stability of the object being described.\n   *\n   * The stability must be a valid stability index, as defined in\n   * the `Stability` object.\n   *\n   * Stability can be inherited, and it can be propagated. When\n   * propagating, the worse stability is kept.\n   *\n   * ---\n   * category  : Social Metadata\n   * stability : experimental\n   * type: |\n   *   type StabilityId = \'deprecated\'\n   *                    | \'experimental\'\n   *                    | \'stable\'\n   *                    | \'locked\'\n   *   Field StabilityId\n   */\n  stability: Field.refine({\n    name: \'stability\',\n    allowInheritance: true,\n    allowPropagation: true,\n    merge(values) {\n      if (values.length === 0) {\n        return Maybe.Nothing();\n      } else {\n        return Maybe.Just(values.reduce((l, r) => {\n          const left  = Stability.fromIdentifier(l).index;\n          const right = Stability.fromIdentifier(r).index;\n\n          return left < right ?  l\n          :      /* else */      r;\n        }));\n      }\n    }\n  }),\n\n  /*~\n   * Provides an URL for the project website.\n   *\n   * Homepages can be inherited, but not propagated.\n   *\n   * ---\n   * category  : Social Metadata\n   * stability : stable\n   * type: Field String\n   */\n  homepage: Field.refine({\n    name: \'homepage\',\n    allowInheritance: true\n  }),\n\n\n  // ---[ Organisational Metadata ]------------------------------------\n\n  /*~\n   * Provides a category for the object.\n   *\n   * Like in Smalltalk and Swift, objects in Meta:Magical are grouped\n   * in logical categories to make it easier for people to find the\n   * functionality they\'re looking for. This is particularly important\n   * when your object or module has several properties.\n   *\n   * While there are no restrictions in what one may use as a category,\n   * and you should try to provide a grouping that makes sense in your domain,\n   * there are a few groups that are considered common:\n   *\n   *   - `Constructing`, for methods or functions that construct\n   *     a particular version of the object.\n   *   - `Comparing and Testing`, for things like `equals`, `isEmpty`,\n   *     and other predicates.\n   *   - `Transforming`, for methods like `map`, where you transform the\n   *     contents of the object.\n   *   - `Combining`, for methods like `concat`, where you combine two or more\n   *     objects into a new one.\n   *   - `Handling Errors`, for methods that provide a way of handling errors\n   *     captured by the object, like Promise\'s `catch`.\n   *\n   * Categories can be neither inherited or propagated.\n   *\n   * ---\n   * category  : Organisational Metadata\n   * stability : stable\n   * type: Field String\n   */\n  category: Field.refine({\n    name: \'category\',\n    allowInheritance: false,\n    allowPropagation: false\n  }),\n\n  /*~\n   * Provides a set of short terms related to the functionality.\n   *\n   * Tags help people find functionality when searching for related\n   * terms. They can be neither inherited nor propagated.\n   *\n   * ---\n   * category  : Organisational Metadata\n   * stability : stable\n   * type: Field (Array String)\n   */\n  tags: Field.refine({\n    name: \'tags\',\n    allowInheritance: false,\n    allowPropagation: false\n  }),\n\n\n  // ---[ Definition Metadata ]----------------------------------------\n\n  /*~\n   * Provides the npm package the object belongs to.\n   *\n   * Packages can be inherited, but not propagated.\n   *\n   * ---\n   * category  : Definition Metadata\n   * stability : stable\n   * type: Field String\n   */\n  npmPackage: Field.refine({\n    name: \'npmPackage\',\n    allowInheritance: true,\n    allowPropagation: false\n  }),\n\n  /*~\n   * Provides the module the object belongs to.\n   *\n   * This should be the same module identifier the user can pass to\n   * `require()`.\n   *\n   * Modules can be inherited, but not propagated.\n   *\n   * ---\n   * category  : Definition Metadata\n   * stability : stable\n   * type: Field String\n   */\n  module: Field.refine({\n    name: \'module\',\n    allowInheritance: true,\n    allowPropagation: false\n  }),\n\n  /*~\n   * Tells whether the object is also a module.\n   *\n   * While ES6 modules are second class, CommonJS modules are first-class,\n   * and in Node modules may be any object. Browsers need to know whether\n   * a particular object also doubles as a module for display purposes.\n   *\n   * This annotation can neither be inherited nor propagated.\n   *\n   * ---\n   * category  : Definition Metadata\n   * stability : stable\n   * type: Field Boolean\n   */\n  isModule: Field.refine({\n    name: \'isModule\',\n    allowInheritance: false,\n    allowPropagation: false\n  }),\n\n  /*~\n   * Tells whether the object has an implementation or requires one\n   * to be provided.\n   *\n   * This is used for getters and methods, so tools can tell users the\n   * expectations of an object, and avoid running code that hasn\'t been\n   * defined yet.\n   *\n   * This annotation can neither be inherited nor propagated.\n   *\n   * ---\n   * category  : Definition Metadata\n   * stability : experimental\n   * type: Field Boolean\n   */\n  isRequired: Field.refine({\n    name: \'isRequired\',\n    allowInheritance: false,\n    allowPropagation: false\n  }),\n\n  /*~\n   * Provides the object that defines the annotated object.\n   *\n   * In JavaScript we can\'t ask an object where it\'s defined, and\n   * even if we could this would lead to multiple answers. The `belongsTo`\n   * annotation provides a canonical answer to this question, and is used\n   * for things like methods.\n   *\n   * Because the object containing the annotated object may not\n   * be referenceable at the point where the annotated object is created,\n   * this annotation requires the object to be provided as a thunk.\n   *\n   * belongsTo may be neither inherited nor propagated.\n   *\n   * ---\n   * category  : Definition Metadata\n   * stability : stable\n   * type: Field (() => Object \'a)\n   */\n  belongsTo: Field.refine({\n    name: \'belongsTo\',\n    allowInheritance: false,\n    allowPropagation: false\n  }),\n\n  /*~\n   * The canonical name for the object being annotated.\n   *\n   * name may be neither inherited nor propagated.\n   *\n   * ---\n   * category  : Definition Metadata\n   * stability : stable\n   * type: Field String\n   */\n  name: Field.refine({\n    name: \'name\',\n    allowInheritance: false,\n    allowPropagation: false\n  }),\n\n  /*~\n   * The place where the object is defined.\n   *\n   * location can be neither inherited nor propagated.\n   *\n   * ---\n   * category  : Definition Metadata\n   * stability : experimental\n   * type: |\n   *   type Position = {\n   *     line: Number,\n   *     column: Number\n   *   }\n   *\n   *   Field {\n   *     filename: String,\n   *     start?: Position,\n   *     end?: Position\n   *   }\n   */\n  location: Field.refine({\n    name: \'location\',\n    allowInheritance: false,\n    allowPropagation: false\n  }),\n\n  /*~\n   * The original source code for the annotated object.\n   *\n   * source may be neither inherited nor propagated.\n   *\n   * ---\n   * category  : Definition Metadata\n   * stability : stable\n   * type: Field String\n   */\n  source: Field.refine({\n    name: \'source\',\n    allowInheritance: false,\n    allowPropagation: false\n  }),\n\n\n  // ---[ Usage Metadata ]---------------------------------------------\n  /*~\n   * The documentation of the annotated object, in Markdown.\n   *\n   * documentation may be neither inherited nor propagated.\n   *\n   * ---\n   * category  : Definition Metadata\n   * stability : experimental\n   * type: Field String\n   */\n  documentation: Field.refine({\n    name: \'documentation\',\n    allowInheritance: false,\n    allowPropagation: false\n  }),\n\n  /*~\n   * An array of example code for the annotated object.\n   *\n   * examples may be neither inherited nor propagated.\n   *\n   * ---\n   * category  : Definition Metadata\n   * stability : experimental\n   * type: |\n   *   type Example = {\n   *     name: String,\n   *     call: (() => None),\n   *     inferred?: Boolean\n   *   }\n   *\n   *   Array Example\n   */\n  examples: Field.refine({\n    name: \'examples\',\n    allowInheritance: false,\n    allowPropagation: false\n  }),\n\n  /*~\n   * The signature of the entity being annotated.\n   *\n   * This is mostly used for functions and methods,\n   * and should match the way those are defined in the code,\n   * like: `doStuff(value, optional = default)`\n   *\n   * signature may be neither inherited nor propagated.\n   *\n   * ---\n   * category  : Definition Metadata\n   * stability : experimental\n   * type: Field String\n   */\n  signature: Field.refine({\n    name: \'signature\',\n    allowInheritance: false,\n    allowPropagation: false\n  }),\n\n  /*~\n   * The type of the entity being annotated.\n   *\n   * Currently Meta:Magical does nothing with this field, and\n   * the value is a String describing a type as described\n   * in [this document](https://github.com/origamitower/conventions/blob/master/documentation/type-notation.md).\n   *\n   * type may be neither inherited nor propagated.\n   *\n   * ---\n   * category  : Definition Metadata\n   * stability : experimental\n   * type: Field String\n   */\n  type: Field.refine({\n    name: \'type\',\n    allowInheritance: false,\n    allowPropagation: false\n  }),\n\n  /*~\n   * Describes all errors that may be thrown by the entity being annotated.\n   *\n   * The value is an object where the key is the name of the error\n   * being thrown, and the value is a description of which situations\n   * lead to that error being thrown.\n   *\n   * throws may be neither inherited nor propagated.\n   *\n   * ---\n   * category  : Definition Metadata\n   * stability : experimental\n   * type: Field (Object String)\n   */\n  throws: Field.refine({\n    name: \'throws\',\n    allowInheritance: false,\n    allowPropagation: false\n  }),\n\n  /*~\n   * Describes all of the parameters accepted by the entity being annotated.\n   *\n   * The value is an object where the key is the name of the parameter,\n   * and the value is a short description of what it means and how it\'s\n   * used.\n   *\n   * Longer descriptions are more suited to the documentation metadata.\n   *\n   * parameters may be neither inherited nor propagated.\n   *\n   * ---\n   * category  : Definition Metadata\n   * stability : experimental\n   * type: Field (Object String)\n   */\n  parameters: Field.refine({\n    name: \'parameters\',\n    allowInheritance: false,\n    allowPropagation: false\n  }),\n\n  /*~\n   * A short summary of what the entity being annotated returns when ran.\n   *\n   * returns may be neither inherited nor propagated.\n   *\n   * ---\n   * category  : Definition Metadata\n   * stability : stable\n   * type: Field String\n   */\n  returns: Field.refine({\n    name: \'returns\',\n    allowInheritance: false,\n    allowPropagation: false\n  }),\n\n  /*~\n   * A short summary of the algorithmic complexity of the entity being annotated.\n   *\n   * This is meant to provide only the worst case for now.\n   *\n   * complexity may be neither inherited nor propagated.\n   *\n   * ---\n   * category  : Definition Metadata\n   * stability : experimental\n   * type: Field String\n   */\n  complexity: Field.refine({\n    name: \'complexity\',\n    allowInheritance: false,\n    allowPropagation: false\n  }),\n\n\n  // ---[ Execution Metadata ]-----------------------------------------\n  /*~\n   * A list of platforms that support the entity being annotated.\n   *\n   * Platforms may be inherited, but not propagated.\n   *\n   * ---\n   * category  : Execution Metadata\n   * stability : experimental\n   * type: Field (Array String)\n   */\n  platforms: Field.refine({\n    name: \'platforms\',\n    allowInheritance: true,\n    allowPropagation: false,\n  }),\n\n  /*~\n   * Whether the object being annotated is portable or not.\n   *\n   * Portability can be inherited. When propagating, an entity is\n   * considered portable if all of its children are also portable.\n   *\n   * ---\n   * category  : Execution Metadata\n   * stability : experimental\n   * type: Field Boolean\n   */\n  portable: Field.refine({\n    name: \'portable\',\n    allowInheritance: true,\n    allowPropagation: true,\n    merge(values) {\n      if (values.length === 0) {\n        return Maybe.Nothing();\n      } else {\n        return Maybe.Just(values.every(Boolean));\n      }\n    }\n  })\n\n}',
  'location': {
    'filename': 'src/fields.js',
    'start': {
      'line': 160,
      'column': 0
    },
    'end': {
      'line': 814,
      'column': 2
    }
  },
  'module': 'metamagical-interface/lib/fields',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'isModule': true,
  'documentation': '\nThis module provides a set of built-in fields that Meta:Magical\nknows about, as well as a way of defining new fields.\n'
});
},{"./stability":389,"data.maybe":350,"refinable":393}],387:[function(require,module,exports){
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var __metamagical_withMeta = function metamagical_withMeta(object, meta) {
  var parent = Object.getPrototypeOf(object);var oldMeta = object[Symbol.for('@@meta:magical')] || {};if (parent && parent[Symbol.for('@@meta:magical')] === oldMeta) {
    oldMeta = {};
  }Object.keys(meta).forEach(function (key) {
    if (/^~/.test(key)) {
      oldMeta[key.slice(1)] = meta[key];
    } else {
      oldMeta[key] = meta[key];
    }
  });object[Symbol.for('@@meta:magical')] = oldMeta;return object;
},
    _Refinable$refine,
    __metamagical_assert_equals = function metamagical_assert_equals(assert, actual, expected, message) {
  var assertionType = Symbol.for('@@meta:magical:assertion-type');var rest = Symbol.for('@@meta:magical:assertion-rest');var keys = Object.keys;function isSetoid(value) {
    return value && typeof value.equals === 'function';
  }function isRecord(value) {
    return value && value[assertionType] === 'record';
  }
  function check(predicate) {
    for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }return values.every(predicate);
  }function getSpecialArrayLength(array) {
    var rests = array.map(function (x, i) {
      return [x, i];
    }).filter(function (pair) {
      return pair[0] === rest;
    });if (rests.length > 1 || rests[0] && rests[0][1] !== array.length - 1) {
      assert.ok(false, message);
    }return (rests[0] || [null, array.length])[1];
  }function compareArrays(left, right) {
    var expectedLength = getSpecialArrayLength(right);assert.ok(Array.isArray(left), message);if (left.length < expectedLength) {
      assert.ok(false, message);
    }for (var i = 0; i < expectedLength; ++i) {
      compare(left[i], right[i]);
    }
  }function compareRecord(left, right) {
    var isPartial = right[rest];assert.ok(Object(left) === left, message);if (!isPartial) {
      assert.deepStrictEqual(keys(left).sort(), keys(right).sort(), message);
    }Object.keys(right).forEach(function (key) {
      if (!(key in left)) {
        assert.ok(false, message);
      }compare(left[key], right[key]);
    });
  }function compare(l, r) {
    return check(isSetoid, l, r) ? assert.ok(l.equals(r), message) : Array.isArray(r) ? compareArrays(l, r) : isRecord(r) ? compareRecord(l, r) : /* otherwise */assert.deepStrictEqual(l, r, message);
  }compare(actual, expected);
};

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

//---------------------------------------------------------------------
//
// This source file is part of the Meta:Magical project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//---------------------------------------------------------------------

// --[ Shared State ]--------------------------------------------------
var metadata = new WeakMap();
var metaSymbol = Symbol.for('@@meta:magical');

// --[ Dependencies ]--------------------------------------------------
var Refinable = require('refinable');
var Maybe = require('data.maybe');

var _require = require('./assertions');

var assertObject = _require.assertObject;

var fields = require('./fields');
var Stability = require('./stability');
var Primitive = require('./primitives');

// --[ Aliases ]-------------------------------------------------------
var symbols = Object.getOwnPropertySymbols;
var propertiesOf = Object.getOwnPropertyNames;
var keys = Object.keys;
var hasProperty = Function.call.bind(Object.prototype.hasOwnProperty);
var prototypeOf = Object.getPrototypeOf;

// --[ Helpers ]-------------------------------------------------------

/*~
 * Returns a getter or setter in an object.
 */
function getGetterSetter(object, name, kind) {
  if (hasProperty(object, name)) {
    var descriptor = descriptorOf(object, name);
    return descriptor[kind] ? Maybe.Just(descriptor[kind]) : /* otherwise */Maybe.Nothing();
  } else {
    return Maybe.Nothing();
  }
}

/*~
 * Retrieves meta-data from an object (either set directly or associated
 * through the global `WeakMap`).
 */

__metamagical_withMeta(getGetterSetter, {
  'name': 'getGetterSetter',
  'source': 'function getGetterSetter(object, name, kind) {\n  if (hasProperty(object, name)) {\n    const descriptor = descriptorOf(object, name);\n    return descriptor[kind] ?  Maybe.Just(descriptor[kind])\n    :      /* otherwise */     Maybe.Nothing();\n  } else {\n    return Maybe.Nothing();\n  }\n}',
  'signature': 'getGetterSetter(object, name, kind)',
  'location': {
    'filename': 'src/index.js',
    'start': {
      'line': 37,
      'column': 0
    },
    'end': {
      'line': 45,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'documentation': '\nReturns a getter or setter in an object.\n '
});

function getMeta(object) {
  assertObject(object);

  var data = {};
  if (hasOwnSymbol(object, metaSymbol)) {
    Object.assign(data, object[metaSymbol] || {});
  }
  Object.assign(data, metadata.get(object) || {});

  return data;
}

/*~
 * Tests if something is an object.
 */

__metamagical_withMeta(getMeta, {
  'name': 'getMeta',
  'source': 'function getMeta(object) {\n  assertObject(object);\n\n  let data = {};\n  if (hasOwnSymbol(object, metaSymbol)) {\n    Object.assign(data, object[metaSymbol] || {});\n  }\n  Object.assign(data, metadata.get(object) || {});\n\n  return data;\n}',
  'signature': 'getMeta(object)',
  'location': {
    'filename': 'src/index.js',
    'start': {
      'line': 51,
      'column': 0
    },
    'end': {
      'line': 61,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'documentation': '\nRetrieves meta-data from an object (either set directly or associated\nthrough the global `WeakMap`).\n '
});

function isObject(x) {
  return Object(x) === x;
}

/*~
 * Flattens one level of a list of lists.
 * ---
 * complexity: O(`xss.length`)
 */

__metamagical_withMeta(isObject, {
  'name': 'isObject',
  'source': 'function isObject(x) {\n  return Object(x) === x;\n}',
  'signature': 'isObject(x)',
  'location': {
    'filename': 'src/index.js',
    'start': {
      'line': 67,
      'column': 0
    },
    'end': {
      'line': 69,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'documentation': '\nTests if something is an object.\n '
});

function flatten(xss) {
  return xss.reduce(function (ys, xs) {
    return ys.concat(xs);
  }, []);
}

/*~
 * Checks if an object has a symbol defined in itself.
 */

__metamagical_withMeta(flatten, {
  'name': 'flatten',
  'source': 'function flatten(xss) {\n  return xss.reduce((ys, xs) => ys.concat(xs), []);\n}',
  'signature': 'flatten(xss)',
  'location': {
    'filename': 'src/index.js',
    'start': {
      'line': 77,
      'column': 0
    },
    'end': {
      'line': 79,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'complexity': 'O(`xss.length`)',
  'documentation': '\nFlattens one level of a list of lists.'
});

function hasOwnSymbol(object, symbol) {
  return symbols(object).indexOf(symbol) !== -1;
}

/*~
 * Groups values based on the grouping function provided.
 * ---
 * complexity: O(`xs.length`)
 */

__metamagical_withMeta(hasOwnSymbol, {
  'name': 'hasOwnSymbol',
  'source': 'function hasOwnSymbol(object, symbol) {\n  return symbols(object).indexOf(symbol) !== -1;\n}',
  'signature': 'hasOwnSymbol(object, symbol)',
  'location': {
    'filename': 'src/index.js',
    'start': {
      'line': 85,
      'column': 0
    },
    'end': {
      'line': 87,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'documentation': '\nChecks if an object has a symbol defined in itself.\n '
});

function groupBy(values, groupingFn) {
  var result = new Map();

  values.forEach(function (value) {
    var key = groupingFn(value);
    var values = result.get(key) || [];

    values.push(value);
    result.set(key, values);
  });

  return Array.from(result.entries());
}

/*~
 * Returns the descriptor searching upwards the prototype chain.
 */

__metamagical_withMeta(groupBy, {
  'name': 'groupBy',
  'source': 'function groupBy(values, groupingFn) {\n  let result = new Map();\n\n  values.forEach(value => {\n    const key    = groupingFn(value);\n    const values = result.get(key) || [];\n\n    values.push(value);\n    result.set(key, values);\n  });\n\n  return Array.from(result.entries());\n}',
  'signature': 'groupBy(values, groupingFn)',
  'location': {
    'filename': 'src/index.js',
    'start': {
      'line': 94,
      'column': 0
    },
    'end': {
      'line': 106,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'complexity': 'O(`xs.length`)',
  'documentation': '\nGroups values based on the grouping function provided.'
});

function descriptorOf(object, name) {
  var descriptor = Object.getOwnPropertyDescriptor(object, name);
  if (descriptor) {
    return descriptor;
  } else {
    var proto = prototypeOf(object);
    if (proto) {
      return descriptorOf(proto, name);
    } else {
      return null;
    }
  }
}

/*~
 * Returns an array of property names in an object.
 * ---
 * complexity: O(number of enumberable properties)
 */

__metamagical_withMeta(descriptorOf, {
  'name': 'descriptorOf',
  'source': 'function descriptorOf(object, name) {\n  const descriptor = Object.getOwnPropertyDescriptor(object, name);\n  if (descriptor) {\n    return descriptor;\n  } else {\n    const proto = prototypeOf(object);\n    if (proto) {\n      return descriptorOf(proto, name);\n    } else {\n      return null;\n    }\n  }\n}',
  'signature': 'descriptorOf(object, name)',
  'location': {
    'filename': 'src/index.js',
    'start': {
      'line': 111,
      'column': 0
    },
    'end': {
      'line': 123,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'documentation': '\nReturns the descriptor searching upwards the prototype chain.\n '
});

function allPropertiesOf(object) {
  function go(object) {
    var proto = prototypeOf(object);

    return proto ? propertiesOf(object).concat(go(proto)) : /* else */propertiesOf(object);
  }

  return Array.from(new Set(go(object)));
}

/*~
 * Converts an array of property names into an array of Entry.
 * ---
 * complexity: O(properties.length)
 */

__metamagical_withMeta(allPropertiesOf, {
  'name': 'allPropertiesOf',
  'source': 'function allPropertiesOf(object) {\n  function go(object) {\n    const proto = prototypeOf(object);\n\n    return proto       ?  propertiesOf(object).concat(go(proto))\n    :      /* else */     propertiesOf(object);\n  }\n\n  return Array.from(new Set(go(object)));\n}',
  'signature': 'allPropertiesOf(object)',
  'location': {
    'filename': 'src/index.js',
    'start': {
      'line': 130,
      'column': 0
    },
    'end': {
      'line': 139,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'complexity': 'O(number of enumberable properties)',
  'documentation': '\nReturns an array of property names in an object.'
});

function toEntries(object, properties) {
  return flatten(properties.map(function (name) {
    var p = descriptorOf(object, name);

    var result = [];

    if (p.get) {
      result.push({ name: name, value: p.get, kind: 'getter' });
    }
    if (p.set) {
      result.push({ name: name, value: p.set, kind: 'setter' });
    }
    if (p.value) {
      result.push({ name: name, value: p.value, kind: 'value' });
    }

    return result;
  }));
}

/*~
 * Returns an array of `key, descriptor` pairs for all own properties
 * in an object.
 * ---
 * complexity: O(number of own properties)
 */

__metamagical_withMeta(toEntries, {
  'name': 'toEntries',
  'source': 'function toEntries(object, properties) {\n  return flatten(properties.map(name => {\n    const p = descriptorOf(object, name);\n\n    let result = [];\n\n    if (p.get) {\n      result.push({ name, value: p.get, kind: \'getter\' });\n    }\n    if (p.set) {\n      result.push({ name, value: p.set, kind: \'setter\' });\n    }\n    if (p.value) {\n      result.push({ name, value: p.value, kind: \'value\' });\n    }\n\n    return result;\n  }));\n}',
  'signature': 'toEntries(object, properties)',
  'location': {
    'filename': 'src/index.js',
    'start': {
      'line': 146,
      'column': 0
    },
    'end': {
      'line': 164,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'complexity': 'O(properties.length)',
  'documentation': '\nConverts an array of property names into an array of Entry.'
});

function entriesOf(object) {
  return toEntries(object, propertiesOf(object));
}

/*~
 * Returns an array of `key, descriptor` pairs for all properties
 * in an object.
 * ---
 * complexity: O(number of properties)
 */

__metamagical_withMeta(entriesOf, {
  'name': 'entriesOf',
  'source': 'function entriesOf(object) {\n  return toEntries(object, propertiesOf(object));\n}',
  'signature': 'entriesOf(object)',
  'location': {
    'filename': 'src/index.js',
    'start': {
      'line': 172,
      'column': 0
    },
    'end': {
      'line': 174,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'complexity': 'O(number of own properties)',
  'documentation': '\nReturns an array of `key, descriptor` pairs for all own properties\nin an object.'
});

function allEntriesOf(object) {
  return toEntries(object, allPropertiesOf(object));
}

/*~
 * Compares two comparable objects.
 */

__metamagical_withMeta(allEntriesOf, {
  'name': 'allEntriesOf',
  'source': 'function allEntriesOf(object) {\n  return toEntries(object, allPropertiesOf(object));\n}',
  'signature': 'allEntriesOf(object)',
  'location': {
    'filename': 'src/index.js',
    'start': {
      'line': 182,
      'column': 0
    },
    'end': {
      'line': 184,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'complexity': 'O(number of properties)',
  'documentation': '\nReturns an array of `key, descriptor` pairs for all properties\nin an object.'
});

function compare(a, b) {
  return a < b ? -1 : a > b ? 1 : /* else */0;
}

/*~
 * Compares two categories.
 */

__metamagical_withMeta(compare, {
  'name': 'compare',
  'source': 'function compare(a, b) {\n  return a < b      ?  -1\n  :      a > b      ?   1\n  :      /* else */     0;\n}',
  'signature': 'compare(a, b)',
  'location': {
    'filename': 'src/index.js',
    'start': {
      'line': 189,
      'column': 0
    },
    'end': {
      'line': 193,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'documentation': '\nCompares two comparable objects.\n '
});

function compareCategories(a, b) {
  return a === b ? 0 : a === '(Uncategorised)' ? 1 : b === '(Uncategorised)' ? -1 : /* otherwise */compare(a, b);
}

/*~
 * Returns a list of categories for the given properties.
 */

__metamagical_withMeta(compareCategories, {
  'name': 'compareCategories',
  'source': 'function compareCategories(a, b) {\n  return a === b                 ?   0\n  :      a === \'(Uncategorised)\' ?   1\n  :      b === \'(Uncategorised)\' ?  -1\n  :      /* otherwise */            compare(a, b);\n}',
  'signature': 'compareCategories(a, b)',
  'location': {
    'filename': 'src/index.js',
    'start': {
      'line': 198,
      'column': 0
    },
    'end': {
      'line': 203,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'documentation': '\nCompares two categories.\n '
});

function categoriseProperties(meta, entries) {
  var byName = function byName(a, b) {
    return compare(a.name, b.name);
  };
  var byCategory = function byCategory(a, b) {
    return compareCategories(a.category, b.category);
  };

  var asCategoryObject = function asCategoryObject(_ref) {
    var _ref2 = _slicedToArray(_ref, 2);

    var category = _ref2[0];
    var members = _ref2[1];
    return { category: category, members: members };
  };

  var category = function category(_ref3) {
    var value = _ref3.value;
    return isObject(value) ? meta.for(value).get(meta.fields.category).getOrElse('(Uncategorised)') : /* else */'(Uncategorised)';
  };

  return groupBy(entries.sort(byName), category).map(asCategoryObject).sort(byCategory);
}

// --[ The Meta:Magical Interface ]------------------------------------

/*~
 * The Meta:Magical interface allows one to query meta-data associated
 * with a particular object, or attach new meta-data to any object
 * without modifying the object.
 *
 *
 * ## Why?
 *
 * Languages like Python, Ruby, Clojure, Smalltalk, and others support
 * interactively exploring their world of objects. For example, in
 * Python, one is able to look at the documentation of an object through
 * the `__doc__` property. In Smalltalk, the platform's browser tells
 * you what classes you have, which methods are available on them, their
 * source code, documentation, all in a searchable interactive
 * environment.
 *
 * JavaScript has a very limited support for this kind of reflective
 * capabilities. One may, for example, ask which properties an object
 * has, what's the name of a function, or its source, but there isn't
 * much beyond that which we could benefit from while exploring a
 * particular library in the REPL. There's nothing in JavaScript that
 * reifies a concept of documentation, making it accessible at runtime.
 *
 * In order to support a more exploration-driven interactive development
 * of applications, and even more accurate documentation in more static
 * forms (given that JavaScript is too dynamic to lend itself well to
 * static analysis documentation tools usually rely on), Meta:Magical
 * allows people to attach new, arbitrary meta-data to any object in the
 * system, and query that meta-data later.
 *
 * The Meta:Magical project is heavily influenced by work on Smalltalk
 * reflective environments, and Clojure's take on meta annotations for
 * runtime values, and this interface aims to be the basis of better
 * tooling for discoverable interactive environments and documentation
 * tools.
 *
 *
 * ## How Meta:Magical handles metadata?
 *
 * JavaScript has a prototype-based object-orientation model, which
 * basically means that each object defines its own layout (the methods,
 * properties, fields, etc. it has), rather than linking to a class that
 * defines such. Alongside the possibility of adding or modifying
 * properties in an object at any time, and the new `Symbol` feature,
 * this allows us to attach arbitrary meta-data to any object without
 * risking conflicts.
 *
 * There are two ways in which Meta:Magical supports attaching meta-data
 * to an object:
 *
 *   - By assigning an object to the global Meta:Magical symbol:
 *
 *         object[Symbol.for('@@meta:magical')] = { ... };
 *
 *   - By using the Interface's `.set()` method, which assigns meta-data
 *     to an object using an internal `WeakMap` to avoid problems
 *     modifying non-owned objects, specially those that have been
 *     frozen::
 *
 *         const frozen = Object.freeze({});
 *         Interface.for(frozen).set('name', 'frozen');
 *
 * Meta-data associated with an object through the `WeakMap` has
 * precedence over meta-data attached directly on the object, as a
 * property. This allows people to refine existing meta-data and provide
 * new ones for objects from the outside.
 *
 *
 * ## Querying meta-data
 *
 * The Meta:Magical interface is an object that wraps another object,
 * and lets you reflect over meta-properties associated with that
 * object, by both querying or updating them.
 *
 * The `object` method defines which object this interface is looking
 * at. By default, the interface starts looking at itself, but it can be
 * refined to look at another object, which can be done by inheriting
 * from it explicitly or just using the `.for()` method::
 *
 *     Interface.getByName('name').get();
 *     // ==> 'Interface'
 *
 *     const getInterface = Interface.for(Interface.getByName);
 *     getInterface.getByName('name').get();
 *     // ==> 'getByName'
 *
 *     const myInterface = getInterface.for(Interface);
 *     myInterface.getByName('name').get();
 *     // ==> 'Interface'
 *
 * At any point you can use the `object` method to retrieve the
 * object the interface is looking at::
 *
 *     Interface.object
 *     // ==> Interface
 *
 *
 * ### Containership and Inheritance
 *
 * Objects form hierarchies of data, but given a JavaScript object
 * one is only able to ask which objects are under that, it's not
 * possible to query which objects contains a particular value.
 * This makes interactive exploration in a REPL harder, because
 * we can't figure out the context of a particular value (where
 * does this belong to?).
 *
 * To solve this, Meta:Magical introduces a special piece of metadata,
 * `belongsTo`, which lazily provides the missing link::
 *
 *     const root = {
 *       child: { }
 *     };
 *     root.child[Symbol.for('@@meta:magical')] = {
 *       belongsTo() { return root },
 *       name: 'child'
 *     };
 *
 * This allows one to retrieve which object canonically holds the
 * definition of a particular value. So, if one has a function like
 * `get`, they can retrieve the broader context in which this function
 * lives::
 *
 *     const getMeta = Interface.for(Interface.get);
 *     getMeta.getByName('belongsTo').getOrElse(null)();
 *     // ==> Interface
 *
 * Internally, Meta:Magical uses this information to propagate some
 * metadata from the broader context (parent object) to the current
 * context. Things such as `licence`, `repository`, `copyright`, and
 * others allow this kind of inheritance::
 *
 *     root[Symbol.for('@@meta:magical')] = {
 *       licence: 'CC0'
 *     };
 *
 *     Interface.for(root.child).getInheritedMeta('licence').getOrElse(null);
 *     // ==> 'CC0'
 *
 *
 * ### Propagation
 *
 * Another aspect that's important when you have a hierarchy of objects
 * is that objects are made out of several smaller pieces. And these
 * pieces impact the metadata about the top objects. For example, if
 * a module contains a single experimental function, then it might make
 * sense to mark the module as experimental.
 *
 * Meta:Magical supports this through the concept of propagation. Given
 * a root object, and a metadata field, one may retrieve all of the
 * values for that field in all objects contained in it. The interface
 * handles all of the recursion and cycles for you::
 *
 *     const root = {
 *       childA: {
 *         childB: { }
 *       }
 *     };
 *     root.childA[Symbol.for('@@meta:magical')] = {
 *       stability: 'experimental'
 *     };
 *     root.childA.childB[Symbol.for('@@meta:magical')] = {
 *       stability: 'stable'
 *     };
 *
 *     Interface.for(root).getPropagatedMeta('stability');
 *     // ==> ['experimental', 'stable']
 *
 *
 * ### Simplifying querying with fields
 *
 * Because different pieces of metadata have different behaviours
 * with inheritance and propagation, and because propagated metadata
 * needs to be merged for it to make sense (an array of stability
 * indexes is often meaningless, for example), Meta:Magical has a
 * concept of fields.
 *
 * `Field`s are an object that describe how a particular metadata
 * is handled, providing a name, inheritance and propagation
 * behaviours, and a way to merge metadata. All of this is used
 * by the `.get()` method to provide a value for the metadata.
 *
 * Taking the example in the previous section, a field could
 * provide an overall stability for the whole module::
 *
 *     const root = {
 *       childA: {
 *         childB: { }
 *       }
 *     };
 *     root.childA[Symbol.for('@@meta:magical')] = {
 *       stability: 'experimental'
 *     };
 *     root.childA.childB[Symbol.for('@@meta:magical')] = {
 *       stability: 'stable'
 *     };
 *
 *     const stability = Interface.fields.stability;
 *     Interface.for(root).get(stability).getOrElse(null);
 *     // ==> 'experimental'
 *
 *     Interface.for(root.childA.childB).get(stability).getOrElse(null);
 *     // ==> 'stable'
 *
 * For more information on fields, see the `.fields` property
 * exposed by the interface.
 *
 *
 * ## Updating meta-data
 *
 * The interface object also handles updating meta-data. The newly
 * associated meta-data is stored in a `WeakMap`, rather than on the
 * object itself, to avoid problems with modifying unowned, and frozen
 * objects.
 *
 * In order to associate new metadata one needs to construct an
 * `Interface` pointing to the object one wants to associate metadata
 * with, and then use the `.set(name, value)` to update the metadata::
 *
 *     const x = {};
 *     const xMeta = Interface.for(x);
 *     xMeta.set('name', 'x');
 *     xMeta.getByName('name').getOrElse(null); // ==> 'x'
 *
 * Multiple metadata may be provided as an object through the
 * `.update(meta)` method. All own enumerable key/value pairs provided
 * will replace the existing metadata on the object::
 *
 *     xMeta.update({ name: 'X' });
 *     xMeta.getByName('name').getOrElse(null); // ==> 'X'
 *
 *
 * ## Known issues with Meta:Magical
 *
 * Meta:Magical's use of global symbols for associating meta-data with
 * the objects doesn't have any issues, although in the unlikely event
 * that someone uses a global symbol with the `"@@meta:magical"` key
 * that would conflict with this library's use of the symbol. As long as
 * you only use the Symbol approach, there are no problems to worry
 * about.
 *
 * The use of a `WeakMap` to keep track of additional metadata for
 * unowned objects, on the other hand, is somewhat of a problem due to
 * JavaScript's semantics:
 *
 *   - The `metamagical-interface` library should be loaded only once.
 *     Because the library relies on a single `WeakMap` to keep track
 *     of additional metadata, having different libraries (and
 *     consequently different state) would lead to inconsistencies and
 *     unpredictable behaviour.
 *
 *   - All code realms should share the same instance of the
 *     `metamagical-interface`. Because a JavaScript VM may have
 *     different Code Realms (essentially, global execution contexts),
 *     it's important that all of them share the same Interface
 *     instance, otherwise metadata attached in one realm would not be
 *     visible in another.
 *
 *   - The `metamagical-interface` module uses reference equality, so it
 *     will treat objects from different realms as different objects, as
 *     it will treat duplicated isntances of a particular module (as
 *     could happen in npm) as different objects. There is no way of
 *     avoiding this problem.
 *
 * To ensure that one only has a single instance of the
 * `metamagical-interface` module in their application, all modules that
 * depend on this interface should be parameterised and expect an
 * outsider to provide the proper object, rather than require it
 * directly. In essence, modules that depend on the
 * `metamagical-interface` should be written as:
 *
 *     module.exports = function(metamagical) {
 *       return {
 *         foo() { return metamagical.getByName('name') }
 *       };
 *     }
 *
 * Rather than:
 *
 *     const metamagical = require('metamagical-interface');
 *     module.exports = {
 *       foo() { return metamagical.getByName('name') }
 *     }
 *
 * ---
 * stability : experimental
 * module    : metamagical-interface
 * category  : Metadata
 * platforms:
 *   - ECMAScript 2015
 */

__metamagical_withMeta(categoriseProperties, {
  'name': 'categoriseProperties',
  'source': 'function categoriseProperties(meta, entries) {\n  const byName     = (a, b) => compare(a.name, b.name);\n  const byCategory = (a, b) => compareCategories(a.category, b.category);\n\n  const asCategoryObject = ([category, members]) => ({ category, members });\n\n  const category = ({ value }) =>\n    isObject(value) ?  meta.for(value)\n                           .get(meta.fields.category)\n                           .getOrElse(\'(Uncategorised)\')\n    : /* else */       \'(Uncategorised)\';\n\n  return groupBy(entries.sort(byName), category)\n           .map(asCategoryObject)\n           .sort(byCategory);\n}',
  'signature': 'categoriseProperties(meta, entries)',
  'location': {
    'filename': 'src/index.js',
    'start': {
      'line': 208,
      'column': 0
    },
    'end': {
      'line': 223,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'documentation': '\nReturns a list of categories for the given properties.\n '
});

var Interface = __metamagical_withMeta(Refinable.refine((_Refinable$refine = {
  fields: fields,
  Stability: Stability,

  get object() {
    return this;
  },

  for: function _for(value) {
    if (isObject(value)) {
      return this.refine({ object: value });
    } else {
      return this.refine({ object: Primitive.from(value) });
    }
  },
  getOwnMeta: function getOwnMeta(name) {
    var meta = getMeta(this.object);

    return name in meta ? Maybe.Just(meta[name]) : /* otherwise */Maybe.Nothing();
  },
  getInheritedMeta: function getInheritedMeta(name) {
    var _this = this;

    return this.getOwnMeta('belongsTo').chain(function (parentFn) {
      var parent = parentFn();
      return _this.for(parent).getOwnMeta(name).orElse(function (_) {
        return _this.for(parent).getInheritedMeta(name);
      });
    });
  },
  getPropagatedMeta: function getPropagatedMeta(name) {
    var _this2 = this;

    var visited = new Set();

    var collectFrom = function collectFrom(meta) {
      var object = meta.object;

      if (visited.has(object)) {
        return [];
      }

      visited.add(object);

      return flatten(entriesOf(object).map(function (child) {
        if (!isObject(child.value) || visited.has(child.value)) {
          return [];
        } else {
          var childMeta = _this2.for(child.value);
          return childMeta.getOwnMeta(name).map(function (x) {
            return [x];
          }).getOrElse([]).concat(collectFrom(childMeta));
        }
      }));
    };

    return collectFrom(this);
  },
  get: function get(field) {
    var _this3 = this;

    return this.getOwnMeta(field.name).orElse(function (_) {
      return field.allowInheritance ? _this3.getInheritedMeta(field.name) : /* otherwise */Maybe.Nothing();
    }).orElse(function (_) {
      return field.allowPropagation ? field.merge(_this3.getPropagatedMeta(field.name)) : /* otherwise */Maybe.Nothing();
    });
  },
  getByName: function getByName(name) {
    return this.get(this.fields.Field.refine({ name: name }));
  },
  set: function set(field, value) {
    var object = this.object;
    var meta = metadata.get(object) || {};

    meta[field] = value;
    metadata.set(object, meta);

    return this;
  },
  update: function update(meta) {
    var _this4 = this;

    keys(meta).forEach(function (key) {
      return _this4.set(key, meta[key]);
    });
  },
  property: function property(name) {
    return name in this.object ? Maybe.Just(this.for(this.object[name])) : /* otherwise */Maybe.Nothing();
  },
  getter: function getter(name) {
    var _this5 = this;

    return getGetterSetter(this.object, name, 'get').map(function (x) {
      return _this5.for(x);
    });
  },
  setter: function setter(name) {
    var _this6 = this;

    return getGetterSetter(this.object, name, 'set').map(function (x) {
      return _this6.for(x);
    });
  },
  prototype: function prototype() {
    var parent = prototypeOf(this.object);
    return parent != null ? Maybe.Just(this.for(parent)) : /* otherwise */Maybe.Nothing();
  },
  properties: function properties() {
    return categoriseProperties(this, entriesOf(this.object));
  },
  allProperties: function allProperties() {
    return categoriseProperties(this, allEntriesOf(this.object));
  },
  parents: function parents() {
    return this.prototype().cata({
      Nothing: function Nothing(_) {
        return [];
      },
      Just: function Just(a) {
        return [[a.getByName('name').getOrElse(null), a.object]].concat(a.parents());
      }
    });
  },
  hierarchy: function hierarchy() {
    return this.parents().filter(function (_ref4) {
      var _ref5 = _slicedToArray(_ref4, 2);

      var name = _ref5[0];
      var _ = _ref5[1];
      return name != null;
    });
  }
}, __metamagical_withMeta(Object.getOwnPropertyDescriptor(_Refinable$refine, 'object').get, {
  'name': 'object',
  'source': 'get object() {\n    return this;\n  }',
  'signature': 'get object()',
  'belongsTo': function belongsTo() {
    return Interface;
  },
  'category': 'State and configuration',
  'stability': 'stable',
  'seeAlso': [{
    'type': 'entity',
    'path': '.for',
    'reason': 'A convenience method for changing the context.'
  }],
  'type': 'Interface. => Object \'a\n \n',
  'documentation': '\nThe current context of the Meta:Magical interface.\n\nA Meta:Magical interface has a current context, that is the\nobject to retrieve metadata from, or associate new metadata\nwith. This method provides such context.\n\nBy default the interface starts looking at itself. But this\ncan be changed by inheriting from the interface:\n\n    const x = {\n      [Symbol.for(\'@@meta:magical\')]: {\n        name: \'x\'\n      }\n    };\n    const meta = Interface.refine({\n      object: x\n    });\n\n    meta.getByName(\'name\').getOrElse(null); // ==> \'x\'\n\nA much more convenient way of changing the context is by using\nthe `.for(object)` method, however:\n\n    Interface.for(x).getByName(\'name\').getOrElse(null);\n    // ==> \'x\'\n',
  'examples': [{
    'name': '',
    'call': __metamagical_withMeta(function () {
      var x = _defineProperty({}, Symbol.for('@@meta:magical'), { name: 'x' });var meta = Interface.refine({ object: x });__metamagical_assert_equals(require('assert'), meta.getByName('name').getOrElse(null), 'x', 'meta.getByName(\'name\').getOrElse(null) ==> \'x\'');; // ==> 'x'
      ;__metamagical_assert_equals(require('assert'), Interface.for(x).getByName('name').getOrElse(null), 'x', 'Interface.for(x).getByName(\'name\').getOrElse(null) ==> \'x\'');; // ==> 'x'
    }, {
      'source': 'const x = {\n  [Symbol.for(\'@@meta:magical\')]: {\n    name: \'x\'\n  }\n};\nconst meta = Interface.refine({\n  object: x\n});\n\nmeta.getByName(\'name\').getOrElse(null); // ==> \'x\'\n;\nInterface.for(x).getByName(\'name\').getOrElse(null);\n// ==> \'x\''
    }),
    'inferred': true
  }]
}), __metamagical_withMeta(_Refinable$refine['for'], {
  'name': 'for',
  'source': 'for(value) {\n    if (isObject(value)) {\n      return this.refine({ object: value });\n    } else {\n      return this.refine({ object: Primitive.from(value) });\n    }\n  }',
  'signature': 'for(value)',
  'belongsTo': function belongsTo() {
    return Interface;
  },
  'category': 'State and configuration',
  'stability': 'stable',
  'seeAlso': [{
    'type': 'entity',
    'path': '.object',
    'reason': 'Retrieving the current context of the interface.'
  }],
  'type': '(proto is Interface).(Object \'a) => Interface <: proto\n \n',
  'documentation': '\nChanges the current context of the Meta:Magical object.\n\nThis method allows changing the current context of the object\nin a more convenient way than explicitly inheriting from the\nobject:\n\n    const x = {\n      [Symbol.for(\'@@meta:magical\')]: {\n        name: \'x\'\n      }\n    };\n    const xMeta = Interface.for(x);\n    xMeta.getByName(\'name\').getOrElse(null); // ==> \'x\'\n',
  'examples': [{
    'name': '',
    'call': __metamagical_withMeta(function () {
      var x = _defineProperty({}, Symbol.for('@@meta:magical'), { name: 'x' });var xMeta = Interface.for(x);__metamagical_assert_equals(require('assert'), xMeta.getByName('name').getOrElse(null), 'x', 'xMeta.getByName(\'name\').getOrElse(null) ==> \'x\'');; // ==> 'x'
    }, {
      'source': 'const x = {\n  [Symbol.for(\'@@meta:magical\')]: {\n    name: \'x\'\n  }\n};\nconst xMeta = Interface.for(x);\nxMeta.getByName(\'name\').getOrElse(null); // ==> \'x\''
    }),
    'inferred': true
  }]
}), __metamagical_withMeta(_Refinable$refine['getOwnMeta'], {
  'name': 'getOwnMeta',
  'source': 'getOwnMeta(name) {\n    const meta = getMeta(this.object);\n\n    return name in meta ?   Maybe.Just(meta[name])\n    :      /* otherwise */  Maybe.Nothing();\n  }',
  'signature': 'getOwnMeta(name)',
  'belongsTo': function belongsTo() {
    return Interface;
  },
  'category': 'Auxiliary methods for querying metadata',
  'stability': 'stable',
  'type': 'Interface.(String) => Maybe Any\n \n',
  'documentation': '\nRetrieves metadata defined directly on the current interface\'s context.\n\n\n    const x = {[Symbol.for(\'@@meta:magical\')]: {\n      name: \'x\'\n    }};\n\n    Interface.for(x).getOwnMeta(\'name\').getOrElse(\'Anonymous\');\n    // ==> \'x\'\n    Interface.for({}).getOwnMeta(\'name\').getOrElse(\'Anonymous\');\n    // ==> \'Anonymous\'\n'
}), __metamagical_withMeta(_Refinable$refine['getInheritedMeta'], {
  'name': 'getInheritedMeta',
  'source': 'getInheritedMeta(name) {\n    return this.getOwnMeta(\'belongsTo\').chain(parentFn => {\n      const parent = parentFn();\n      return this.for(parent).getOwnMeta(name).orElse(_ =>\n        this.for(parent).getInheritedMeta(name)\n      );\n    });\n  }',
  'signature': 'getInheritedMeta(name)',
  'belongsTo': function belongsTo() {
    return Interface;
  },
  'category': 'Auxiliary methods for querying metadata',
  'stability': 'experimental',
  'type': 'Interface.(String) => Maybe Any\n \n',
  'documentation': '\nRetrieves metadata defined in the closest parent for the interface\'s\ncontext.\n\nIn JavaScript objects may contain other objects, but we can\'t know\nwhat object contains another object (given that many objects might).\nIn order to support inherited meta-data for classes and objects,\nMeta:Magical allows one to annotate this missing link with the\n`belongsTo` field:\n\n    const root = {\n      child: { }\n    };\n    root[Symbol.for(\'@@meta:magical\')] = {\n      category: \'Objects\'\n    };\n    root.child[Symbol.for(\'@@meta:magical\')] = {\n      belongsTo() { return root; }\n    };\n\nOne may then ask for the meta-data in this containership-chain:\n\n    Interface.for(root.child)\n             .getInheritedMeta(\'category\')\n             .getOrElse(\'Uncategorised\');\n    // ==> \'Objects\'\n\n    Interface.for(root)\n             .getInheritedMeta(\'category\')\n             .getOrElse(\'Uncategorised\');\n    // ==> \'Uncategorised\'\n',
  'examples': [{
    'name': '',
    'call': __metamagical_withMeta(function () {
      var root = { child: {} };root[Symbol.for('@@meta:magical')] = { category: 'Objects' };root.child[Symbol.for('@@meta:magical')] = {
        belongsTo: function belongsTo() {
          return root;
        }
      };;__metamagical_assert_equals(require('assert'), Interface.for(root.child).getInheritedMeta('category').getOrElse('Uncategorised'), 'Objects', 'Interface.for(root.child).getInheritedMeta(\'category\').getOrElse(\'Uncategorised\') ==> \'Objects\'');; // ==> 'Objects'
      __metamagical_assert_equals(require('assert'), Interface.for(root).getInheritedMeta('category').getOrElse('Uncategorised'), 'Uncategorised', 'Interface.for(root).getInheritedMeta(\'category\').getOrElse(\'Uncategorised\') ==> \'Uncategorised\'');; // ==> 'Uncategorised'
    }, {
      'source': 'const root = {\n  child: { }\n};\nroot[Symbol.for(\'@@meta:magical\')] = {\n  category: \'Objects\'\n};\nroot.child[Symbol.for(\'@@meta:magical\')] = {\n  belongsTo() { return root; }\n};\n;\nInterface.for(root.child)\n         .getInheritedMeta(\'category\')\n         .getOrElse(\'Uncategorised\');\n// ==> \'Objects\'\n\nInterface.for(root)\n         .getInheritedMeta(\'category\')\n         .getOrElse(\'Uncategorised\');\n// ==> \'Uncategorised\''
    }),
    'inferred': true
  }]
}), __metamagical_withMeta(_Refinable$refine['getPropagatedMeta'], {
  'name': 'getPropagatedMeta',
  'source': 'getPropagatedMeta(name) {\n    let visited = new Set();\n\n    const collectFrom = (meta) => {\n      const object = meta.object;\n\n      if (visited.has(object)) {\n        return [];\n      }\n\n      visited.add(object);\n\n      return flatten(entriesOf(object).map(child => {\n        if (!isObject(child.value) || visited.has(child.value)) {\n          return [];\n        } else {\n          const childMeta = this.for(child.value);\n          return childMeta.getOwnMeta(name)\n                          .map(x => [x])\n                          .getOrElse([])\n                          .concat(collectFrom(childMeta));\n        }\n      }));\n    };\n\n    return collectFrom(this);\n  }',
  'signature': 'getPropagatedMeta(name)',
  'belongsTo': function belongsTo() {
    return Interface;
  },
  'category': 'Auxiliary methods for querying metadata',
  'complexity': 'O(n), `n` is the number of obects inside the current context',
  'stability': 'experimental',
  'type': 'Interface.(String) => Array Any\n \n',
  'documentation': '\nRetrieves metadata defined in the children of the interface\'s context.\n\nThis gives you an array of the values for the given metadata field defined\nin the children (direct or indirect) of the current interface\'s context:\n\n    const root = {\n      childA: { },\n      childB: { }\n    };\n    root.childA[Symbol.for(\'@@meta:magical\')] = {\n      stability: \'experimental\'\n    };\n    root.childB[Symbol.for(\'@@meta:magical\')] = {\n      stability: \'stable\'\n    };\n\n    Interface.for(root).getPropagatedMeta(\'stability\');\n    // ==> [\'experimental\', \'stable\']\n',
  'examples': [{
    'name': '',
    'call': __metamagical_withMeta(function () {
      var root = { childA: {}, childB: {} };root.childA[Symbol.for('@@meta:magical')] = { stability: 'experimental' };root.childB[Symbol.for('@@meta:magical')] = { stability: 'stable' };__metamagical_assert_equals(require('assert'), Interface.for(root).getPropagatedMeta('stability'), ['experimental', 'stable'], 'Interface.for(root).getPropagatedMeta(\'stability\') ==> [\'experimental\', \'stable\']');; // ==> ['experimental', 'stable']
    }, {
      'source': 'const root = {\n  childA: { },\n  childB: { }\n};\nroot.childA[Symbol.for(\'@@meta:magical\')] = {\n  stability: \'experimental\'\n};\nroot.childB[Symbol.for(\'@@meta:magical\')] = {\n  stability: \'stable\'\n};\n\nInterface.for(root).getPropagatedMeta(\'stability\');\n// ==> [\'experimental\', \'stable\']'
    }),
    'inferred': true
  }]
}), __metamagical_withMeta(_Refinable$refine['get'], {
  'name': 'get',
  'source': 'get(field) {\n    return this.getOwnMeta(field.name)\n               .orElse(_ =>\n                 field.allowInheritance ?  this.getInheritedMeta(field.name)\n                 : /* otherwise */         Maybe.Nothing()\n               ).orElse(_ =>\n                 field.allowPropagation ?  field.merge(this.getPropagatedMeta(field.name))\n                 : /* otherwise */         Maybe.Nothing()\n               );\n  }',
  'signature': 'get(field)',
  'belongsTo': function belongsTo() {
    return Interface;
  },
  'category': 'Querying metadata',
  'complexity': 'O(n), `n` is the number of objects inside the current context',
  'stability': 'experimental',
  'type': 'Interface.(Field) => Maybe Any\n \n',
  'documentation': '\nRetrieves metadata for the given field from the interface\'s current\ncontext.\n\nThis will try retrieving metadata stored directly in the current context,\nand fallback to metadata inherited from a parent object (through the\n`belongsTo` metadata), or metadata propagated from the values of the\nproperties in the object, if the provided field allows either.\n'
}), __metamagical_withMeta(_Refinable$refine['getByName'], {
  'name': 'getByName',
  'source': 'getByName(name) {\n    return this.get(this.fields.Field.refine({ name }));\n  }',
  'signature': 'getByName(name)',
  'belongsTo': function belongsTo() {
    return Interface;
  },
  'category': 'Querying metadata',
  'complexity': 'O(n), `n` is the number of objects inside the current context',
  'stability': 'experimental',
  'type': 'Interface.(String) => Maybe Any\n \n',
  'documentation': '\nRetrieves metadata with the given name from the interface\'s current context.\n'
}), __metamagical_withMeta(_Refinable$refine['set'], {
  'name': 'set',
  'source': 'set(field, value) {\n    const object = this.object;\n    let meta     = metadata.get(object) || {};\n\n    meta[field] = value;\n    metadata.set(object, meta);\n\n    return this;\n  }',
  'signature': 'set(field, value)',
  'belongsTo': function belongsTo() {
    return Interface;
  },
  'category': 'Querying and updating metadata',
  'stability': 'experimental',
  'seeAlso': [{
    'type': 'entity',
    'path': '.update',
    'reason': 'Convenience for updating multiple metadata fields'
  }],
  'type': '(a is Interface).(String, Any) => Interface :: mutates a\n \n',
  'documentation': '\nUpdates a single metadata field associated with the current interface\'s\ncontext.\n\n\n    const a     = Object.freeze({});\n    const aMeta = Interface.for(a);\n\n    aMeta.getByName(\'name\').getOrElse(\'Anonymous\');  // ==> \'Anonymous\'\n\n    aMeta.set(\'name\', \'a\');         // ==> aMeta\n    aMeta.getByName(\'name\').get();  // ==> \'a\'\n\nThis operation associates new metadata with the current interface\'s context.\nMetadata is attached by using the internal `WeakMap`, and as such can be\nused for frozen objects as well.\n\n> | **NOTE**\n> | Since this relies on a global `WeakMap`, it\'s subject to the\n> | limitations described in the `Interface`.\n'
}), __metamagical_withMeta(_Refinable$refine['update'], {
  'name': 'update',
  'source': 'update(meta) {\n    keys(meta).forEach(key => this.set(key, meta[key]));\n  }',
  'signature': 'update(meta)',
  'belongsTo': function belongsTo() {
    return Interface;
  },
  'category': 'Querying and updating metadata',
  'stability': 'experimental',
  'type': '(a is Interface).(String, Object Any) => Interface :: mutates a\n \n',
  'documentation': '\nUpdates many metadata fields associated with the current interface\'s\ncontext.\n\n\n    const a     = Object.freeze({});\n    const aMeta = Interface.for(a);\n\n    aMeta.getByName(\'type\').getOrElse(\'Unknown\'); // ==> \'Unknown\'\n\n    aMeta.update({ name: \'a\', type: \'Object\' }); // ==> aMeta\n    aMeta.getByName(\'name\').get();  // ==> \'a\'\n    aMeta.getByName(\'type\').get();  // ==> \'Object\'\n\nThis operation associates new metadata with the current interface\'s context.\nMetadata is attached by using the internal `WeakMap`, and as such can be\nused for frozen objects as well.\n\n> | **NOTE**\n> | Since this relies on a global `WeakMap`, it\'s subject to the\n> | limitations described in the `Interface`.\n'
}), __metamagical_withMeta(_Refinable$refine['property'], {
  'name': 'property',
  'source': 'property(name) {\n    return name in this.object ?  Maybe.Just(this.for(this.object[name]))\n    :      /* otherwise */        Maybe.Nothing();\n  }',
  'signature': 'property(name)',
  'belongsTo': function belongsTo() {
    return Interface;
  },
  'category': 'Navigating the context',
  'stability': 'experimental',
  'type': 'Interface.(String) => Maybe Interface\n \n',
  'documentation': '\nReturns an interface pointing to the given property of the current\ncontext.\n\n\n     Interface.property(\'get\').get().object;\n     // ==> Interface.get\n'
}), __metamagical_withMeta(_Refinable$refine['getter'], {
  'name': 'getter',
  'source': 'getter(name) {\n    return getGetterSetter(this.object, name, \'get\').map(x => this.for(x));\n  }',
  'signature': 'getter(name)',
  'belongsTo': function belongsTo() {
    return Interface;
  },
  'category': 'Navigating the context',
  'stability': 'experimental',
  'type': 'Interface.(String) => Maybe Interface\n \n',
  'documentation': '\nReturns an interface pointing to a getter with the given name in the\ncurrent context.\n\n\n    const x = { get value() { } };\n    const valueGetter = Object.getOwnPropertyDescriptor(x, \'value\').get;\n    Interface.for(x).getter(\'value\').get().object;\n    // ==> valueGetter\n'
}), __metamagical_withMeta(_Refinable$refine['setter'], {
  'name': 'setter',
  'source': 'setter(name) {\n    return getGetterSetter(this.object, name, \'set\').map(x => this.for(x));\n  }',
  'signature': 'setter(name)',
  'belongsTo': function belongsTo() {
    return Interface;
  },
  'category': 'Navigating the context',
  'stability': 'experimental',
  'type': 'Interface.(String) => Maybe Interface\n \n',
  'documentation': '\nReturns an interface pointing to a setter with the given name in the\ncurrent context.\n\n\n    const x = { set value(arg){ } };\n    const valueSetter = Object.getOwnPropertyDescriptor(x, \'value\').set;\n    Interface.for(x).setter(\'value\').get().object;\n    // ==> valueSetter\n'
}), __metamagical_withMeta(_Refinable$refine['prototype'], {
  'name': 'prototype',
  'source': 'prototype() {\n    const parent = prototypeOf(this.object);\n    return parent != null ?  Maybe.Just(this.for(parent))\n    :      /* otherwise */   Maybe.Nothing();\n  }',
  'signature': 'prototype()',
  'belongsTo': function belongsTo() {
    return Interface;
  },
  'category': 'Navigating the context',
  'stability': 'experimental',
  'type': 'Interface.() => Maybe Interface\n \n',
  'documentation': '\nReturns an interface pointing to the prototype of the current context\'s\n`[[Prototype]]`.\n\n\n    const x = {};\n    const y = Object.create(x);\n    Interface.for(y).prototype().get().object;\n    // ==> x\n'
}), __metamagical_withMeta(_Refinable$refine['properties'], {
  'name': 'properties',
  'source': 'properties() {\n    return categoriseProperties(this, entriesOf(this.object));\n  }',
  'signature': 'properties()',
  'belongsTo': function belongsTo() {
    return Interface;
  },
  'category': 'Additional reflective methods',
  'stability': 'experimental',
  'type': 'type PropertyKind is \'value\' or \'getter\' or \'setter\'\ntype Property     is { name: String, value: Any, kind: PropertyKind }\n\nInterface.() => Array { category: String, members: Array Property }\n \n',
  'documentation': '\nRetrieves a categorised list of properties owned by the current\ncontext.\n'
}), __metamagical_withMeta(_Refinable$refine['allProperties'], {
  'name': 'allProperties',
  'source': 'allProperties() {\n    return categoriseProperties(this, allEntriesOf(this.object));\n  }',
  'signature': 'allProperties()',
  'belongsTo': function belongsTo() {
    return Interface;
  },
  'category': 'Additional reflective methods',
  'stability': 'experimental',
  'type': 'type PropertyKind is \'value\' or \'getter\' or \'setter\'\ntype Property     is { name: String, value: Any, kind: PropertyKind }\n\nInterface.() => Array { category: String, members: Array Property }\n \n',
  'documentation': '\nRetrieves a categorised list of properties in the current\ncontext.\n'
}), __metamagical_withMeta(_Refinable$refine['parents'], {
  'name': 'parents',
  'source': 'parents() {\n    return this.prototype().cata({\n      Nothing: _ => [],\n      Just:    a => [[a.getByName(\'name\').getOrElse(null), a.object]].concat(a.parents())\n    });\n  }',
  'signature': 'parents()',
  'belongsTo': function belongsTo() {
    return Interface;
  },
  'category': 'Additional reflective methods',
  'stability': 'experimental',
  'type': 'Interface.() => Array (String, Object)\n \n',
  'documentation': '\nReturns all of the parents of the current context.\n'
}), __metamagical_withMeta(_Refinable$refine['hierarchy'], {
  'name': 'hierarchy',
  'source': 'hierarchy() {\n    return this.parents().filter(([name, _]) => name != null);\n  }',
  'signature': 'hierarchy()',
  'belongsTo': function belongsTo() {
    return Interface;
  },
  'category': 'Additional reflective methods',
  'stability': 'experimental',
  'type': 'Interface.() => Array (String, Object)\n \n',
  'documentation': '\nReturns all named parents of the current context.\n'
}), _Refinable$refine)), {
  'name': 'Interface',
  'source': 'Refinable.refine({\n  // ---[ Related objects ]--------------------------------------------\n  fields: fields,\n  Stability: Stability,\n\n  // ---[ State & Configuration ]--------------------------------------\n\n  /*~\n   * The current context of the Meta:Magical interface.\n   *\n   * A Meta:Magical interface has a current context, that is the\n   * object to retrieve metadata from, or associate new metadata\n   * with. This method provides such context.\n   *\n   * By default the interface starts looking at itself. But this\n   * can be changed by inheriting from the interface::\n   *\n   *     const x = {\n   *       [Symbol.for(\'@@meta:magical\')]: {\n   *         name: \'x\'\n   *       }\n   *     };\n   *     const meta = Interface.refine({\n   *       object: x\n   *     });\n   *\n   *     meta.getByName(\'name\').getOrElse(null); // ==> \'x\'\n   *\n   * A much more convenient way of changing the context is by using\n   * the `.for(object)` method, however::\n   *\n   *     Interface.for(x).getByName(\'name\').getOrElse(null);\n   *     // ==> \'x\'\n   *\n   * ---\n   * category  : State and configuration\n   * stability : stable\n   *\n   * seeAlso:\n   *   - type: entity\n   *     path: .for\n   *     reason: A convenience method for changing the context.\n   *\n   * type: |\n   *   Interface. => Object \'a\n   */\n  get object() {\n    return this;\n  },\n\n\n  /*~\n   * Changes the current context of the Meta:Magical object.\n   *\n   * This method allows changing the current context of the object\n   * in a more convenient way than explicitly inheriting from the\n   * object::\n   *\n   *     const x = {\n   *       [Symbol.for(\'@@meta:magical\')]: {\n   *         name: \'x\'\n   *       }\n   *     };\n   *     const xMeta = Interface.for(x);\n   *     xMeta.getByName(\'name\').getOrElse(null); // ==> \'x\'\n   *\n   * ---\n   * category  : State and configuration\n   * stability : stable\n   *\n   * seeAlso:\n   *   - type: entity\n   *     path: .object\n   *     reason: Retrieving the current context of the interface.\n   *\n   * type: |\n   *   (proto is Interface).(Object \'a) => Interface <: proto\n   */\n  for(value) {\n    if (isObject(value)) {\n      return this.refine({ object: value });\n    } else {\n      return this.refine({ object: Primitive.from(value) });\n    }\n  },\n\n\n  // ---[ Auxiliary Methods for Querying Metadata ]--------------------\n\n  /*~\n   * Retrieves metadata defined directly on the current interface\'s context.\n   *\n   * ::\n   *     const x = {[Symbol.for(\'@@meta:magical\')]: {\n   *       name: \'x\'\n   *     }};\n   *\n   *     Interface.for(x).getOwnMeta(\'name\').getOrElse(\'Anonymous\');\n   *     // ==> \'x\'\n   *     Interface.for({}).getOwnMeta(\'name\').getOrElse(\'Anonymous\');\n   *     // ==> \'Anonymous\'\n   *\n   * ---\n   * category  : Auxiliary methods for querying metadata\n   * stability : stable\n   * type: |\n   *   Interface.(String) => Maybe Any\n   */\n  getOwnMeta(name) {\n    const meta = getMeta(this.object);\n\n    return name in meta ?   Maybe.Just(meta[name])\n    :      /* otherwise */  Maybe.Nothing();\n  },\n\n\n  /*~\n   * Retrieves metadata defined in the closest parent for the interface\'s\n   * context.\n   *\n   * In JavaScript objects may contain other objects, but we can\'t know\n   * what object contains another object (given that many objects might).\n   * In order to support inherited meta-data for classes and objects,\n   * Meta:Magical allows one to annotate this missing link with the\n   * `belongsTo` field::\n   *\n   *     const root = {\n   *       child: { }\n   *     };\n   *     root[Symbol.for(\'@@meta:magical\')] = {\n   *       category: \'Objects\'\n   *     };\n   *     root.child[Symbol.for(\'@@meta:magical\')] = {\n   *       belongsTo() { return root; }\n   *     };\n   *\n   * One may then ask for the meta-data in this containership-chain::\n   *\n   *     Interface.for(root.child)\n   *              .getInheritedMeta(\'category\')\n   *              .getOrElse(\'Uncategorised\');\n   *     // ==> \'Objects\'\n   *\n   *     Interface.for(root)\n   *              .getInheritedMeta(\'category\')\n   *              .getOrElse(\'Uncategorised\');\n   *     // ==> \'Uncategorised\'\n   *\n   * ---\n   * category  : Auxiliary methods for querying metadata\n   * stability : experimental\n   * type: |\n   *   Interface.(String) => Maybe Any\n   */\n  getInheritedMeta(name) {\n    return this.getOwnMeta(\'belongsTo\').chain(parentFn => {\n      const parent = parentFn();\n      return this.for(parent).getOwnMeta(name).orElse(_ =>\n        this.for(parent).getInheritedMeta(name)\n      );\n    });\n  },\n\n\n  /*~\n   * Retrieves metadata defined in the children of the interface\'s context.\n   *\n   * This gives you an array of the values for the given metadata field defined\n   * in the children (direct or indirect) of the current interface\'s context::\n   *\n   *     const root = {\n   *       childA: { },\n   *       childB: { }\n   *     };\n   *     root.childA[Symbol.for(\'@@meta:magical\')] = {\n   *       stability: \'experimental\'\n   *     };\n   *     root.childB[Symbol.for(\'@@meta:magical\')] = {\n   *       stability: \'stable\'\n   *     };\n   *\n   *     Interface.for(root).getPropagatedMeta(\'stability\');\n   *     // ==> [\'experimental\', \'stable\']\n   *\n   * ---\n   * category   : Auxiliary methods for querying metadata\n   * complexity : O(n), `n` is the number of obects inside the current context\n   * stability  : experimental\n   *\n   * type: |\n   *   Interface.(String) => Array Any\n   */\n  getPropagatedMeta(name) {\n    let visited = new Set();\n\n    const collectFrom = (meta) => {\n      const object = meta.object;\n\n      if (visited.has(object)) {\n        return [];\n      }\n\n      visited.add(object);\n\n      return flatten(entriesOf(object).map(child => {\n        if (!isObject(child.value) || visited.has(child.value)) {\n          return [];\n        } else {\n          const childMeta = this.for(child.value);\n          return childMeta.getOwnMeta(name)\n                          .map(x => [x])\n                          .getOrElse([])\n                          .concat(collectFrom(childMeta));\n        }\n      }));\n    };\n\n    return collectFrom(this);\n  },\n\n\n  // ---[ Querying Metadata ]------------------------------------------\n\n  /*~\n   * Retrieves metadata for the given field from the interface\'s current\n   * context.\n   *\n   * This will try retrieving metadata stored directly in the current context,\n   * and fallback to metadata inherited from a parent object (through the\n   * `belongsTo` metadata), or metadata propagated from the values of the\n   * properties in the object, if the provided field allows either.\n   *\n   * ---\n   * category   : Querying metadata\n   * complexity : O(n), `n` is the number of objects inside the current context\n   * stability  : experimental\n   *\n   * type: |\n   *   Interface.(Field) => Maybe Any\n   */\n  get(field) {\n    return this.getOwnMeta(field.name)\n               .orElse(_ =>\n                 field.allowInheritance ?  this.getInheritedMeta(field.name)\n                 : /* otherwise */         Maybe.Nothing()\n               ).orElse(_ =>\n                 field.allowPropagation ?  field.merge(this.getPropagatedMeta(field.name))\n                 : /* otherwise */         Maybe.Nothing()\n               );\n  },\n\n  /*~\n   * Retrieves metadata with the given name from the interface\'s current context.\n   *\n   * ---\n   * category   : Querying metadata\n   * complexity : O(n), `n` is the number of objects inside the current context\n   * stability  : experimental\n   *\n   * type: |\n   *   Interface.(String) => Maybe Any\n   */\n  getByName(name) {\n    return this.get(this.fields.Field.refine({ name }));\n  },\n\n\n  // ---[ Updating Metadata ]------------------------------------------\n\n  /*~\n   * Updates a single metadata field associated with the current interface\'s\n   * context.\n   *\n   * ::\n   *     const a     = Object.freeze({});\n   *     const aMeta = Interface.for(a);\n   *\n   *     aMeta.getByName(\'name\').getOrElse(\'Anonymous\');  // ==> \'Anonymous\'\n   *\n   *     aMeta.set(\'name\', \'a\');         // ==> aMeta\n   *     aMeta.getByName(\'name\').get();  // ==> \'a\'\n   *\n   * This operation associates new metadata with the current interface\'s context.\n   * Metadata is attached by using the internal `WeakMap`, and as such can be\n   * used for frozen objects as well.\n   *\n   * > | **NOTE**\n   * > | Since this relies on a global `WeakMap`, it\'s subject to the\n   * > | limitations described in the `Interface`.\n   *\n   * ---\n   * category  : Querying and updating metadata\n   * stability : experimental\n   *\n   * seeAlso:\n   *   - type: entity\n   *     path: .update\n   *     reason: Convenience for updating multiple metadata fields\n   *\n   * type: |\n   *   (a is Interface).(String, Any) => Interface :: mutates a\n   */\n  set(field, value) {\n    const object = this.object;\n    let meta     = metadata.get(object) || {};\n\n    meta[field] = value;\n    metadata.set(object, meta);\n\n    return this;\n  },\n\n\n  /*~\n   * Updates many metadata fields associated with the current interface\'s\n   * context.\n   *\n   * ::\n   *     const a     = Object.freeze({});\n   *     const aMeta = Interface.for(a);\n   *\n   *     aMeta.getByName(\'type\').getOrElse(\'Unknown\'); // ==> \'Unknown\'\n   *\n   *     aMeta.update({ name: \'a\', type: \'Object\' }); // ==> aMeta\n   *     aMeta.getByName(\'name\').get();  // ==> \'a\'\n   *     aMeta.getByName(\'type\').get();  // ==> \'Object\'\n   *\n   * This operation associates new metadata with the current interface\'s context.\n   * Metadata is attached by using the internal `WeakMap`, and as such can be\n   * used for frozen objects as well.\n   *\n   * > | **NOTE**\n   * > | Since this relies on a global `WeakMap`, it\'s subject to the\n   * > | limitations described in the `Interface`.\n   *\n   * ---\n   * category  : Querying and updating metadata\n   * stability : experimental\n   *\n   * type: |\n   *   (a is Interface).(String, Object Any) => Interface :: mutates a\n   */\n  update(meta) {\n    keys(meta).forEach(key => this.set(key, meta[key]));\n  },\n\n\n  // ---[ Navigating the context ]-------------------------------------\n\n  /*~\n   * Returns an interface pointing to the given property of the current\n   * context.\n   *\n   * ::\n   *      Interface.property(\'get\').get().object;\n   *      // ==> Interface.get\n   *\n   * ---\n   * category  : Navigating the context\n   * stability : experimental\n   * type: |\n   *   Interface.(String) => Maybe Interface\n   */\n  property(name) {\n    return name in this.object ?  Maybe.Just(this.for(this.object[name]))\n    :      /* otherwise */        Maybe.Nothing();\n  },\n\n\n  /*~\n   * Returns an interface pointing to a getter with the given name in the\n   * current context.\n   *\n   * ::\n   *     const x = { get value() { } };\n   *     const valueGetter = Object.getOwnPropertyDescriptor(x, \'value\').get;\n   *     Interface.for(x).getter(\'value\').get().object;\n   *     // ==> valueGetter\n   *\n   * ---\n   * category  : Navigating the context\n   * stability : experimental\n   * type: |\n   *   Interface.(String) => Maybe Interface\n   */\n  getter(name) {\n    return getGetterSetter(this.object, name, \'get\').map(x => this.for(x));\n  },\n\n\n  /*~\n   * Returns an interface pointing to a setter with the given name in the\n   * current context.\n   *\n   * ::\n   *     const x = { set value(arg){ } };\n   *     const valueSetter = Object.getOwnPropertyDescriptor(x, \'value\').set;\n   *     Interface.for(x).setter(\'value\').get().object;\n   *     // ==> valueSetter\n   *\n   * ---\n   * category  : Navigating the context\n   * stability : experimental\n   * type: |\n   *   Interface.(String) => Maybe Interface\n   */\n  setter(name) {\n    return getGetterSetter(this.object, name, \'set\').map(x => this.for(x));\n  },\n\n\n  /*~\n   * Returns an interface pointing to the prototype of the current context\'s\n   * `[[Prototype]]`.\n   *\n   * ::\n   *     const x = {};\n   *     const y = Object.create(x);\n   *     Interface.for(y).prototype().get().object;\n   *     // ==> x\n   *\n   * ---\n   * category  : Navigating the context\n   * stability : experimental\n   * type: |\n   *   Interface.() => Maybe Interface\n   */\n  prototype() {\n    const parent = prototypeOf(this.object);\n    return parent != null ?  Maybe.Just(this.for(parent))\n    :      /* otherwise */   Maybe.Nothing();\n  },\n\n\n  // ---[ Additional reflective methods ]------------------------------\n\n  /*~\n   * Retrieves a categorised list of properties owned by the current\n   * context.\n   *\n   * ---\n   * category  : Additional reflective methods\n   * stability : experimental\n   * type: |\n   *   type PropertyKind is \'value\' or \'getter\' or \'setter\'\n   *   type Property     is { name: String, value: Any, kind: PropertyKind }\n   *\n   *   Interface.() => Array { category: String, members: Array Property }\n   */\n  properties() {\n    return categoriseProperties(this, entriesOf(this.object));\n  },\n\n  /*~\n   * Retrieves a categorised list of properties in the current\n   * context.\n   *\n   * ---\n   * category  : Additional reflective methods\n   * stability : experimental\n   * type: |\n   *   type PropertyKind is \'value\' or \'getter\' or \'setter\'\n   *   type Property     is { name: String, value: Any, kind: PropertyKind }\n   *\n   *   Interface.() => Array { category: String, members: Array Property }\n   */\n  allProperties() {\n    return categoriseProperties(this, allEntriesOf(this.object));\n  },\n\n  /*~\n   * Returns all of the parents of the current context.\n   * \n   * ---\n   * category  : Additional reflective methods\n   * stability : experimental\n   * type: |\n   *   Interface.() => Array (String, Object)\n   */\n  parents() {\n    return this.prototype().cata({\n      Nothing: _ => [],\n      Just:    a => [[a.getByName(\'name\').getOrElse(null), a.object]].concat(a.parents())\n    });\n  },\n\n  /*~\n   * Returns all named parents of the current context.\n   * \n   * ---\n   * category  : Additional reflective methods\n   * stability : experimental\n   * type: |\n   *   Interface.() => Array (String, Object)\n   */\n  hierarchy() {\n    return this.parents().filter(([name, _]) => name != null);\n  }\n})',
  'location': {
    'filename': 'src/index.js',
    'start': {
      'line': 518,
      'column': 0
    },
    'end': {
      'line': 1016,
      'column': 3
    }
  },
  'module': 'metamagical-interface',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'stability': 'experimental',
  'category': 'Metadata',
  'platforms': ['ECMAScript 2015'],
  'documentation': '\nThe Meta:Magical interface allows one to query meta-data associated\nwith a particular object, or attach new meta-data to any object\nwithout modifying the object.\n\n\n## Why?\n\nLanguages like Python, Ruby, Clojure, Smalltalk, and others support\ninteractively exploring their world of objects. For example, in\nPython, one is able to look at the documentation of an object through\nthe `__doc__` property. In Smalltalk, the platform\'s browser tells\nyou what classes you have, which methods are available on them, their\nsource code, documentation, all in a searchable interactive\nenvironment.\n\nJavaScript has a very limited support for this kind of reflective\ncapabilities. One may, for example, ask which properties an object\nhas, what\'s the name of a function, or its source, but there isn\'t\nmuch beyond that which we could benefit from while exploring a\nparticular library in the REPL. There\'s nothing in JavaScript that\nreifies a concept of documentation, making it accessible at runtime.\n\nIn order to support a more exploration-driven interactive development\nof applications, and even more accurate documentation in more static\nforms (given that JavaScript is too dynamic to lend itself well to\nstatic analysis documentation tools usually rely on), Meta:Magical\nallows people to attach new, arbitrary meta-data to any object in the\nsystem, and query that meta-data later.\n\nThe Meta:Magical project is heavily influenced by work on Smalltalk\nreflective environments, and Clojure\'s take on meta annotations for\nruntime values, and this interface aims to be the basis of better\ntooling for discoverable interactive environments and documentation\ntools.\n\n\n## How Meta:Magical handles metadata?\n\nJavaScript has a prototype-based object-orientation model, which\nbasically means that each object defines its own layout (the methods,\nproperties, fields, etc. it has), rather than linking to a class that\ndefines such. Alongside the possibility of adding or modifying\nproperties in an object at any time, and the new `Symbol` feature,\nthis allows us to attach arbitrary meta-data to any object without\nrisking conflicts.\n\nThere are two ways in which Meta:Magical supports attaching meta-data\nto an object:\n\n  - By assigning an object to the global Meta:Magical symbol:\n\n        object[Symbol.for(\'@@meta:magical\')] = { ... };\n\n  - By using the Interface\'s `.set()` method, which assigns meta-data\n    to an object using an internal `WeakMap` to avoid problems\n    modifying non-owned objects, specially those that have been\n    frozen:\n\n        const frozen = Object.freeze({});\n        Interface.for(frozen).set(\'name\', \'frozen\');\n\nMeta-data associated with an object through the `WeakMap` has\nprecedence over meta-data attached directly on the object, as a\nproperty. This allows people to refine existing meta-data and provide\nnew ones for objects from the outside.\n\n\n## Querying meta-data\n\nThe Meta:Magical interface is an object that wraps another object,\nand lets you reflect over meta-properties associated with that\nobject, by both querying or updating them.\n\nThe `object` method defines which object this interface is looking\nat. By default, the interface starts looking at itself, but it can be\nrefined to look at another object, which can be done by inheriting\nfrom it explicitly or just using the `.for()` method:\n\n    Interface.getByName(\'name\').get();\n    // ==> \'Interface\'\n\n    const getInterface = Interface.for(Interface.getByName);\n    getInterface.getByName(\'name\').get();\n    // ==> \'getByName\'\n\n    const myInterface = getInterface.for(Interface);\n    myInterface.getByName(\'name\').get();\n    // ==> \'Interface\'\n\nAt any point you can use the `object` method to retrieve the\nobject the interface is looking at:\n\n    Interface.object\n    // ==> Interface\n\n\n### Containership and Inheritance\n\nObjects form hierarchies of data, but given a JavaScript object\none is only able to ask which objects are under that, it\'s not\npossible to query which objects contains a particular value.\nThis makes interactive exploration in a REPL harder, because\nwe can\'t figure out the context of a particular value (where\ndoes this belong to?).\n\nTo solve this, Meta:Magical introduces a special piece of metadata,\n`belongsTo`, which lazily provides the missing link:\n\n    const root = {\n      child: { }\n    };\n    root.child[Symbol.for(\'@@meta:magical\')] = {\n      belongsTo() { return root },\n      name: \'child\'\n    };\n\nThis allows one to retrieve which object canonically holds the\ndefinition of a particular value. So, if one has a function like\n`get`, they can retrieve the broader context in which this function\nlives:\n\n    const getMeta = Interface.for(Interface.get);\n    getMeta.getByName(\'belongsTo\').getOrElse(null)();\n    // ==> Interface\n\nInternally, Meta:Magical uses this information to propagate some\nmetadata from the broader context (parent object) to the current\ncontext. Things such as `licence`, `repository`, `copyright`, and\nothers allow this kind of inheritance:\n\n    root[Symbol.for(\'@@meta:magical\')] = {\n      licence: \'CC0\'\n    };\n\n    Interface.for(root.child).getInheritedMeta(\'licence\').getOrElse(null);\n    // ==> \'CC0\'\n\n\n### Propagation\n\nAnother aspect that\'s important when you have a hierarchy of objects\nis that objects are made out of several smaller pieces. And these\npieces impact the metadata about the top objects. For example, if\na module contains a single experimental function, then it might make\nsense to mark the module as experimental.\n\nMeta:Magical supports this through the concept of propagation. Given\na root object, and a metadata field, one may retrieve all of the\nvalues for that field in all objects contained in it. The interface\nhandles all of the recursion and cycles for you:\n\n    const root = {\n      childA: {\n        childB: { }\n      }\n    };\n    root.childA[Symbol.for(\'@@meta:magical\')] = {\n      stability: \'experimental\'\n    };\n    root.childA.childB[Symbol.for(\'@@meta:magical\')] = {\n      stability: \'stable\'\n    };\n\n    Interface.for(root).getPropagatedMeta(\'stability\');\n    // ==> [\'experimental\', \'stable\']\n\n\n### Simplifying querying with fields\n\nBecause different pieces of metadata have different behaviours\nwith inheritance and propagation, and because propagated metadata\nneeds to be merged for it to make sense (an array of stability\nindexes is often meaningless, for example), Meta:Magical has a\nconcept of fields.\n\n`Field`s are an object that describe how a particular metadata\nis handled, providing a name, inheritance and propagation\nbehaviours, and a way to merge metadata. All of this is used\nby the `.get()` method to provide a value for the metadata.\n\nTaking the example in the previous section, a field could\nprovide an overall stability for the whole module:\n\n    const root = {\n      childA: {\n        childB: { }\n      }\n    };\n    root.childA[Symbol.for(\'@@meta:magical\')] = {\n      stability: \'experimental\'\n    };\n    root.childA.childB[Symbol.for(\'@@meta:magical\')] = {\n      stability: \'stable\'\n    };\n\n    const stability = Interface.fields.stability;\n    Interface.for(root).get(stability).getOrElse(null);\n    // ==> \'experimental\'\n\n    Interface.for(root.childA.childB).get(stability).getOrElse(null);\n    // ==> \'stable\'\n\nFor more information on fields, see the `.fields` property\nexposed by the interface.\n\n\n## Updating meta-data\n\nThe interface object also handles updating meta-data. The newly\nassociated meta-data is stored in a `WeakMap`, rather than on the\nobject itself, to avoid problems with modifying unowned, and frozen\nobjects.\n\nIn order to associate new metadata one needs to construct an\n`Interface` pointing to the object one wants to associate metadata\nwith, and then use the `.set(name, value)` to update the metadata:\n\n    const x = {};\n    const xMeta = Interface.for(x);\n    xMeta.set(\'name\', \'x\');\n    xMeta.getByName(\'name\').getOrElse(null); // ==> \'x\'\n\nMultiple metadata may be provided as an object through the\n`.update(meta)` method. All own enumerable key/value pairs provided\nwill replace the existing metadata on the object:\n\n    xMeta.update({ name: \'X\' });\n    xMeta.getByName(\'name\').getOrElse(null); // ==> \'X\'\n\n\n## Known issues with Meta:Magical\n\nMeta:Magical\'s use of global symbols for associating meta-data with\nthe objects doesn\'t have any issues, although in the unlikely event\nthat someone uses a global symbol with the `"@@meta:magical"` key\nthat would conflict with this library\'s use of the symbol. As long as\nyou only use the Symbol approach, there are no problems to worry\nabout.\n\nThe use of a `WeakMap` to keep track of additional metadata for\nunowned objects, on the other hand, is somewhat of a problem due to\nJavaScript\'s semantics:\n\n  - The `metamagical-interface` library should be loaded only once.\n    Because the library relies on a single `WeakMap` to keep track\n    of additional metadata, having different libraries (and\n    consequently different state) would lead to inconsistencies and\n    unpredictable behaviour.\n\n  - All code realms should share the same instance of the\n    `metamagical-interface`. Because a JavaScript VM may have\n    different Code Realms (essentially, global execution contexts),\n    it\'s important that all of them share the same Interface\n    instance, otherwise metadata attached in one realm would not be\n    visible in another.\n\n  - The `metamagical-interface` module uses reference equality, so it\n    will treat objects from different realms as different objects, as\n    it will treat duplicated isntances of a particular module (as\n    could happen in npm) as different objects. There is no way of\n    avoiding this problem.\n\nTo ensure that one only has a single instance of the\n`metamagical-interface` module in their application, all modules that\ndepend on this interface should be parameterised and expect an\noutsider to provide the proper object, rather than require it\ndirectly. In essence, modules that depend on the\n`metamagical-interface` should be written as:\n\n    module.exports = function(metamagical) {\n      return {\n        foo() { return metamagical.getByName(\'name\') }\n      };\n    }\n\nRather than:\n\n    const metamagical = require(\'metamagical-interface\');\n    module.exports = {\n      foo() { return metamagical.getByName(\'name\') }\n    }\n',
  'examples': [{
    'name': '',
    'call': __metamagical_withMeta(function () {}, {
      'source': ''
    }),
    'inferred': true
  }, {
    'name': 'Why?',
    'call': __metamagical_withMeta(function () {}, {
      'source': ''
    }),
    'inferred': true
  }, {
    'name': 'How Meta:Magical handles metadata?',
    'call': __metamagical_withMeta(function () {}, {
      'source': ''
    }),
    'inferred': true
  }, {
    'name': 'Querying meta-data',
    'call': __metamagical_withMeta(function () {
      __metamagical_assert_equals(require('assert'), Interface.getByName('name').get(), 'Interface', 'Interface.getByName(\'name\').get() ==> \'Interface\'');; // ==> 'Interface'
      var getInterface = Interface.for(Interface.getByName);__metamagical_assert_equals(require('assert'), getInterface.getByName('name').get(), 'getByName', 'getInterface.getByName(\'name\').get() ==> \'getByName\'');; // ==> 'getByName'
      var myInterface = getInterface.for(Interface);__metamagical_assert_equals(require('assert'), myInterface.getByName('name').get(), 'Interface', 'myInterface.getByName(\'name\').get() ==> \'Interface\'');; // ==> 'Interface'
      __metamagical_assert_equals(require('assert'), Interface.object, Interface, 'Interface.object ==> Interface');; // ==> Interface
    }, {
      'source': 'Interface.getByName(\'name\').get();\n// ==> \'Interface\'\n\nconst getInterface = Interface.for(Interface.getByName);\ngetInterface.getByName(\'name\').get();\n// ==> \'getByName\'\n\nconst myInterface = getInterface.for(Interface);\nmyInterface.getByName(\'name\').get();\n// ==> \'Interface\'\n\nInterface.object\n// ==> Interface'
    }),
    'inferred': true
  }, {
    'name': 'Containership and Inheritance',
    'call': __metamagical_withMeta(function () {
      var root = { child: {} };root.child[Symbol.for('@@meta:magical')] = {
        belongsTo: function belongsTo() {
          return root;
        },
        name: 'child' };var getMeta = Interface.for(Interface.get);__metamagical_assert_equals(require('assert'), getMeta.getByName('belongsTo').getOrElse(null)(), Interface, 'getMeta.getByName(\'belongsTo\').getOrElse(null)() ==> Interface');;root[Symbol.for('@@meta:magical')] = { licence: 'CC0' };__metamagical_assert_equals(require('assert'), Interface.for(root.child).getInheritedMeta('licence').getOrElse(null), 'CC0', 'Interface.for(root.child).getInheritedMeta(\'licence\').getOrElse(null) ==> \'CC0\'');; // ==> 'CC0'
    }, {
      'source': 'const root = {\n  child: { }\n};\nroot.child[Symbol.for(\'@@meta:magical\')] = {\n  belongsTo() { return root },\n  name: \'child\'\n};\n\nconst getMeta = Interface.for(Interface.get);\ngetMeta.getByName(\'belongsTo\').getOrElse(null)();\n// ==> Interface\n\nroot[Symbol.for(\'@@meta:magical\')] = {\n  licence: \'CC0\'\n};\n\nInterface.for(root.child).getInheritedMeta(\'licence\').getOrElse(null);\n// ==> \'CC0\''
    }),
    'inferred': true
  }, {
    'name': 'Propagation',
    'call': __metamagical_withMeta(function () {
      var root = { childA: { childB: {} } };root.childA[Symbol.for('@@meta:magical')] = { stability: 'experimental' };root.childA.childB[Symbol.for('@@meta:magical')] = { stability: 'stable' };__metamagical_assert_equals(require('assert'), Interface.for(root).getPropagatedMeta('stability'), ['experimental', 'stable'], 'Interface.for(root).getPropagatedMeta(\'stability\') ==> [\'experimental\', \'stable\']');; // ==> ['experimental', 'stable']
    }, {
      'source': 'const root = {\n  childA: {\n    childB: { }\n  }\n};\nroot.childA[Symbol.for(\'@@meta:magical\')] = {\n  stability: \'experimental\'\n};\nroot.childA.childB[Symbol.for(\'@@meta:magical\')] = {\n  stability: \'stable\'\n};\n\nInterface.for(root).getPropagatedMeta(\'stability\');\n// ==> [\'experimental\', \'stable\']'
    }),
    'inferred': true
  }, {
    'name': 'Simplifying querying with fields',
    'call': __metamagical_withMeta(function () {
      var root = { childA: { childB: {} } };root.childA[Symbol.for('@@meta:magical')] = { stability: 'experimental' };root.childA.childB[Symbol.for('@@meta:magical')] = { stability: 'stable' };var stability = Interface.fields.stability;__metamagical_assert_equals(require('assert'), Interface.for(root).get(stability).getOrElse(null), 'experimental', 'Interface.for(root).get(stability).getOrElse(null) ==> \'experimental\'');; // ==> 'experimental'
      __metamagical_assert_equals(require('assert'), Interface.for(root.childA.childB).get(stability).getOrElse(null), 'stable', 'Interface.for(root.childA.childB).get(stability).getOrElse(null) ==> \'stable\'');; // ==> 'stable'
    }, {
      'source': 'const root = {\n  childA: {\n    childB: { }\n  }\n};\nroot.childA[Symbol.for(\'@@meta:magical\')] = {\n  stability: \'experimental\'\n};\nroot.childA.childB[Symbol.for(\'@@meta:magical\')] = {\n  stability: \'stable\'\n};\n\nconst stability = Interface.fields.stability;\nInterface.for(root).get(stability).getOrElse(null);\n// ==> \'experimental\'\n\nInterface.for(root.childA.childB).get(stability).getOrElse(null);\n// ==> \'stable\''
    }),
    'inferred': true
  }, {
    'name': 'Updating meta-data',
    'call': __metamagical_withMeta(function () {
      var x = {};var xMeta = Interface.for(x);xMeta.set('name', 'x');__metamagical_assert_equals(require('assert'), xMeta.getByName('name').getOrElse(null), 'x', 'xMeta.getByName(\'name\').getOrElse(null) ==> \'x\'');; // ==> 'x'
      xMeta.update({ name: 'X' });__metamagical_assert_equals(require('assert'), xMeta.getByName('name').getOrElse(null), 'X', 'xMeta.getByName(\'name\').getOrElse(null) ==> \'X\'');; // ==> 'X'
    }, {
      'source': 'const x = {};\nconst xMeta = Interface.for(x);\nxMeta.set(\'name\', \'x\');\nxMeta.getByName(\'name\').getOrElse(null); // ==> \'x\'\n\nxMeta.update({ name: \'X\' });\nxMeta.getByName(\'name\').getOrElse(null); // ==> \'X\''
    }),
    'inferred': true
  }]
});

// --[ Exports ]-------------------------------------------------------
module.exports = Interface;

// --[ Attaches built-in annotations ]---------------------------------
require('./annotations')(Interface);
},{"./annotations":384,"./assertions":385,"./fields":386,"./primitives":388,"./stability":389,"assert":54,"data.maybe":350,"refinable":393}],388:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var __metamagical_withMeta = function metamagical_withMeta(object, meta) {
  var parent = Object.getPrototypeOf(object);var oldMeta = object[Symbol.for('@@meta:magical')] || {};if (parent && parent[Symbol.for('@@meta:magical')] === oldMeta) {
    oldMeta = {};
  }Object.keys(meta).forEach(function (key) {
    if (/^~/.test(key)) {
      oldMeta[key.slice(1)] = meta[key];
    } else {
      oldMeta[key] = meta[key];
    }
  });object[Symbol.for('@@meta:magical')] = oldMeta;return object;
};

//---------------------------------------------------------------------
//
// This source file is part of the Meta:Magical project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//---------------------------------------------------------------------

// --[ Helpers ]-------------------------------------------------------
var VALUE = Symbol('Primitive.value');
var isPrototypeOf = Function.call.bind(Object.prototype.isPrototypeOf);

function notPrimitive(value) {
  throw new TypeError('Not a primitive: ' + value);
}

// --[ Primitives ]----------------------------------------------------

/*~
 * A Primitive provides an annotated representation for JS primitives,
 * which themselves can't be used as an object.
 *
 * This it much simpler to handle a lot of the complexities that come
 * with handling this difference at every call site.
 *
 * ---
 * category  : Wrapper objects
 * stability : experimental
 * isModule  : true
 */
var Primitive = __metamagical_withMeta(Object.create(null), {
  'name': 'Primitive',
  'source': 'Object.create(null)',
  'location': {
    'filename': 'src/primitives.js',
    'start': {
      'line': 32,
      'column': 0
    },
    'end': {
      'line': 32,
      'column': 36
    }
  },
  'module': 'metamagical-interface/src/primitives',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'category': 'Wrapper objects',
  'stability': 'experimental',
  'isModule': true,
  'documentation': '\nA Primitive provides an annotated representation for JS primitives,\nwhich themselves can\'t be used as an object.\n\nThis it much simpler to handle a lot of the complexities that come\nwith handling this difference at every call site.\n'
});

// ---[ Types of primitive values ]------------------------------------

/*~
 * Wraps Undefined in a Primitive object.
 *
 * ---
 * category  : Types of primitive values
 * stability : experimental
 * type: |
 *   (Undefined) => Primitive
 */
Primitive.Undefined = __metamagical_withMeta(function (value) {
  if (value !== undefined) {
    throw new TypeError('Expected undefined');
  }

  /*~
   * An Undefined value.
   *
   * This object provides an annotated representation for the underlying
   * Undefined JS primitive.
   *
   * ---
   * category  : JavaScript primitives
   * stability : experimental
   * type: "Undefined"
   */
  var Undefined = __metamagical_withMeta(Primitive.of(value), {
    'name': 'Undefined',
    'source': 'Primitive.of(value)',
    'location': {
      'filename': 'src/primitives.js',
      'start': {
        'line': 61,
        'column': 2
      },
      'end': {
        'line': 61,
        'column': 40
      }
    },
    'module': 'metamagical-interface/src/primitives',
    'homepage': 'https://github.com/origamitower/metamagical#readme',
    'licence': 'MIT',
    'authors': ['Quildreen Motta <queen@robotlolita.me>'],
    'repository': 'git://github.com/origamitower/metamagical.git',
    'npmPackage': 'metamagical-interface',
    'copyright': '(c) 2016 Quildreen Motta',
    'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
    'category': 'JavaScript primitives',
    'stability': 'experimental',
    'type': 'Undefined',
    'documentation': '\nAn Undefined value.\n\nThis object provides an annotated representation for the underlying\nUndefined JS primitive.\n'
  });

  return Undefined;
}, {
  'name': 'Undefined',
  'source': 'function(value) {\n  if (value !== undefined) {\n    throw new TypeError(\'Expected undefined\');\n  }\n\n  /*~\n   * An Undefined value.\n   *\n   * This object provides an annotated representation for the underlying\n   * Undefined JS primitive.\n   *\n   * ---\n   * category  : JavaScript primitives\n   * stability : experimental\n   * type: "Undefined"\n   */\n  const Undefined = Primitive.of(value);\n\n  return Undefined;\n}',
  'signature': 'Undefined(value)',
  'belongsTo': function belongsTo() {
    return Primitive;
  },
  'category': 'Types of primitive values',
  'stability': 'experimental',
  'type': '(Undefined) => Primitive\n',
  'documentation': '\nWraps Undefined in a Primitive object.\n'
});

/*~
 * Wraps Null in a Primitive object.
 *
 * ---
 * category  : Types of primitive values
 * stability : experimental
 * type: |
 *   (Null) => Primitive
 */
Primitive.Null = __metamagical_withMeta(function (value) {
  if (value !== null) {
    throw new TypeError('Expected null');
  }

  /*~
   * A null value.
   *
   * This object provides an annotated representation for the underlying
   * null JS primitive.
   *
   * ---
   * category  : JavaScript primitives
   * stability : experimental
   * type: "Null"
   */
  var Null = __metamagical_withMeta(Primitive.of(value), {
    'name': 'Null',
    'source': 'Primitive.of(value)',
    'location': {
      'filename': 'src/primitives.js',
      'start': {
        'line': 91,
        'column': 2
      },
      'end': {
        'line': 91,
        'column': 35
      }
    },
    'module': 'metamagical-interface/src/primitives',
    'homepage': 'https://github.com/origamitower/metamagical#readme',
    'licence': 'MIT',
    'authors': ['Quildreen Motta <queen@robotlolita.me>'],
    'repository': 'git://github.com/origamitower/metamagical.git',
    'npmPackage': 'metamagical-interface',
    'copyright': '(c) 2016 Quildreen Motta',
    'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
    'category': 'JavaScript primitives',
    'stability': 'experimental',
    'type': 'Null',
    'documentation': '\nA null value.\n\nThis object provides an annotated representation for the underlying\nnull JS primitive.\n'
  });

  return Null;
}, {
  'name': 'Null',
  'source': 'function(value) {\n  if (value !== null) {\n    throw new TypeError(\'Expected null\');\n  }\n\n  /*~\n   * A null value.\n   *\n   * This object provides an annotated representation for the underlying\n   * null JS primitive.\n   *\n   * ---\n   * category  : JavaScript primitives\n   * stability : experimental\n   * type: "Null"\n   */\n  const Null = Primitive.of(value);\n\n  return Null;\n}',
  'signature': 'Null(value)',
  'belongsTo': function belongsTo() {
    return Primitive;
  },
  'category': 'Types of primitive values',
  'stability': 'experimental',
  'type': '(Null) => Primitive\n',
  'documentation': '\nWraps Null in a Primitive object.\n'
});

/*~
 * Wraps Boolean in a Primitive object.
 *
 * ---
 * category  : Types of primitive values
 * stability : experimental
 * type: |
 *   (Boolean) => Primitive
 */
Primitive.Boolean = __metamagical_withMeta(function (value) {
  if (typeof value !== "boolean") {
    throw new TypeError('Expected Boolean');
  }

  /*~
   * A Boolean.
   *
   * This object provides an annotated representation for the underlying
   * boolean JS primitive.
   *
   * ---
   * category  : JavaScript primitives
   * stability : experimental
   * type: "Boolean"
   */
  var Boolean = __metamagical_withMeta(Primitive.of(value), {
    'name': 'Boolean',
    'source': 'Primitive.of(value)',
    'location': {
      'filename': 'src/primitives.js',
      'start': {
        'line': 121,
        'column': 2
      },
      'end': {
        'line': 121,
        'column': 38
      }
    },
    'module': 'metamagical-interface/src/primitives',
    'homepage': 'https://github.com/origamitower/metamagical#readme',
    'licence': 'MIT',
    'authors': ['Quildreen Motta <queen@robotlolita.me>'],
    'repository': 'git://github.com/origamitower/metamagical.git',
    'npmPackage': 'metamagical-interface',
    'copyright': '(c) 2016 Quildreen Motta',
    'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
    'category': 'JavaScript primitives',
    'stability': 'experimental',
    'type': 'Boolean',
    'documentation': '\nA Boolean.\n\nThis object provides an annotated representation for the underlying\nboolean JS primitive.\n'
  });

  return Boolean;
}, {
  'name': 'Boolean',
  'source': 'function(value) {\n  if (typeof value !== "boolean") {\n    throw new TypeError(\'Expected Boolean\');\n  }\n\n  /*~\n   * A Boolean.\n   *\n   * This object provides an annotated representation for the underlying\n   * boolean JS primitive.\n   *\n   * ---\n   * category  : JavaScript primitives\n   * stability : experimental\n   * type: "Boolean"\n   */\n  const Boolean = Primitive.of(value);\n\n  return Boolean;\n}',
  'signature': 'Boolean(value)',
  'belongsTo': function belongsTo() {
    return Primitive;
  },
  'category': 'Types of primitive values',
  'stability': 'experimental',
  'type': '(Boolean) => Primitive\n',
  'documentation': '\nWraps Boolean in a Primitive object.\n'
});

/*~
 * Wraps Number in a Primitive object.
 *
 * ---
 * category  : Types of primitive values
 * stability : experimental
 * type: |
 *   (Number) => Primitive
 */
Primitive.Number = __metamagical_withMeta(function (value) {
  if (typeof value !== "number") {
    throw new TypeError('Expected Number');
  }

  /*~
   * A Number.
   *
   * This object provides an annotated representation for the underlying
   * number JS primitive.
   *
   * ---
   * category  : JavaScript primitives
   * stability : experimental
   * type: "Number"
   */
  var Number = __metamagical_withMeta(Primitive.of(value), {
    'name': 'Number',
    'source': 'Primitive.of(value)',
    'location': {
      'filename': 'src/primitives.js',
      'start': {
        'line': 151,
        'column': 2
      },
      'end': {
        'line': 151,
        'column': 37
      }
    },
    'module': 'metamagical-interface/src/primitives',
    'homepage': 'https://github.com/origamitower/metamagical#readme',
    'licence': 'MIT',
    'authors': ['Quildreen Motta <queen@robotlolita.me>'],
    'repository': 'git://github.com/origamitower/metamagical.git',
    'npmPackage': 'metamagical-interface',
    'copyright': '(c) 2016 Quildreen Motta',
    'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
    'category': 'JavaScript primitives',
    'stability': 'experimental',
    'type': 'Number',
    'documentation': '\nA Number.\n\nThis object provides an annotated representation for the underlying\nnumber JS primitive.\n'
  });

  return Number;
}, {
  'name': 'Number',
  'source': 'function(value) {\n  if (typeof value !== "number") {\n    throw new TypeError(\'Expected Number\');\n  }\n\n  /*~\n   * A Number.\n   *\n   * This object provides an annotated representation for the underlying\n   * number JS primitive.\n   *\n   * ---\n   * category  : JavaScript primitives\n   * stability : experimental\n   * type: "Number"\n   */\n  const Number = Primitive.of(value);\n\n  return Number;\n}',
  'signature': 'Number(value)',
  'belongsTo': function belongsTo() {
    return Primitive;
  },
  'category': 'Types of primitive values',
  'stability': 'experimental',
  'type': '(Number) => Primitive\n',
  'documentation': '\nWraps Number in a Primitive object.\n'
});

/*~
 * Wraps String in a Primitive object.
 *
 * ---
 * category  : Types of primitive values
 * stability : experimental
 * type: |
 *   (String) => Primitive
 */
Primitive.String = __metamagical_withMeta(function (value) {
  if (typeof value !== "string") {
    throw new TypeError('Expected String');
  }

  /*~
   * A String.
   *
   * This object provides an annotated representation for the underlying
   * string JS primitive.
   *
   * ---
   * category  : JavaScript primitives
   * stability : experimental
   * type: "String"
   */
  var String = __metamagical_withMeta(Primitive.of(value), {
    'name': 'String',
    'source': 'Primitive.of(value)',
    'location': {
      'filename': 'src/primitives.js',
      'start': {
        'line': 181,
        'column': 2
      },
      'end': {
        'line': 181,
        'column': 37
      }
    },
    'module': 'metamagical-interface/src/primitives',
    'homepage': 'https://github.com/origamitower/metamagical#readme',
    'licence': 'MIT',
    'authors': ['Quildreen Motta <queen@robotlolita.me>'],
    'repository': 'git://github.com/origamitower/metamagical.git',
    'npmPackage': 'metamagical-interface',
    'copyright': '(c) 2016 Quildreen Motta',
    'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
    'category': 'JavaScript primitives',
    'stability': 'experimental',
    'type': 'String',
    'documentation': '\nA String.\n\nThis object provides an annotated representation for the underlying\nstring JS primitive.\n'
  });

  return String;
}, {
  'name': 'String',
  'source': 'function(value) {\n  if (typeof value !== "string") {\n    throw new TypeError(\'Expected String\');\n  }\n\n  /*~\n   * A String.\n   *\n   * This object provides an annotated representation for the underlying\n   * string JS primitive.\n   *\n   * ---\n   * category  : JavaScript primitives\n   * stability : experimental\n   * type: "String"\n   */\n  const String = Primitive.of(value);\n\n  return String;\n}',
  'signature': 'String(value)',
  'belongsTo': function belongsTo() {
    return Primitive;
  },
  'category': 'Types of primitive values',
  'stability': 'experimental',
  'type': '(String) => Primitive\n',
  'documentation': '\nWraps String in a Primitive object.\n'
});

/*~
 * Wraps Symbol in a Primitive object.
 *
 * ---
 * category  : Types of primitive values
 * stability : experimental
 * type: |
 *   (Symbol) => Primitive
 */
Primitive.Symbol = __metamagical_withMeta(function (value) {
  if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) !== "symbol") {
    throw new TypeError('Expected Symbol');
  }

  /*~
   * A Symbol.
   *
   * This object provides an annotated representation for the underlying
   * symbol JS primitive.
   *
   * ---
   * category  : JavaScript primitives
   * stability : experimental
   * type: "Symbol"
   */
  var _Symbol = __metamagical_withMeta(Primitive.of(value), {
    'name': '_Symbol',
    'source': 'Primitive.of(value)',
    'location': {
      'filename': 'src/primitives.js',
      'start': {
        'line': 211,
        'column': 2
      },
      'end': {
        'line': 211,
        'column': 37
      }
    },
    'module': 'metamagical-interface/src/primitives',
    'homepage': 'https://github.com/origamitower/metamagical#readme',
    'licence': 'MIT',
    'authors': ['Quildreen Motta <queen@robotlolita.me>'],
    'repository': 'git://github.com/origamitower/metamagical.git',
    'npmPackage': 'metamagical-interface',
    'copyright': '(c) 2016 Quildreen Motta',
    'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
    'category': 'JavaScript primitives',
    'stability': 'experimental',
    'type': 'Symbol',
    'documentation': '\nA Symbol.\n\nThis object provides an annotated representation for the underlying\nsymbol JS primitive.\n'
  });

  return _Symbol;
}, {
  'name': 'Symbol',
  'source': 'function(value) {\n  if (typeof value !== "symbol") {\n    throw new TypeError(\'Expected Symbol\');\n  }\n\n  /*~\n   * A Symbol.\n   *\n   * This object provides an annotated representation for the underlying\n   * symbol JS primitive.\n   *\n   * ---\n   * category  : JavaScript primitives\n   * stability : experimental\n   * type: "Symbol"\n   */\n  const Symbol = Primitive.of(value);\n\n  return Symbol;\n}',
  'signature': 'Symbol(value)',
  'belongsTo': function belongsTo() {
    return Primitive;
  },
  'category': 'Types of primitive values',
  'stability': 'experimental',
  'type': '(Symbol) => Primitive\n',
  'documentation': '\nWraps Symbol in a Primitive object.\n'
});

// ---[ Creating primitives ]------------------------------------------

/*~
 * Constructs a new primitive containing the given value.
 *
 * ---
 * category  : Constructing primitives
 * stability : experimental
 * type: |
 *   (primitive) => Primitive
 */
Primitive.of = __metamagical_withMeta(function (value) {
  var result = Object.create(Primitive);
  result[VALUE] = value;
  return result;
}, {
  'name': 'of',
  'source': 'function(value) {\n  let result = Object.create(Primitive);\n  result[VALUE] = value;\n  return result;\n}',
  'signature': 'of(value)',
  'belongsTo': function belongsTo() {
    return Primitive;
  },
  'category': 'Constructing primitives',
  'stability': 'experimental',
  'type': '(primitive) => Primitive\n',
  'documentation': '\nConstructs a new primitive containing the given value.\n'
});

/*~
 * Converts a regular primitive value to a Primitive object, or does
 * nothing if that's already wrapped.
 *
 * ---
 * category  : Constructing primitives
 * stability : experimental
 * type: |
 *   (primitive or Primitive) => Primitive
 */
Primitive.from = __metamagical_withMeta(function (value) {
  if (isPrototypeOf(Primitive, value)) {
    return value;
  } else {
    return value === null ? Primitive.Null(value) : value === undefined ? Primitive.Undefined(value) : typeof value === "boolean" ? Primitive.Boolean(value) : typeof value === "number" ? Primitive.Number(value) : typeof value === "string" ? Primitive.String(value) : (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === "symbol" ? Primitive.Symbol(value) : /* otherwise */notPrimitive(value);
  }
}, {
  'name': 'from',
  'source': 'function(value) {\n  if (isPrototypeOf(Primitive, value)) {\n    return value;\n  } else {\n    return value === null             ?  Primitive.Null(value)\n    :      value === undefined        ?  Primitive.Undefined(value)\n    :      typeof value === "boolean" ?  Primitive.Boolean(value)\n    :      typeof value === "number"  ?  Primitive.Number(value)\n    :      typeof value === "string"  ?  Primitive.String(value)\n    :      typeof value === "symbol"  ?  Primitive.Symbol(value)\n    :      /* otherwise */               notPrimitive(value);\n  }\n}',
  'signature': 'from(value)',
  'belongsTo': function belongsTo() {
    return Primitive;
  },
  'category': 'Constructing primitives',
  'stability': 'experimental',
  'type': '(primitive or Primitive) => Primitive\n',
  'documentation': '\nConverts a regular primitive value to a Primitive object, or does\nnothing if that\'s already wrapped.\n'
});

// --[ Exports ]-------------------------------------------------------
module.exports = Primitive;
},{}],389:[function(require,module,exports){
'use strict';

var __metamagical_withMeta = function metamagical_withMeta(object, meta) {
  var parent = Object.getPrototypeOf(object);var oldMeta = object[Symbol.for('@@meta:magical')] || {};if (parent && parent[Symbol.for('@@meta:magical')] === oldMeta) {
    oldMeta = {};
  }Object.keys(meta).forEach(function (key) {
    if (/^~/.test(key)) {
      oldMeta[key.slice(1)] = meta[key];
    } else {
      oldMeta[key] = meta[key];
    }
  });object[Symbol.for('@@meta:magical')] = oldMeta;return object;
},
    _Refinable$refine,
    _index;

//---------------------------------------------------------------------
//
// This source file is part of the Meta:Magical project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//---------------------------------------------------------------------

// --[ Dependencies ]--------------------------------------------------
var Refinable = require('refinable');

// --[ Implementation ]------------------------------------------------

/*~
 * Handles describing and normalising stability identifiers.
 *
 * ---
 * name     : module stability
 * module   : metamagical-interface/lib/stability
 * category : Metadata
 * platforms:
 *   - ECMAScript 5
 *   - ECMAScript 3 (with `es5-shim`)
 */
module.exports = __metamagical_withMeta(Refinable.refine((_Refinable$refine = {
  fromIdentifier: function fromIdentifier(id) {
    if (this.index.hasOwnProperty(id)) {
      return this.index[id];
    } else {
      throw new Error('No stability with id "' + id + '"');
    }
  },
  index: (_index = {
    deprecated: Refinable.refine({
      index: 0,
      name: 'Deprecated',
      description: '\nThis feature is known to be problematic, and will either be entirely\nremoved from the system, or completely redesigned. You should not rely\non it.'
    }),
    experimental: Refinable.refine({
      index: 1,
      name: 'Experimental',
      description: '\nThis feature is experimental and likely to change (or be removed) in the\nfuture.'
    }),
    stable: Refinable.refine({
      index: 2,
      name: 'Stable',
      description: '\nThis feature is stable, and its API is unlikely to change (unless deemed\nnecessary for security or other important reasons). You should expect\nbackwards compatibility with the system, and a well-defined and automated\n(if possible) migration path if it changes.'
    }),
    locked: Refinable.refine({
      index: 3,
      name: 'Locked',
      description: '\nThis API will not change, however security and other bug fixes will still\nbe applied.'
    })
  }, __metamagical_withMeta(_index['deprecated'], {
    'name': 'deprecated',
    'source': 'Refinable.refine({\n      index: 0,\n      name:  \'Deprecated\',\n      description: `\nThis feature is known to be problematic, and will either be entirely\nremoved from the system, or completely redesigned. You should not rely\non it.`\n    })',
    'location': {
      'filename': 'src/stability.js',
      'start': {
        'line': 58,
        'column': 9
      },
      'end': {
        'line': 121,
        'column': 3
      }
    },
    'module': 'metamagical-interface/src/stability',
    'homepage': 'https://github.com/origamitower/metamagical#readme',
    'licence': 'MIT',
    'authors': ['Quildreen Motta <queen@robotlolita.me>'],
    'repository': 'git://github.com/origamitower/metamagical.git',
    'npmPackage': 'metamagical-interface',
    'copyright': '(c) 2016 Quildreen Motta',
    'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
    'stability': 'stable',
    'category': 'Stability entry',
    'documentation': '\nDescribes deprecated features.\n'
  }), __metamagical_withMeta(_index['experimental'], {
    'name': 'experimental',
    'source': 'Refinable.refine({\n      index: 1,\n      name:  \'Experimental\',\n      description: `\nThis feature is experimental and likely to change (or be removed) in the\nfuture.`\n    })',
    'location': {
      'filename': 'src/stability.js',
      'start': {
        'line': 58,
        'column': 9
      },
      'end': {
        'line': 121,
        'column': 3
      }
    },
    'module': 'metamagical-interface/src/stability',
    'homepage': 'https://github.com/origamitower/metamagical#readme',
    'licence': 'MIT',
    'authors': ['Quildreen Motta <queen@robotlolita.me>'],
    'repository': 'git://github.com/origamitower/metamagical.git',
    'npmPackage': 'metamagical-interface',
    'copyright': '(c) 2016 Quildreen Motta',
    'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
    'stability': 'stable',
    'category': 'Stability entry',
    'documentation': '\nDescribes experimental features.\n'
  }), __metamagical_withMeta(_index['stable'], {
    'name': 'stable',
    'source': 'Refinable.refine({\n      index: 2,\n      name:  \'Stable\',\n      description: `\nThis feature is stable, and its API is unlikely to change (unless deemed\nnecessary for security or other important reasons). You should expect\nbackwards compatibility with the system, and a well-defined and automated\n(if possible) migration path if it changes.`\n    })',
    'location': {
      'filename': 'src/stability.js',
      'start': {
        'line': 58,
        'column': 9
      },
      'end': {
        'line': 121,
        'column': 3
      }
    },
    'module': 'metamagical-interface/src/stability',
    'homepage': 'https://github.com/origamitower/metamagical#readme',
    'licence': 'MIT',
    'authors': ['Quildreen Motta <queen@robotlolita.me>'],
    'repository': 'git://github.com/origamitower/metamagical.git',
    'npmPackage': 'metamagical-interface',
    'copyright': '(c) 2016 Quildreen Motta',
    'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
    'stability': 'stable',
    'category': 'Stability entry',
    'documentation': '\nDescribes stable features.\n'
  }), __metamagical_withMeta(_index['locked'], {
    'name': 'locked',
    'source': 'Refinable.refine({\n      index: 3,\n      name:  \'Locked\',\n      description: `\nThis API will not change, however security and other bug fixes will still\nbe applied.`\n    })',
    'location': {
      'filename': 'src/stability.js',
      'start': {
        'line': 58,
        'column': 9
      },
      'end': {
        'line': 121,
        'column': 3
      }
    },
    'module': 'metamagical-interface/src/stability',
    'homepage': 'https://github.com/origamitower/metamagical#readme',
    'licence': 'MIT',
    'authors': ['Quildreen Motta <queen@robotlolita.me>'],
    'repository': 'git://github.com/origamitower/metamagical.git',
    'npmPackage': 'metamagical-interface',
    'copyright': '(c) 2016 Quildreen Motta',
    'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
    'stability': 'stable',
    'category': 'Stability entry',
    'documentation': '\nDescribes locked features.\n'
  }), _index)
}, __metamagical_withMeta(_Refinable$refine['fromIdentifier'], {
  'name': 'fromIdentifier',
  'source': 'fromIdentifier(id) {\n    if (this.index.hasOwnProperty(id)) {\n      return this.index[id];\n    } else {\n      throw new Error(`No stability with id "${id}"`);\n    }\n  }',
  'signature': 'fromIdentifier(id)',
  'location': {
    'filename': 'src/stability.js',
    'start': {
      'line': 28,
      'column': 34
    },
    'end': {
      'line': 122,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src/stability',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'category': 'Constructing stability entries',
  'stability': 'stable',
  'type': 'Stability.(String) => StabilityEntry\n \n',
  'documentation': '\nConverts a textual identifier of stability to a structured\nrepresentation of the stability.\n'
}), __metamagical_withMeta(_Refinable$refine['index'], {
  'name': 'index',
  'source': '{\n    /*~\n     * Describes deprecated features.\n     *\n     * ---\n     * stability : stable\n     * category  : Stability entry\n     */\n    deprecated: Refinable.refine({\n      index: 0,\n      name:  \'Deprecated\',\n      description: `\nThis feature is known to be problematic, and will either be entirely\nremoved from the system, or completely redesigned. You should not rely\non it.`\n    }),\n\n    /*~\n     * Describes experimental features.\n     *\n     * ---\n     * stability : stable\n     * category  : Stability entry\n     */\n    experimental: Refinable.refine({\n      index: 1,\n      name:  \'Experimental\',\n      description: `\nThis feature is experimental and likely to change (or be removed) in the\nfuture.`\n    }),\n\n    /*~\n     * Describes stable features.\n     *\n     * ---\n     * stability : stable\n     * category  : Stability entry\n     */\n    stable: Refinable.refine({\n      index: 2,\n      name:  \'Stable\',\n      description: `\nThis feature is stable, and its API is unlikely to change (unless deemed\nnecessary for security or other important reasons). You should expect\nbackwards compatibility with the system, and a well-defined and automated\n(if possible) migration path if it changes.`\n    }),\n\n    /*~\n     * Describes locked features.\n     *\n     * ---\n     * stability : stable\n     * category  : Stability entry\n     */\n    locked: Refinable.refine({\n      index: 3,\n      name:  \'Locked\',\n      description: `\nThis API will not change, however security and other bug fixes will still\nbe applied.`\n    })\n  }',
  'location': {
    'filename': 'src/stability.js',
    'start': {
      'line': 28,
      'column': 34
    },
    'end': {
      'line': 122,
      'column': 1
    }
  },
  'module': 'metamagical-interface/src/stability',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'stability': 'stable',
  'category': 'Stability index',
  'documentation': '\nAn index of valid stability identifiers.\n\nMeta:Magical uses [Node\'s stability index](https://nodejs.org/dist/latest-v4.x/docs/api/documentation.html#documentation_stability_index)\n'
}), _Refinable$refine)), {
  'name': 'module stability',
  'source': 'Refinable.refine({\n  /*~\n   * Converts a textual identifier of stability to a structured\n   * representation of the stability.\n   *\n   * ---\n   * category  : Constructing stability entries\n   * stability : stable\n   *\n   * type: |\n   *   Stability.(String) => StabilityEntry\n   */\n  fromIdentifier(id) {\n    if (this.index.hasOwnProperty(id)) {\n      return this.index[id];\n    } else {\n      throw new Error(`No stability with id "${id}"`);\n    }\n  },\n\n\n  /*~\n   * An index of valid stability identifiers.\n   *\n   * Meta:Magical uses [Node\'s stability index](https://nodejs.org/dist/latest-v4.x/docs/api/documentation.html#documentation_stability_index)\n   *\n   * ---\n   * stability : stable\n   * category  : Stability index\n   */\n  index: {\n    /*~\n     * Describes deprecated features.\n     *\n     * ---\n     * stability : stable\n     * category  : Stability entry\n     */\n    deprecated: Refinable.refine({\n      index: 0,\n      name:  \'Deprecated\',\n      description: `\nThis feature is known to be problematic, and will either be entirely\nremoved from the system, or completely redesigned. You should not rely\non it.`\n    }),\n\n    /*~\n     * Describes experimental features.\n     *\n     * ---\n     * stability : stable\n     * category  : Stability entry\n     */\n    experimental: Refinable.refine({\n      index: 1,\n      name:  \'Experimental\',\n      description: `\nThis feature is experimental and likely to change (or be removed) in the\nfuture.`\n    }),\n\n    /*~\n     * Describes stable features.\n     *\n     * ---\n     * stability : stable\n     * category  : Stability entry\n     */\n    stable: Refinable.refine({\n      index: 2,\n      name:  \'Stable\',\n      description: `\nThis feature is stable, and its API is unlikely to change (unless deemed\nnecessary for security or other important reasons). You should expect\nbackwards compatibility with the system, and a well-defined and automated\n(if possible) migration path if it changes.`\n    }),\n\n    /*~\n     * Describes locked features.\n     *\n     * ---\n     * stability : stable\n     * category  : Stability entry\n     */\n    locked: Refinable.refine({\n      index: 3,\n      name:  \'Locked\',\n      description: `\nThis API will not change, however security and other bug fixes will still\nbe applied.`\n    })\n  }\n})',
  'location': {
    'filename': 'src/stability.js',
    'start': {
      'line': 28,
      'column': 0
    },
    'end': {
      'line': 122,
      'column': 3
    }
  },
  'module': 'metamagical-interface/lib/stability',
  'homepage': 'https://github.com/origamitower/metamagical#readme',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'git://github.com/origamitower/metamagical.git',
  'npmPackage': 'metamagical-interface',
  'copyright': '(c) 2016 Quildreen Motta',
  'maintainers': ['Quildreen Motta <queen@robotlolita.me> (http://robotlolita.me/)'],
  'isModule': true,
  'category': 'Metadata',
  'platforms': ['ECMAScript 5', 'ECMAScript 3 (with `es5-shim`)'],
  'documentation': '\nHandles describing and normalising stability identifiers.\n'
});
},{"refinable":393}],390:[function(require,module,exports){
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

//----------------------------------------------------------------------
//
// This source file is part of the Meta:Magical project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

function isObject(object) {
  return Object(object) === object;
}

function groupBy(xs, f) {
  var groups = new Map();

  xs.forEach(function (x) {
    var key = f(x);
    var values = groups.get(key) || [];
    values.push(x);
    groups.set(key, values);
  });

  return [].concat(_toConsumableArray(groups.entries()));
}

function exampleDescription(example) {
  return example.name ? example.name.replace(/_/, ' ') : /* otherwise */'Meta:Magical examples';
}

module.exports = function (meta, describe, it) {
  return function (object) {
    var visited = new Set();
    var _ = meta.fields;

    function isProvided(kind, value) {
      if (kind !== 'getter') {
        return isObject(value);
      } else {
        return !meta.for(value).get(_.isRequired).getOrElse(false);
      }
    }

    function defineTests(object) {
      if (!isObject(object) || visited.has(object)) return;

      var m = meta.for(object);

      visited.add(object);

      m.get(_.examples).chain(function (examples) {
        var exampleGroups = groupBy(examples, exampleDescription);
        exampleGroups.forEach(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2);

          var heading = _ref2[0];
          var functions = _ref2[1];

          it(heading, function () {
            return functions.forEach(function (f) {
              return f.call();
            });
          });
        });
      });

      m.properties().forEach(function (_ref3) {
        var category = _ref3.category;
        var members = _ref3.members;

        describe('(' + category + ')', function () {
          members.forEach(function (_ref4) {
            var name = _ref4.name;
            var kind = _ref4.kind;
            var value = _ref4.value;

            if (isProvided(kind, value)) {
              describe('.' + name, function () {
                return defineTests(value);
              });
            }
          });
        });
      });
    }

    meta.for(object).get(_.name).chain(function (name) {
      describe('Examples in ' + name, function () {
        defineTests(object);
      });
    });
  };
};
},{}],391:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],392:[function(require,module,exports){
"use strict";

// Based on RC4 algorithm, as described in
// http://en.wikipedia.org/wiki/RC4

function isInteger(n) {
  return parseInt(n, 10) === n;
}

function createRC4(N) {
  function identityPermutation() {
    var s = new Array(N);
    for (var i = 0; i < N; i++) {
      s[i] = i;
    }
    return s;
  }

  // :: string | array integer -> array integer
  function seed(key) {
    if (key === undefined) {
      key = new Array(N);
      for (var k = 0; k < N; k++) {
        key[k] = Math.floor(Math.random() * N);
      }
    } else if (typeof key === "string") {
      // to string
      key = "" + key;
      key = key.split("").map(function (c) { return c.charCodeAt(0) % N; });
    } else if (Array.isArray(key)) {
      if (!key.every(function (v) {
        return typeof v === "number" && v === (v | 0);
      })) {
        throw new TypeError("invalid seed key specified: not array of integers");
      }
    } else {
      throw new TypeError("invalid seed key specified");
    }

    var keylen = key.length;

    // resed state
    var s = identityPermutation();

    var j = 0;
    for (var i = 0; i < N; i++) {
      j = (j + s[i] + key[i % keylen]) % N;
      var tmp = s[i];
      s[i] = s[j];
      s[j] = tmp;
    }

    return s;
  }

  /* eslint-disable no-shadow */
  function RC4(key) {
    this.s = seed(key);
    this.i = 0;
    this.j = 0;
  }
  /* eslint-enable no-shadow */

  RC4.prototype.randomNative = function () {
    this.i = (this.i + 1) % N;
    this.j = (this.j + this.s[this.i]) % N;

    var tmp = this.s[this.i];
    this.s[this.i] = this.s[this.j];
    this.s[this.j] = tmp;

    var k = this.s[(this.s[this.i] + this.s[this.j]) % N];

    return k;
  };

  RC4.prototype.randomUInt32 = function () {
    var a = this.randomByte();
    var b = this.randomByte();
    var c = this.randomByte();
    var d = this.randomByte();

    return ((a * 256 + b) * 256 + c) * 256 + d;
  };

  RC4.prototype.randomFloat = function () {
    return this.randomUInt32() / 0x100000000;
  };

  RC4.prototype.random = function () {
    var a;
    var b;

    if (arguments.length === 1) {
      a = 0;
      b = arguments[0];
    } else if (arguments.length === 2) {
      a = arguments[0];
      b = arguments[1];
    } else {
      throw new TypeError("random takes one or two integer arguments");
    }

    if (!isInteger(a) || !isInteger(b)) {
      throw new TypeError("random takes one or two integer arguments");
    }

    return a + this.randomUInt32() % (b - a + 1);
  };

  RC4.prototype.currentState = function () {
    return {
      i: this.i,
      j: this.j,
      s: this.s.slice(), // copy
    };
  };

  RC4.prototype.setState = function (state) {
    var s = state.s;
    var i = state.i;
    var j = state.j;

    /* eslint-disable yoda */
    if (!(i === (i | 0) && 0 <= i && i < N)) {
      throw new Error("state.i should be integer [0, " + (N - 1) + "]");
    }

    if (!(j === (j | 0) && 0 <= j && j < N)) {
      throw new Error("state.j should be integer [0, " + (N - 1) + "]");
    }
    /* eslint-enable yoda */

    // check length
    if (!Array.isArray(s) || s.length !== N) {
      throw new Error("state should be array of length " + N);
    }

    // check that all params are there
    for (var k = 0; k < N; k++) {
      if (s.indexOf(k) === -1) {
        throw new Error("state should be permutation of 0.." + (N - 1) + ": " + k + " is missing");
      }
    }

    this.i = i;
    this.j = j;
    this.s = s.slice(); // assign copy
  };

  return RC4;
}

var RC4 = createRC4(256);
RC4.prototype.randomByte = RC4.prototype.randomNative;

var RC4small = createRC4(16);
RC4small.prototype.randomByte = function () {
  var a = this.randomNative();
  var b = this.randomNative();

  return a * 16 + b;
};

var ordA = "a".charCodeAt(0);
var ord0 = "0".charCodeAt(0);

function toHex(n) {
  return n < 10 ? String.fromCharCode(ord0 + n) : String.fromCharCode(ordA + n - 10);
}

function fromHex(c) {
  return parseInt(c, 16);
}

RC4small.prototype.currentStateString = function () {
  var state = this.currentState();

  var i = toHex(state.i);
  var j = toHex(state.j);

  var res = i + j + state.s.map(toHex).join("");
  return res;
};

RC4small.prototype.setStateString = function (stateString) {
  if (!stateString.match(/^[0-9a-f]{18}$/)) {
    throw new TypeError("RC4small stateString should be 18 hex character string");
  }

  var i = fromHex(stateString[0]);
  var j = fromHex(stateString[1]);
  var s = stateString.split("").slice(2).map(fromHex);

  this.setState({
    i: i,
    j: j,
    s: s,
  });
};

RC4.RC4small = RC4small;

module.exports = RC4;

},{}],393:[function(require,module,exports){
'use strict';

var __metamagical_withMeta = function metamagical_withMeta(object, meta) {
  var parent = Object.getPrototypeOf(object);var oldMeta = object[Symbol.for('@@meta:magical')] || {};if (parent && parent[Symbol.for('@@meta:magical')] === oldMeta) {
    oldMeta = {};
  }Object.keys(meta).forEach(function (key) {
    if (/^~/.test(key)) {
      oldMeta[key.slice(1)] = meta[key];
    } else {
      oldMeta[key] = meta[key];
    }
  });object[Symbol.for('@@meta:magical')] = oldMeta;return object;
},
    _metamagical_withMet,
    __metamagical_assert_equals = function metamagical_assert_equals(assert, actual, expected, message) {
  var assertionType = Symbol.for('@@meta:magical:assertion-type');var rest = Symbol.for('@@meta:magical:assertion-rest');var keys = Object.keys;function isSetoid(value) {
    return value && typeof value.equals === 'function';
  }function isRecord(value) {
    return value && value[assertionType] === 'record';
  }
  function check(predicate) {
    for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }return values.every(predicate);
  }function getSpecialArrayLength(array) {
    var rests = array.map(function (x, i) {
      return [x, i];
    }).filter(function (pair) {
      return pair[0] === rest;
    });if (rests.length > 1 || rests[0] && rests[0][1] !== array.length - 1) {
      assert.ok(false, message);
    }return (rests[0] || [null, array.length])[1];
  }function compareArrays(left, right) {
    var expectedLength = getSpecialArrayLength(right);assert.ok(Array.isArray(left), message);if (left.length < expectedLength) {
      assert.ok(false, message);
    }for (var i = 0; i < expectedLength; ++i) {
      compare(left[i], right[i]);
    }
  }function compareRecord(left, right) {
    var isPartial = right[rest];assert.ok(Object(left) === left, message);if (!isPartial) {
      assert.deepStrictEqual(keys(left).sort(), keys(right).sort(), message);
    }Object.keys(right).forEach(function (key) {
      if (!(key in left)) {
        assert.ok(false, message);
      }compare(left[key], right[key]);
    });
  }function compare(l, r) {
    return check(isSetoid, l, r) ? assert.ok(l.equals(r), message) : Array.isArray(r) ? compareArrays(l, r) : isRecord(r) ? compareRecord(l, r) : /* otherwise */assert.deepStrictEqual(l, r, message);
  }compare(actual, expected);
};

//----------------------------------------------------------------------
//
// This source file is part of the Refinable project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

// -- ALIASES ----------------------------------------------------------
var keys = Object.keys;
var clone = Object.create;
var define = Object.defineProperty;
var descriptor = Object.getOwnPropertyDescriptor;

// -- IMPLEMENTATION ---------------------------------------------------

/*~
 * Provides better primitives for prototype-based OO.
 *
 * While JavaScript uses prototype-based OO, the most important primitive
 * (the "clone" operation, [[Object.create]]) is not available directly
 * on the object you want to extend, and takes property descriptors for
 * new properties, which makes using it less convenient.
 *
 * The Refinable object is a base object that provides the "clone"
 * primitive in a more usable way, instead. The [[refine]] method
 * takes an object, and merges it in a copy of the receiver of the method
 * to create a new object::
 *
 *     const Point2d = Refinable.refine({
 *       x: 0,
 *       y: 0,
 *       toString() {
 *         return this.x + ', ' + this.y
 *       }
 *     });
 *
 *     const p1 = Point2d.refine({ x: 10, y: 10 });
 *     const p2 = p1.refine({ y: 20 });
 *
 *     p1.toString()
 *     // ==> '10, 10'
 *
 *     p2.toString()
 *     // ==> '10, 20'
 *
 * ---
 * module      : refinable
 * isModule    : true
 * copyright   : (c) 2016 Quildreen Motta
 *
 * category : Essential Objects
 * portable : true
 * platforms:
 *   - ECMAScript 5
 *   - ECMAScript 3 (with `es5-shim`)
 *
 * maintainers:
 *   - Quildreen Motta <queen@robotlolita.me>
 */
var Refinable = __metamagical_withMeta((_metamagical_withMet = {
  toString: function toString() {
    return '[object Refinable]';
  },
  refine: function refine(properties) {
    var instance = clone(this);
    var names = keys(properties);

    for (var i = 0; i < names.length; ++i) {
      var name = names[i];
      define(instance, name, descriptor(properties, name));
    }

    return instance;
  }
}, __metamagical_withMeta(_metamagical_withMet['toString'], {
  'name': 'toString',
  'source': 'toString() {\n    return \'[object Refinable]\';\n  }',
  'signature': 'toString()',
  'belongsTo': function belongsTo() {
    return Refinable;
  },
  'category': 'Inspecting',
  'stability': 'stable',
  'type': 'Refinable.() => String\n \n',
  'documentation': '\nA textual representation of this object.\n'
}), __metamagical_withMeta(_metamagical_withMet['refine'], {
  'name': 'refine',
  'source': 'refine(properties) {\n    const instance = clone(this);\n    const names    = keys(properties);\n\n    for (let i = 0; i < names.length; ++i) {\n      const name = names[i];\n      define(instance, name, descriptor(properties, name));\n    }\n\n    return instance;\n  }',
  'signature': 'refine(properties)',
  'belongsTo': function belongsTo() {
    return Refinable;
  },
  'category': 'Refinement',
  'stability': 'stable',
  'complexity': 'O(n), `n` is the number of properties.',
  'type': '(a is Refinable).(Object Any) => (Object Any) <: a\n \n',
  'documentation': '\nConstructs a new object that\'s enhanced with the given properties.\n\nThe [[refine]] operation allows one to copy the receiver object,\nand enhance that copy with the provided properties, in a more\nconvenient way than JavaScript\'s built-in [[Object.create]]:\n\n    const o  = Refinable.refine({ x: 0, y: 3 });\n    const o1 = o.refine({ x: 1 });\n    const o2 = o1.refine({ x: 2 });\n    [o1.x, o1.y];  // ==> [1, 3]\n    [o2.x, o2.y];  // ==> [2, 3]\n',
  'examples': [{
    'name': '',
    'call': __metamagical_withMeta(function () {
      var o = Refinable.refine({ x: 0, y: 3 });var o1 = o.refine({ x: 1 });var o2 = o1.refine({ x: 2 });__metamagical_assert_equals(require('assert'), [o1.x, o1.y], [1, 3], '[o1.x, o1.y] ==> [1, 3]');; // ==> [1, 3]
      __metamagical_assert_equals(require('assert'), [o2.x, o2.y], [2, 3], '[o2.x, o2.y] ==> [2, 3]');; // ==> [2, 3]
    }, {
      'source': 'const o  = Refinable.refine({ x: 0, y: 3 });\nconst o1 = o.refine({ x: 1 });\nconst o2 = o1.refine({ x: 2 });\n[o1.x, o1.y];  // ==> [1, 3]\n[o2.x, o2.y];  // ==> [2, 3]'
    }),
    'inferred': true
  }]
}), _metamagical_withMet), {
  'name': 'Refinable',
  'source': '{\n\n  /*~\n   * A textual representation of this object.\n   *\n   * ---\n   * category  : Inspecting\n   * stability : stable\n   *\n   * type: |\n   *   Refinable.() => String\n   */\n  toString() {\n    return \'[object Refinable]\';\n  },\n\n\n  /*~\n   * Constructs a new object that\'s enhanced with the given properties.\n   *\n   * The [[refine]] operation allows one to copy the receiver object,\n   * and enhance that copy with the provided properties, in a more\n   * convenient way than JavaScript\'s built-in [[Object.create]]::\n   *\n   *     const o  = Refinable.refine({ x: 0, y: 3 });\n   *     const o1 = o.refine({ x: 1 });\n   *     const o2 = o1.refine({ x: 2 });\n   *     [o1.x, o1.y];  // ==> [1, 3]\n   *     [o2.x, o2.y];  // ==> [2, 3]\n   *\n   * ---\n   * category  : Refinement\n   * stability : stable\n   *\n   * complexity : O(n), `n` is the number of properties.\n   * type: |\n   *   (a is Refinable).(Object Any) => (Object Any) <: a\n   */\n  refine(properties) {\n    const instance = clone(this);\n    const names    = keys(properties);\n\n    for (let i = 0; i < names.length; ++i) {\n      const name = names[i];\n      define(instance, name, descriptor(properties, name));\n    }\n\n    return instance;\n  }\n}',
  'location': {
    'filename': 'src/index.js',
    'start': {
      'line': 65,
      'column': 0
    },
    'end': {
      'line': 114,
      'column': 2
    }
  },
  'module': 'refinable',
  'licence': 'MIT',
  'authors': ['Quildreen Motta <queen@robotlolita.me>'],
  'repository': 'https://github.com/origamitower/refinable.git',
  'npmPackage': 'refinable',
  'isModule': true,
  'copyright': '(c) 2016 Quildreen Motta',
  'category': 'Essential Objects',
  'portable': true,
  'platforms': ['ECMAScript 5', 'ECMAScript 3 (with `es5-shim`)'],
  'maintainers': ['Quildreen Motta <queen@robotlolita.me>'],
  'documentation': '\nProvides better primitives for prototype-based OO.\n\nWhile JavaScript uses prototype-based OO, the most important primitive\n(the "clone" operation, [[Object.create]]) is not available directly\non the object you want to extend, and takes property descriptors for\nnew properties, which makes using it less convenient.\n\nThe Refinable object is a base object that provides the "clone"\nprimitive in a more usable way, instead. The [[refine]] method\ntakes an object, and merges it in a copy of the receiver of the method\nto create a new object:\n\n    const Point2d = Refinable.refine({\n      x: 0,\n      y: 0,\n      toString() {\n        return this.x + \', \' + this.y\n      }\n    });\n\n    const p1 = Point2d.refine({ x: 10, y: 10 });\n    const p2 = p1.refine({ y: 20 });\n\n    p1.toString()\n    // ==> \'10, 10\'\n\n    p2.toString()\n    // ==> \'10, 20\'\n',
  'examples': [{
    'name': '',
    'call': __metamagical_withMeta(function () {
      var Point2d = Refinable.refine({ x: 0, y: 0, toString: function toString() {
          return this.x + ', ' + this.y;
        }
      });var p1 = Point2d.refine({ x: 10, y: 10 });var p2 = p1.refine({ y: 20 });__metamagical_assert_equals(require('assert'), p1.toString(), '10, 10', 'p1.toString() ==> \'10, 10\'');; // ==> '10, 10'
      __metamagical_assert_equals(require('assert'), p2.toString(), '10, 20', 'p2.toString() ==> \'10, 20\'');; // ==> '10, 20'
    }, {
      'source': 'const Point2d = Refinable.refine({\n  x: 0,\n  y: 0,\n  toString() {\n    return this.x + \', \' + this.y\n  }\n});\n\nconst p1 = Point2d.refine({ x: 10, y: 10 });\nconst p2 = p1.refine({ y: 20 });\n\np1.toString()\n// ==> \'10, 10\'\n\np2.toString()\n// ==> \'10, 20\''
    }),
    'inferred': true
  }]
});

module.exports = Refinable;
},{"assert":54}],394:[function(require,module,exports){
(function (process,global){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var hasOwn = Object.prototype.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided, then outerFn.prototype instanceof Generator.
    var generator = Object.create((outerFn || Generator).prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `value instanceof AwaitArgument` to determine if the yielded value is
  // meant to be awaited. Some may consider the name of this method too
  // cutesy, but they are curmudgeons.
  runtime.awrap = function(arg) {
    return new AwaitArgument(arg);
  };

  function AwaitArgument(arg) {
    this.arg = arg;
  }

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value instanceof AwaitArgument) {
          return Promise.resolve(value.arg).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof process === "object" && process.domain) {
      invoke = process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          if (method === "return" ||
              (method === "throw" && delegate.iterator[method] === undefined)) {
            // A return or throw (when the delegate iterator has no throw
            // method) always terminates the yield* loop.
            context.delegate = null;

            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            var returnMethod = delegate.iterator["return"];
            if (returnMethod) {
              var record = tryCatch(returnMethod, delegate.iterator, arg);
              if (record.type === "throw") {
                // If the return method threw an exception, let that
                // exception prevail over the original return or throw.
                method = "throw";
                arg = record.arg;
                continue;
              }
            }

            if (method === "return") {
              // Continue with the outer return, now that the delegate
              // iterator has been terminated.
              continue;
            }
          }

          var record = tryCatch(
            delegate.iterator[method],
            delegate.iterator,
            arg
          );

          if (record.type === "throw") {
            context.delegate = null;

            // Like returning generator.throw(uncaught), but without the
            // overhead of an extra function call.
            method = "throw";
            arg = record.arg;
            continue;
          }

          // Delegate generator ran and handled its own exceptions so
          // regardless of what the method was, we continue as if it is
          // "next" with an undefined arg.
          method = "next";
          arg = undefined;

          var info = record.arg;
          if (info.done) {
            context[delegate.resultName] = info.value;
            context.next = delegate.nextLoc;
          } else {
            state = GenStateSuspendedYield;
            return info;
          }

          context.delegate = null;
        }

        if (method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = arg;

        } else if (method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw arg;
          }

          if (context.dispatchException(arg)) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            method = "next";
            arg = undefined;
          }

        } else if (method === "return") {
          context.abrupt("return", arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          var info = {
            value: record.arg,
            done: context.done
          };

          if (record.arg === ContinueSentinel) {
            if (context.delegate && method === "next") {
              // Deliberately forget the last sent value so that we don't
              // accidentally pass it on to the delegate.
              arg = undefined;
            }
          } else {
            return info;
          }

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(arg) call above.
          method = "throw";
          arg = record.arg;
        }
      }
    };
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp[toStringTagSymbol] = "Generator";

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;
        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.next = finallyEntry.finallyLoc;
      } else {
        this.complete(record);
      }

      return ContinueSentinel;
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = record.arg;
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this
);

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":391}],395:[function(require,module,exports){
"use strict";

/**

# trampa

Trampolines, to emulate tail-call recursion.

[![Build Status](https://secure.travis-ci.org/phadej/trampa.svg?branch=master)](http://travis-ci.org/phadej/trampa)
[![NPM version](https://badge.fury.io/js/trampa.svg)](http://badge.fury.io/js/trampa)
[![Dependency Status](https://david-dm.org/trampa/trampa.svg)](https://david-dm.org/trampa/trampa)
[![devDependency Status](https://david-dm.org/trampa/trampa/dev-status.svg)](https://david-dm.org/trampa/trampa#info=devDependencies)
[![Code Climate](https://img.shields.io/codeclimate/github/phadej/trampa.svg)](https://codeclimate.com/github/phadej/trampa)

## Synopsis

```js
var trampa = require("trampa");

function loop(n, acc) {
  return n === 0 ? trampa.wrap(acc) : trampa.lazy(function () {
    return loop(n - 1, acc + 1);
  });
}

loop(123456789, 0).run(); // doesn't cause stack overflow!
```

## API

*/

// loosely based on https://apocalisp.wordpress.com/2011/10/26/tail-call-elimination-in-scala-monads/

var assert = require("assert");

function Done(x) {
  this.x = x;
}

function Cont(tramp, cont) {
  assert(typeof cont === "function");
  this.tramp = tramp;
  this.cont = cont;
}

/**
- `isTrampoline(t: obj): bool` &mdash; Returns, whether `t` is a trampolined object.
*/
function isTrampoline(t) {
  return t instanceof Done || t instanceof Cont;
}

/**
- `wrap(t: Trampoline a | a): Trampoline a` &mdash; Wrap `t` into trampoline, if it's not already one.
*/
function wrap(t) {
  return isTrampoline(t) ? t : new Done(t);
}

/**
- `lazy(t : () -> Trampoline a | a)` &mdash; Wrap lazy computation into trampoline. Useful when constructing computations.
*/
function lazy(computation) {
  assert(typeof computation === "function", "lazy: computation should be function");
  return wrap().jump(computation);
}

/**
- `Trampoline.jump(f : a -> b | Trampoline b)` &mdash; *map* or *flatmap* trampoline computation. Like `.then` for promises.
*/
Done.prototype.jump = function (f) {
  return new Cont(this, function (x) {
    return wrap(f(x));
  });
};

Cont.prototype.jump = Done.prototype.jump;

function execute(curr, params) {
  params = params || {};
  var debug = params.debug || false;
  var log = params.log || console.log;
  var stack = [];

  while (true) { // eslint-disable-line no-constant-condition
    if (debug) {
      log("trampoline execute: stack size " + stack.length);
    }

    if (curr instanceof Done) {
      if (stack.length === 0) {
        return curr.x;
      } else {
        curr = stack[stack.length - 1](curr.x);
        stack.pop();
      }
    } else {
      assert(curr instanceof Cont);
      stack.push(curr.cont);
      curr = curr.tramp;
    }
  }
}

/**
- `Trampoline.run(): a` &mdash; Run the trampoline synchronously resulting a value.
*/
Done.prototype.run = Cont.prototype.run = function (params) {
  return execute(this, params);
};

module.exports = {
  isTrampoline: isTrampoline,
  wrap: wrap,
  lazy: lazy,
};

/**
## Changelog

- **1.0.0** &mdash; *2015-07-14* &mdash; Initial release
*/

},{"assert":54}],396:[function(require,module,exports){
/**
  # typify type parser

  > Type signature parser for typify

  [![Build Status](https://secure.travis-ci.org/phadej/typify-parser.svg?branch=master)](http://travis-ci.org/phadej/typify-parser)
  [![NPM version](https://badge.fury.io/js/typify-parser.svg)](http://badge.fury.io/js/typify-parser)
  [![Dependency Status](https://david-dm.org/phadej/typify-parser.svg)](https://david-dm.org/phadej/typify-parser)
  [![devDependency Status](https://david-dm.org/phadej/typify-parser/dev-status.svg)](https://david-dm.org/phadej/typify-parser#info=devDependencies)
  [![Code Climate](https://img.shields.io/codeclimate/github/phadej/typify-parser.svg)](https://codeclimate.com/github/phadej/typify-parser)

  Turns `(foo, bar 42) -> quux` into
  ```js
  {
    "type": "function",
    "arg": {
      "type": "product",
      "args": [
        {
          "type": "ident",
          "value": "foo"
        },
        {
          "type": "application",
          "callee": {
            "type": "ident",
            "value": "bar"
          },
          "args": [
            {
              "type": "number",
              "value": 42
            }
          ]
        }
      ]
    },
    "result": {
      "type": "ident",
      "value": "quux"
    }
  }
  ```

  ## Synopsis

  ```js
  var parser = require("typify-parser");

  // Example from above
  var t = parser("(foo, bar 42) -> quux");

  // Free vars
  p.freeVars(t);                             // ['bar', 'foo', 'quux']
  p.freeVars(p("rec list -> () | a & list")) // ['a']
  ```
*/
"use strict";

function unescapeString(str) {
  return str.replace(/\\(?:'|"|\\|n|x[0-9a-fA-F]{2})/g, function (match) {
    switch (match[1]) {
      case "'": return "'";
      case "\"": return "\"";
      case "\\": return "\\";
      case "n": return "\n";
      case "x": return String.fromCharCode(parseInt(match.substr(2), 16));
    }
  });
}

function lex(input) {
  // Unicode
  // top: 22a4
  // bottom: 22a5
  // and: 2227
  // or: 2228
  // times: \u00d7
  // to: 2192
  // ellipsis: 2026
  // blackboard 1: d835 dfd9
  var m = input.match(/^([ \t\r\n]+|[\u22a4\u22a5\u2227\u2228\u00d7\u2192\u2026]|\ud835\udfd9|_\|_|\*|\(\)|"(?:[^"\\]|\\[\\'"n]|\\x[0-9a-fA-F]{2})*"|'(?:[^'\\]|\\[\\'"n]|\\x[0-9a-fA-F]{2})*'|[0-9a-zA-Z_\$@]+|,|->|:|;|&|\||\.\.\.|\(|\)|\[|\]|\{|\}|\?)*$/);
  if (m === null) {
    throw new SyntaxError("Cannot lex type signature");
  }
  m = input.match(/([ \t\r\n]+|[\u22a4\u22a5\u2227\u2228\u00d7\u2192\u2026]|\ud835\udfd9|_\|_|\*|\(\)|"(?:[^"\\]|\\[\\'"n]|\\x[0-9a-fA-F]{2})*"|'(?:[^'\\]|\\[\\'"n]|\\x[0-9a-fA-F]{2})*'|[0-9a-zA-Z_\$@]+|,|->|:|;|&|\||\.\.\.|\(|\)|\[|\]|\{|\}|\?)/g);

  return m
  .map(function (token) {
    switch (token) {
      case "_|_": return { type: "false" };
      case "\u22a5": return { type: "false" };
      case "*": return { type: "true" };
      case "\u22a4": return { type: "true" };
      case "()": return { type: "unit" };
      case "\ud835\udfd9": return { type: "unit" };
      case "true": return { type: "bool", value: true };
      case "false": return { type: "bool", value: false };
      case "rec": return { type: "rec" };
      case "&": return { type: "&" };
      case "\u2227": return { type: "&" };
      case "|": return { type: "|" };
      case "\u2228": return { type: "|" };
      case ",": return { type: "," };
      case "\u00d7": return { type: "," };
      case ";": return { type: ";" };
      case ":": return { type: ":" };
      case "(": return { type: "(" };
      case ")": return { type: ")" };
      case "[": return { type: "[" };
      case "]": return { type: "]" };
      case "{": return { type: "{" };
      case "}": return { type: "}" };
      case "?": return { type: "?" };
      case "->": return { type: "->" };
      case "\u2192": return { type: "->" };
      case "...": return { type: "..." };
      case "\u2026": return { type: "..." };
    }

    // Whitespace
    if (token.match(/^[ \r\r\n]+$/)) {
      return null;
    }

    if (token.match(/^[0-9]+/)) {
      return { type: "number", value: parseInt(token, 10) };
    }

    if (token[0] === "'" || token[0] === "\"") {
      token = token.slice(1, -1);
      return { type: "string", value: unescapeString(token) };
    }

    return { type: "ident", value: token };
  })
  .filter(function (token) {
    return token !== null;
  });
}

function makePunctParser(type) {
  return function (state) {
    if (state.pos >= state.len) {
      throw new SyntaxError("Expecting identifier, end-of-input found");
    }

    var token = state.tokens[state.pos];
    if (token.type !== type) {
      throw new SyntaxError("Expecting '" + type + "', found: " + token.type);
    }
    state.pos += 1;

    return type;
  };
}

var colonParser = makePunctParser(":");
var openCurlyParser = makePunctParser("{");
var closeCurlyParser = makePunctParser("}");
var semicolonParser = makePunctParser(";");
var openParenParser = makePunctParser("(");
var closeParenParser = makePunctParser(")");
var openBracketParser = makePunctParser("[");
var closeBracketParser = makePunctParser("]");
var recKeywordParser = makePunctParser("rec");
var arrowParser = makePunctParser("->");

function nameParser(state) {
  if (state.pos >= state.len) {
    throw new SyntaxError("Expecting identifier, end-of-input found");
  }

  var token = state.tokens[state.pos];
  if (token.type !== "ident") {
    throw new SyntaxError("Expecting 'ident', found: " + token.type);
  }
  state.pos += 1;

  return token.value;
}

function recursiveParser(state) {
  recKeywordParser(state);
  var name = nameParser(state);
  arrowParser(state);
  var value = typeParser(state); // eslint-disable-line no-use-before-define
  return {
    type: "recursive",
    name: name,
    arg: value,
  };
}

function recordParser(state) {
  openCurlyParser(state);

  var token = state.tokens[state.pos];
  if (token && token.type === "}") {
    closeCurlyParser(state);
    return { type: "record", fields: {} };
  }

  var fields = {};

  while (true) { // eslint-disable-line no-constant-condition
    // read
    var name = nameParser(state);
    colonParser(state);
    var value = typeParser(state); // eslint-disable-line no-use-before-define

    // assign to fields
    fields[name] = value;

    // ending token
    token = state.tokens[state.pos];

    // break if }
    if (token && token.type === "}") {
      closeCurlyParser(state);
      break;
    } else if (token && token.type === ";") {
      semicolonParser(state);
    } else {
      throw new SyntaxError("Expecting '}' or ';', found: " + token.type);
    }
  }

  return { type: "record", fields: fields };
}

function postfix(parser, postfixToken, constructor) {
  return function (state) {
    var arg = parser(state);

    var token = state.tokens[state.pos];
    if (token && token.type === postfixToken) {
      state.pos += 1;
      return {
        type: constructor,
        arg: arg,
      };
    } else {
      return arg;
    }
  };
}

// this ties the knot
var optionalParser = postfix(terminalParser, "?", "optional"); // eslint-disable-line no-use-before-define

function applicationParser(state) {
  var rator = optionalParser(state);
  var rands = [];

  while (true) { // eslint-disable-line no-constant-condition
    var pos = state.pos;
    // XXX: we shouldn't use exceptions for this
    try {
      var arg = optionalParser(state);
      rands.push(arg);
    } catch (err) {
      state.pos = pos;
      break;
    }
  }

  if (rands.length === 0) {
    return rator;
  } else {
    return {
      type: "application",
      callee: rator,
      args: rands,
    };
  }
}

function separatedBy(parser, separator, constructor) {
  return function (state) {
    var list = [parser(state)];
    while (true) { // eslint-disable-line no-constant-condition
      // separator
      var token = state.tokens[state.pos];
      if (token && token.type === separator) {
        state.pos += 1;
      } else {
        break;
      }

      // right argument
      list.push(parser(state));
    }

    if (list.length === 1) {
      return list[0];
    } else {
      return {
        type: constructor,
        args: list,
      };
    }
  };
}

var conjunctionParser = separatedBy(applicationParser, "&", "conjunction");
var disjunctionParser = separatedBy(conjunctionParser, "|", "disjunction");

// TODO: combine with optional
var variadicParser = postfix(disjunctionParser, "...", "variadic");

function namedParser(state) {
  var token1 = state.tokens[state.pos];
  var token2 = state.tokens[state.pos + 1];
  if (token1 && token2 && token1.type === "ident" && token2.type === ":") {
    state.pos += 2;
    var arg = namedParser(state);
    return {
      type: "named",
      name: token1.value,
      arg: arg,
    };
  } else {
    return variadicParser(state);
  }
}

var productParser = separatedBy(namedParser, ",", "product");

function functionParser(state) {
  var v = productParser(state);

  var token = state.tokens[state.pos];
  if (token && token.type === "->") {
    state.pos += 1;
    var result = functionParser(state);
    return {
      type: "function",
      arg: v,
      result: result,
    };
  } else {
    return v;
  }
}

function typeParser(state) {
  return functionParser(state);
}

function parenthesesParser(state) {
  openParenParser(state);
  var type = typeParser(state);
  closeParenParser(state);
  return type;
}

function bracketParser(state) {
  openBracketParser(state);
  var type = typeParser(state);
  closeBracketParser(state);
  return {
    type: "brackets",
    arg: type,
  };
}

function terminalParser(state) {
  if (state.pos >= state.len) {
    throw new SyntaxError("Expecting terminal, end-of-input found");
  }

  var token = state.tokens[state.pos];
  switch (token.type) {
    case "false":
    case "true":
    case "unit":
    case "string":
    case "number":
    case "bool":
    case "ident":
      state.pos += 1;
      return token;
    case "{":
      return recordParser(state);
    case "(":
      return parenthesesParser(state);
    case "[":
      return bracketParser(state);
    case "rec":
      return recursiveParser(state);
    default:
      throw new SyntaxError("Expecting terminal, " + token.type + " found");
  }
}

function parse(input) {
  // console.log(input);
  var tokens = lex(input);
  // console.log(tokens);
  var state = {
    pos: 0,
    len: tokens.length,
    tokens: tokens,
  };

  var res = typeParser(state);
  // console.log(state);
  if (state.pos !== state.len) {
    throw new SyntaxError("expecting end-of-input, " + tokens[state.pos].type + " found");
  }
  return res;
}

function recordFreeVars(fields) {
  var res = [];
  for (var k in fields) {
    var t = fields[k];
    res = res.concat(freeVarsImpl(t)); // eslint-disable-line no-use-before-define
  }
  return res;
}

function concatFreeVars(ts) {
  var res = [];
  for (var i = 0; i < ts.length; i++) {
    var t = ts[i];
    res = res.concat(freeVarsImpl(t)); // eslint-disable-line no-use-before-define
  }
  return res;
}

function freeVarsImpl(t) {
  switch (t.type) {
    case "false":
    case "true":
    case "unit":
    case "string":
    case "number":
    case "bool":
      return [];
    case "ident": return [t.value];
    case "record": return recordFreeVars(t.fields);
    case "named": return freeVarsImpl(t.arg);
    case "conjunction": return concatFreeVars(t.args);
    case "disjunction": return concatFreeVars(t.args);
    case "product": return concatFreeVars(t.args);
    case "recursive": return freeVarsImpl(t.arg).filter(function (n) {
      return n !== t.name;
    });
    case "optional": return freeVarsImpl(t.arg);
    case "brackets": return freeVarsImpl(t.arg);
    case "variadic": return freeVarsImpl(t.arg);
    case "application": return freeVarsImpl(t.callee).concat(concatFreeVars(t.args));
    case "function": return freeVarsImpl(t.arg).concat(freeVarsImpl(t.result));
    //default: throw new Error("Unknown type " + t.type);
  }
}

function uniq(arr) {
  var res = [];
  for (var i = 0; i < arr.length; i++) {
    var x = arr[i];
    if (res.indexOf(x) === -1) {
      res.push(x);
    }
  }
  return res;
}

function freeVars(t) {
  var fvs = freeVarsImpl(t);
  fvs.sort();
  return uniq(fvs);
}

parse.freeVars = freeVars;

module.exports = parse;

},{}],397:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],398:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],399:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":398,"_process":391,"inherits":397}],400:[function(require,module,exports){
(function (process){
require('babel-polyfill');
require('es5-shim');
require('es6-shim');

process.env.FOLKTALE_ASSERTIONS = 'none';

require('../specs/core.adt');
require('../specs/core.lambda');
require('../specs/data.either');
require('../specs/data.maybe');
require('../specs/data.validation');
require('../specs/documentation');
}).call(this,require('_process'))
},{"../specs/core.adt":401,"../specs/core.lambda":402,"../specs/data.either":403,"../specs/data.maybe":404,"../specs/data.validation":405,"../specs/documentation":406,"_process":391,"babel-polyfill":55,"es5-shim":352,"es6-shim":353}],401:[function(require,module,exports){
'use strict';

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Copyright (C) 2015-2016 Quildreen Motta.
// Licensed under the MIT licence.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

var _require = require('jsverify');

var property = _require.property;
var forall = _require.forall;

var _require2 = require('../../core/adt');

var data = _require2.data;
var setoid = _require2.setoid;
var show = _require2.show;
var serialize = _require2.serialize;


describe('Data.ADT.derive', function () {
  describe('Setoid', function () {
    var _data$derive = data('AB', {
      A: function A(value) {
        return { value: value };
      },
      B: function B(value) {
        return { value: value };
      }
    }).derive(setoid);

    var A = _data$derive.A;
    var B = _data$derive.B;


    property('Different simple values are NOT equal', 'json', function (a) {
      return !A(a).equals(B(a));
    });
    property('Different composite values are NOT equal', 'json', function (a) {
      return !A(B(a)).equals(A(a));
    });
    property('Similar simple values are equal', 'json', function (a) {
      return A(a).equals(A(a));
    });
    property('Similar composite values are equal', 'json', function (a) {
      return A(B(a)).equals(A(B(a)));
    });

    describe('Setoid#withEquality', function () {
      var _data$derive2 = data('A', {
        A: function A(value) {
          return { value: value };
        }
      }).derive(setoid.withEquality(function (a, b) {
        return a.id === b.id;
      }));

      var A = _data$derive2.A;


      property('Values are compared using a custom function if provided', 'json', 'json', function (a, b) {
        return A({ id: 1, _irrelevantValue: a }).equals(A({ id: 1, _irrelevantValue: b }));
      });
    });
  });
  describe('Show', function () {
    var AB = data('AB', {
      A: function A(value) {
        return { value: value };
      },
      B: function B(value) {
        return { value: value };
      }
    }).derive(show);

    property('Types have a string representation', function () {
      return AB.toString() === 'AB';
    });

    property('Variants have a string representation', function () {
      return AB.A.toString() === 'AB.A';
    });
    property('Primitive Values have a string representation', function () {
      return AB.A(1).toString() === 'AB.A({ value: 1 })';
    });
    property('Complex Values have a string representation', function () {
      return AB.A({ foo: "bar" }).toString() === 'AB.A({ value: { foo: "bar" } })';
    });
    property('Functions have a string representation', function () {
      return AB.A(function (a) {
        return a;
      }).toString() === 'AB.A({ value: [Function] })';
    });
    property('Named functions have a string representation', function () {
      return AB.A(function foo() {}).toString() === 'AB.A({ value: [Function: foo] })';
    });
    property('Symbols have a string representation', function () {
      console.log(AB.A(Symbol('foo')).toString());
      return AB.A(Symbol('foo')).toString() === 'AB.A({ value: Symbol(foo) })';
    });
    property('Recursive Values have a string representation', function () {
      return AB.A({ rec: AB.A(1) }).toString() === 'AB.A({ value: { rec: AB.A({ value: 1 }) } })';
    });
  });
  describe('Serialize', function () {
    var AB = data('folktale:AB', {
      A: function A(value) {
        return { value: value };
      },
      B: function B(value) {
        return { value: value };
      }
    }).derive(serialize, setoid);

    var CD = data('folktale:CD', {
      C: function C(value) {
        return { value: value };
      },
      D: function D(value) {
        return { value: value };
      }
    }).derive(serialize, setoid);

    var A = AB.A;
    var B = AB.B;
    var C = CD.C;
    var D = CD.D;


    property('Serializing a value and deserializing it yields a similar value', 'json', function (a) {
      return AB.fromJSON(A(a).toJSON()).equals(A(a));
    });
    property('Serializing a *recursive* value and deserializing it yields a similar value', 'json', function (a) {
      return AB.fromJSON(A(B(a)).toJSON()).equals(A(B(a)));
    });

    property('Serializing a *composite* value and deserializing it yields a similar value (when the proper parsers are provided).', 'json', function (a) {
      return AB.fromJSON(A(B(C(a))).toJSON(), { AB: AB, CD: CD }).equals(A(B(C(a))));
    });
  });
});
},{"../../core/adt":2,"jsverify":368}],402:[function(require,module,exports){
'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Copyright (C) 2015-2016 Quildreen Motta.
// Licensed under the MIT licence.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

var _require = require('jsverify');

var property = _require.property;

var assert = require('assert');
var _ = require('../..').core.lambda;

var eqPairs = function eqPairs() {
  for (var _len = arguments.length, xs = Array(_len), _key = 0; _key < _len; _key++) {
    xs[_key] = arguments[_key];
  }

  return xs.reduce(function (p, x) {
    return p.r && (!('v' in p) || p.v === x) ? { r: true, v: x } : /* otherwise */{ r: false };
  }, { r: true }).r;
};

describe('Core.Lambda', function () {
  describe('compose(f, g)', function () {
    property('= f(g(x))', 'integer', function (a) {
      var f = function f(x) {
        return x - 1;
      };
      var g = function g(y) {
        return y * 2;
      };
      return _.compose(f, g)(a) === f(g(a));
    });

    property('Associativity: compose(f, compose(g, h)) = compose(compose(f, g), h)', 'integer', function (a) {
      var f = function f(x) {
        return x - 1;
      };
      var g = function g(x) {
        return x * 2;
      };
      var h = function h(x) {
        return x / 3;
      };
      return _.compose(f, _.compose(g, h))(a) === _.compose(_.compose(f, g), h)(a);
    });
  });

  describe('constant(a)()', function () {
    property('= a', 'nat', function (a) {
      return _.constant(a)() === a;
    });
  });

  describe('identity(a)', function () {
    property('= a', 'nat', function (a) {
      return _.identity(a) === a;
    });
  });

  describe('curry(arity, fn)', function () {
    var f = function f(a, b) {
      return a(b);
    };
    var g = function g(a) {
      return a + 1;
    };
    var h = function h(a) {
      return function (b) {
        return a(b) + 1;
      };
    };
    var i = function i(a, b, c, d) {
      return a + b + c + d;
    };

    it('invoking with fewer arguments yields a new function that takes the rest', function () {
      assert.equal(_typeof(_.curry(2, f)(g)), 'function');
      assert.equal(_.curry(2, f)(g)(1), 2);
    });

    it('invoking with the correct number of arguments invokes the underlying operation', function () {
      assert.equal(_.curry(2, f)(g, 1), 2);
    });

    it('invoking with more arguments passes the remaining arguments to the result of the operation', function () {
      assert.equal(_.curry(2, f)(h, g)(1), 3);
    });

    property('should support any kind of arguments grouping', 'nat & nat & nat & nat', function (_ref) {
      var _ref2 = _slicedToArray(_ref, 4);

      var a = _ref2[0];
      var b = _ref2[1];
      var c = _ref2[2];
      var d = _ref2[3];

      return eqPairs(_.curry(4, i)(a)(b)(c)(d), _.curry(4, i)(a, b, c, d), _.curry(4, i)(a, b, c)(d), _.curry(4, i)(a, b)(c, d), _.curry(4, i)(a)(b, c, d), _.curry(4, i)(a)(b, c)(d), _.curry(4, i)(a, b)(c)(d), _.curry(4, i)(a)(b)(c, d), a + b + c + d);
    });
  });
});
},{"../..":53,"assert":54,"jsverify":368}],403:[function(require,module,exports){
'use strict';

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Copyright (C) 2015-2016 Quildreen Motta.
// Licensed under the MIT licence.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

var _require = require('jsverify');

var property = _require.property;
var forall = _require.forall;

var _ = require('../..').data.either;

describe('Data.Either', function () {

  describe('constructors', function () {
    property('try#Left', 'json', function (a) {
      return _.try(function (a) {
        throw a;
      })(a).equals(_.Left(a));
    });

    property('try#Right', 'json', function (a) {
      return _.try(function () {
        return a;
      })(a).equals(_.Right(a));
    });
  });

  describe('Functor', function () {
    property('map', 'json', 'json -> json', function (a, f) {
      return _.of(f(a)).equals(_.of(a).map(f));
    });

    property('Left#map', 'json', 'json -> json', function (a, f) {
      return _.Left(a).map(f).equals(_.Left(a));
    });
  });

  describe('Applicative', function () {
    property('of', 'json', 'json', function (a, b) {
      return a === b === _.of(a).equals(_.of(b));
    });

    property('ap', 'json', 'json -> json', function (a, f) {
      return _.of(f).ap(_.of(a)).equals(_.of(f(a)));
    });
  });

  describe('Chain', function () {
    var lift = function lift(f) {
      return function (a) {
        return _.of(f(a));
      };
    };
    property('chain', 'json', 'json -> json', function (a, f) {
      return _.of(a).chain(lift(f)).equals(lift(f)(a));
    });

    property('Left#chain', 'json', 'json -> json', function (a, f) {
      return _.Left(a).chain(lift(f)).equals(_.Left(a));
    });
  });

  describe('extracting/recovering', function () {
    property('Left#getOrElse', 'json', 'json', function (a, b) {
      return _.Left(b).getOrElse(a) === a;
    });
    property('Right#getOrElse', 'json', 'json', function (a, b) {
      return _.Right(b).getOrElse(a) === b;
    });

    property('Left#orElse', 'json', 'json', function (a, b) {
      return _.Left(b).orElse(function () {
        return a;
      }) === a;
    });
    property('Right#orElse', 'json', 'json', function (a, b) {
      return _.Right(b).orElse(function () {
        return b;
      }).equals(_.Right(b));
    });
  });
  describe('folds', function () {
    var id = function id(a) {
      return a;
    };
    property('Left#fold', 'json', 'json -> json', function (a, f) {
      return _.Left(a).fold(f, id) === f(a);
    });
    property('Right#fold', 'json', 'json -> json', function (a, f) {
      return _.Right(a).fold(id, f) === f(a);
    });

    property('Left#merge', 'json', function (a) {
      return _.Left(a).merge() === a;
    });
    property('Right#merge', 'json', function (a) {
      return _.Right(a).merge() === a;
    });

    property('Left#swap', 'json', function (a) {
      return _.Left(a).swap().equals(_.Right(a));
    });
    property('Right#swap', 'json', function (a) {
      return _.Right(a).swap().equals(_.Left(a));
    });

    property('Left#bimap', 'json', 'json -> json', function (a, f) {
      return _.Left(a).bimap(f, id).equals(_.Left(f(a)));
    });
    property('Right#bimap', 'json', 'json -> json', function (a, f) {
      return _.Right(a).bimap(id, f).equals(_.Right(f(a)));
    });

    property('Left#leftMap', 'json', 'json -> json', function (a, f) {
      return _.Left(f(a)).equals(_.Left(a).leftMap(f));
    });

    property('Right#leftMap', 'json', 'json -> json', function (a, f) {
      return _.Right(a).leftMap(f).equals(_.Right(a));
    });
  });
  describe('Conversions', function () {
    property('Left#fromNullable', function () {
      return _.fromNullable(null).equals(_.Left(null));
    });

    property('Right#fromNullable', 'json', function (a) {
      return _.fromNullable(a).equals(_.Right(a));
    });
    property('Either#fromValidation', 'json', function (a) {
      return _.fromValidation(_.Left(a).toValidation()).equals(_.Left(a));
    });
    property('Left#fromMaybe', 'string', 'string', function (a, b) {
      return _.fromMaybe(_.Left(b).toMaybe(), b).equals(_.Left(b));
    });
    property('Right#fromMaybe', 'json', 'json', function (a, b) {
      return _.fromMaybe(_.Right(a).toMaybe(), b).equals(_.Right(a));
    });
  });
});
},{"../..":53,"jsverify":368}],404:[function(require,module,exports){
'use strict';

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Copyright (C) 2015-2016 Quildreen Motta.
// Licensed under the MIT licence.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

var _require = require('jsverify');

var property = _require.property;
var forall = _require.forall;

var _ = require('../..').data.maybe;

describe('Data.Maybe', function () {

  describe('Conversions', function () {
    property('Just#fromEither', 'json', function (a) {
      return _.fromEither(_.Just(a).toEither()).equals(_.Just(a));
    });
    property('Nothing#fromEither', 'json', function (a) {
      return _.fromEither(_.Nothing().toEither()).equals(_.Nothing());
    });
  });
});
},{"../..":53,"jsverify":368}],405:[function(require,module,exports){
'use strict';

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// Copyright (C) 2015-2016 Quildreen Motta.
// Licensed under the MIT licence.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

var _require = require('jsverify');

var property = _require.property;
var forall = _require.forall;

var _ = require('../..').data.validation;

describe('Data.Validation', function () {
  describe('Functor', function () {
    property('map', 'json', 'json -> json', function (a, f) {
      return _.of(f(a)).equals(_.of(a).map(f));
    });

    property('Failure#map', 'json', 'json -> json', function (a, f) {
      return _.Failure(a).map(f).equals(_.Failure(a));
    });
  });

  describe('Applicative', function () {

    property('of', 'json', 'json', function (a, b) {
      return a === b === _.of(a).equals(_.of(b));
    });
    property('Success#ap', 'string', 'string', 'string -> string -> string', function (a, b, f) {
      return _.Success(f).ap(_.Success(a)).ap(_.Success(b)).equals(_.Success(f(a)(b)));
    });
    property('Success/Failure#ap', 'string', 'string', 'string -> string -> string', function (a, b, f) {
      return _.Success(f).ap(_.Success(a)).ap(_.Failure(b)).equals(_.Failure(b));
    });
    property('Failure#ap', 'string', 'string', 'string -> string -> string', function (a, b, f) {
      return _.Success(f).ap(_.Failure(a)).ap(_.Failure(b)).equals(_.Failure(a.concat(b)));
    });
  });

  describe('Semigroup', function () {
    property('Failure#concat', 'string', 'string', function (a, b) {
      return _.Failure(a).concat(_.Failure(b)).equals(_.Failure(a.concat(b)));
    });
    property('Success#concat', 'string', 'string', function (a, b) {
      return _.Success(a).concat(_.Success(b)).equals(_.Success(b));
    });
    property('Success/Failure#concat', 'string', 'string', function (a, b, f) {
      return _.Success(a).concat(_.Failure(b)).equals(_.Failure(b));
    });
  });

  describe('extracting/recovering', function () {
    property('Failure#getOrElse', 'json', 'json', function (a, b) {
      return _.Failure(b).getOrElse(a) === a;
    });
    property('Success#getOrElse', 'json', 'json', function (a, b) {
      return _.Success(b).getOrElse(a) === b;
    });

    property('Failure#orElse', 'json', 'json', function (a, b) {
      return _.Failure(b).orElse(function () {
        return a;
      }) === a;
    });
    property('Success#orElse', 'json', 'json', function (a, b) {
      return _.Success(b).orElse(function () {
        return b;
      }).equals(_.Success(b));
    });
  });
  describe('folds', function () {
    var id = function id(a) {
      return a;
    };
    property('Failure#fold', 'json', 'json -> json', function (a, f) {
      return _.Success(a).fold(id, f) === f(a);
    });
    property('Success#fold', 'json', 'json -> json', function (a, f) {
      return _.Failure(a).fold(f, id) === f(a);
    });

    property('Failure#merge', 'json', function (a) {
      return _.Success(a).merge() === a;
    });
    property('Success#merge', 'json', function (a) {
      return _.Failure(a).merge() === a;
    });

    property('Failure#swap', 'json', function (a) {
      return _.Failure(a).swap().equals(_.Success(a));
    });
    property('Success#swap', 'json', function (a) {
      return _.Success(a).swap().equals(_.Failure(a));
    });

    property('Success#bimap', 'json', 'json -> json', function (a, f) {
      return _.Success(a).bimap(id, f).equals(_.Success(f(a)));
    });
    property('Failure#bimap', 'json', 'json -> json', function (a, f) {
      return _.Failure(a).bimap(f, id).equals(_.Failure(f(a)));
    });

    property('Failure#failureMap', 'json', 'json -> json', function (a, f) {
      return _.Failure(f(a)).equals(_.Failure(a).failureMap(f));
    });

    property('Success#failureMap', 'json', 'json -> json', function (a, f) {
      return _.Success(a).failureMap(f).equals(_.Success(a));
    });
  });
  describe('Conversions', function () {
    property('Failure#fromNullable', function () {
      return _.fromNullable(null).equals(_.Failure(null));
    });

    property('Success#fromNullable', 'json', function (a) {
      return _.fromNullable(a).equals(_.Success(a));
    });
    property('Validation#fromEither', 'json', function (a) {
      return _.fromEither(_.Success(a).toEither()).equals(_.Success(a));
    });
    property('Success#fromMaybe', 'json', 'json', function (a, b) {
      return _.fromMaybe(_.Success(a).toMaybe(), b).equals(_.Success(a));
    });
    property('Failure#fromMaybe', 'json', 'json', function (a, b) {
      return _.fromMaybe(_.Failure(b).toMaybe(), b).equals(_.Failure(b));
    });
  });
});
},{"../..":53,"jsverify":368}],406:[function(require,module,exports){
'use strict';

//----------------------------------------------------------------------
//
// This source file is part of the Folktale project.
//
// See LICENCE for licence information.
// See CONTRIBUTORS for the list of contributors to the project.
//
//----------------------------------------------------------------------

// This module runs all example-based tests defined in the documentation
var metamagical = require('metamagical-interface');
var defineTests = require('metamagical-mocha-bridge')(metamagical, describe, it);

defineTests(require('../..'));
},{"../..":53,"metamagical-interface":387,"metamagical-mocha-bridge":390}]},{},[400]);
